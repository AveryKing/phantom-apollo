"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langsmith";
exports.ids = ["vendor-chunks/langsmith"];
exports.modules = {

/***/ "(ssr)/./node_modules/langsmith/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/langsmith/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoBatchQueue: () => (/* binding */ AutoBatchQueue),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   DEFAULT_MAX_SIZE_BYTES: () => (/* binding */ DEFAULT_MAX_SIZE_BYTES),\n/* harmony export */   DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES: () => (/* binding */ DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES),\n/* harmony export */   mergeRuntimeEnvIntoRun: () => (/* binding */ mergeRuntimeEnvIntoRun)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _experimental_otel_translator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./experimental/otel/translator.js */ \"(ssr)/./node_modules/langsmith/dist/experimental/otel/translator.js\");\n/* harmony import */ var _singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./singletons/otel.js */ \"(ssr)/./node_modules/langsmith/dist/singletons/otel.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(ssr)/./node_modules/langsmith/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/messages.js */ \"(ssr)/./node_modules/langsmith/dist/utils/messages.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/env.js */ \"(ssr)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/langsmith/dist/index.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(ssr)/./node_modules/langsmith/dist/utils/_uuid.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/warn.js */ \"(ssr)/./node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/prompts.js */ \"(ssr)/./node_modules/langsmith/dist/utils/prompts.js\");\n/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/error.js */ \"(ssr)/./node_modules/langsmith/dist/utils/error.js\");\n/* harmony import */ var _utils_prompts_cache_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/prompts_cache.js */ \"(ssr)/./node_modules/langsmith/dist/utils/prompts_cache.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(ssr)/./node_modules/langsmith/dist/singletons/fetch.js\");\n/* harmony import */ var _utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/fast-safe-stringify/index.js */ \"(ssr)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction mergeRuntimeEnvIntoRun(run, cachedEnvVars, omitTracedRuntimeInfo) {\n    if (omitTracedRuntimeInfo) {\n        return run;\n    }\n    const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getRuntimeEnvironment)();\n    const envVars = cachedEnvVars ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvVarsMetadata)();\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n        ...extra,\n        runtime: {\n            ...runtimeEnv,\n            ...extra?.runtime,\n        },\n        metadata: {\n            ...envVars,\n            ...(envVars.revision_id || (\"revision_id\" in run && run.revision_id)\n                ? {\n                    revision_id: (\"revision_id\" in run ? run.revision_id : undefined) ??\n                        envVars.revision_id,\n                }\n                : {}),\n            ...metadata,\n        },\n    };\n    return run;\n}\nconst getTracingSamplingRate = (configRate) => {\n    const samplingRateStr = configRate?.toString() ??\n        (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async (response) => {\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"10\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve) => setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nfunction _formatFeedbackScore(score) {\n    if (typeof score === \"number\") {\n        // Truncate at 4 decimal places\n        return Number(score.toFixed(4));\n    }\n    return score;\n}\nconst DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES = 24 * 1024 * 1024;\n/** Default maximum memory (1GB) for queue size limits. */\nconst DEFAULT_MAX_SIZE_BYTES = 1024 * 1024 * 1024; // 1GB\nconst SERVER_INFO_REQUEST_TIMEOUT_MS = 10000;\n/** Maximum number of operations to batch in a single request. */\nconst DEFAULT_BATCH_SIZE_LIMIT = 100;\nconst DEFAULT_API_URL = \"https://api.smith.langchain.com\";\nclass AutoBatchQueue {\n    constructor(maxSizeBytes) {\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"sizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"maxSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSizeBytes = maxSizeBytes ?? DEFAULT_MAX_SIZE_BYTES;\n    }\n    peek() {\n        return this.items[0];\n    }\n    push(item) {\n        let itemPromiseResolve;\n        const itemPromise = new Promise((resolve) => {\n            // Setting itemPromiseResolve is synchronous with promise creation:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n            itemPromiseResolve = resolve;\n        });\n        const size = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(item.item, `Serializing run with id: ${item.item.id}`).length;\n        // Check if adding this item would exceed the size limit\n        // Allow the run if the queue is empty (to support large single traces)\n        if (this.sizeBytes + size > this.maxSizeBytes && this.items.length > 0) {\n            console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${item.item.id}. ` +\n                `Current queue size: ${this.sizeBytes} bytes, attempted addition: ${size} bytes.`);\n            // Resolve immediately to avoid blocking caller\n            itemPromiseResolve();\n            return itemPromise;\n        }\n        this.items.push({\n            action: item.action,\n            payload: item.item,\n            otelContext: item.otelContext,\n            apiKey: item.apiKey,\n            apiUrl: item.apiUrl,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            itemPromiseResolve: itemPromiseResolve,\n            itemPromise,\n            size,\n        });\n        this.sizeBytes += size;\n        return itemPromise;\n    }\n    pop({ upToSizeBytes, upToSize, }) {\n        if (upToSizeBytes < 1) {\n            throw new Error(\"Number of bytes to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        let poppedSizeBytes = 0;\n        // Pop items until we reach or exceed the size limit\n        while (poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes &&\n            this.items.length > 0 &&\n            popped.length < upToSize) {\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n                poppedSizeBytes += item.size;\n                this.sizeBytes -= item.size;\n            }\n        }\n        // If there is an item on the queue we were unable to pop,\n        // just return it as a single batch.\n        if (popped.length === 0 && this.items.length > 0) {\n            const item = this.items.shift();\n            popped.push(item);\n            poppedSizeBytes += item.size;\n            this.sizeBytes -= item.size;\n        }\n        return [\n            popped.map((it) => ({\n                action: it.action,\n                item: it.payload,\n                otelContext: it.otelContext,\n                apiKey: it.apiKey,\n                apiUrl: it.apiUrl,\n                size: it.size,\n            })),\n            () => popped.forEach((it) => it.itemPromiseResolve()),\n        ];\n    }\n}\nclass Client {\n    get _fetch() {\n        return this.fetchImplementation || (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_11__._getFetchImplementation)(this.debug);\n    }\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"workspaceId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"omitTracedRuntimeInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filteredPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"batchSizeBytesLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchSizeLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"settings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"blockOnRootRunFinalization\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGSMITH_TRACING_BACKGROUND\") === \"false\"\n        });\n        Object.defineProperty(this, \"traceBatchConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5\n        });\n        Object.defineProperty(this, \"_serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_getServerInfoPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"manualFlushMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"langSmithToOTELTranslator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchImplementation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cachedLSEnvVarsForMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"multipartStreamingDisabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"_multipartDisabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGSMITH_DEBUG\") === \"true\"\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        if (this.apiUrl.endsWith(\"/\")) {\n            this.apiUrl = this.apiUrl.slice(0, -1);\n        }\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        if (this.webUrl?.endsWith(\"/\")) {\n            this.webUrl = this.webUrl.slice(0, -1);\n        }\n        this.workspaceId = trimQuotes(config.workspaceId ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"WORKSPACE_ID\"));\n        this.timeout_ms = config.timeout_ms ?? 90_000;\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__.AsyncCaller({\n            ...(config.callerOptions ?? {}),\n            maxRetries: 4,\n            debug: config.debug ?? this.debug,\n        });\n        this.traceBatchConcurrency =\n            config.traceBatchConcurrency ?? this.traceBatchConcurrency;\n        if (this.traceBatchConcurrency < 1) {\n            throw new Error(\"Trace batch concurrency must be positive.\");\n        }\n        this.debug = config.debug ?? this.debug;\n        this.fetchImplementation = config.fetchImplementation;\n        // Use maxIngestMemoryBytes for both queues\n        const maxMemory = config.maxIngestMemoryBytes ?? DEFAULT_MAX_SIZE_BYTES;\n        this.batchIngestCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__.AsyncCaller({\n            maxRetries: 4,\n            maxConcurrency: this.traceBatchConcurrency,\n            maxQueueSizeBytes: maxMemory,\n            ...(config.callerOptions ?? {}),\n            onFailedResponseHook: handle429,\n            debug: config.debug ?? this.debug,\n        });\n        this.hideInputs =\n            config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n        this.hideOutputs =\n            config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n        this.omitTracedRuntimeInfo = config.omitTracedRuntimeInfo ?? false;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.autoBatchQueue = new AutoBatchQueue(maxMemory);\n        this.blockOnRootRunFinalization =\n            config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;\n        this.batchSizeBytesLimit = config.batchSizeBytesLimit;\n        this.batchSizeLimit = config.batchSizeLimit;\n        this.fetchOptions = config.fetchOptions || {};\n        this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;\n        if ((0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getOtelEnabled)()) {\n            this.langSmithToOTELTranslator = new _experimental_otel_translator_js__WEBPACK_IMPORTED_MODULE_0__.LangSmithToOTELTranslator();\n        }\n        // Cache metadata env vars once during construction to avoid repeatedly scanning process.env\n        this.cachedLSEnvVarsForMetadata = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvVarsMetadata)();\n        // Initialize cache\n        if (config.cache === true) {\n            this._cache = new _utils_prompts_cache_js__WEBPACK_IMPORTED_MODULE_10__.Cache();\n        }\n        else if (config.cache && typeof config.cache === \"object\") {\n            this._cache = config.cache;\n        }\n        else {\n            this._cache = undefined;\n        }\n    }\n    static getDefaultClientConfig() {\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"API_KEY\");\n        const apiUrl = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"ENDPOINT\") ?? DEFAULT_API_URL;\n        const hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"HIDE_INPUTS\") === \"true\";\n        const hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost:3000\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.endsWith(\"/api/v1\")) {\n            this.webUrl = this.apiUrl.replace(\"/api/v1\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n            this.webUrl = \"https://eu.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"beta\")) {\n            this.webUrl = \"https://beta.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return this.webUrl;\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${_index_js__WEBPACK_IMPORTED_MODULE_5__.__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        if (this.workspaceId) {\n            headers[\"x-tenant-id\"] = this.workspaceId;\n        }\n        return headers;\n    }\n    _getPlatformEndpointPath(path) {\n        // Check if apiUrl already ends with /v1 or /v1/ to avoid double /v1/v1/ paths\n        const needsV1Prefix = this.apiUrl.slice(-3) !== \"/v1\" && this.apiUrl.slice(-4) !== \"/v1/\";\n        return needsV1Prefix ? `/v1/platform/${path}` : `/platform/${path}`;\n    }\n    async processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    async processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    async prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = await this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = await this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `fetch ${path}`);\n            return res;\n        });\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(url, {\n                    method: \"GET\",\n                    headers: this.headers,\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `fetch ${path}`);\n                return res;\n            });\n            const items = transform\n                ? transform(await response.json())\n                : await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const body = JSON.stringify(bodyParams);\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(`${this.apiUrl}${path}`, {\n                    method: requestMethod,\n                    headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                    body,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `fetch ${path}`);\n                return res;\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    // Allows mocking for tests\n    _shouldSample() {\n        if (this.tracingSampleRate === undefined) {\n            return true;\n        }\n        return Math.random() < this.tracingSampleRate;\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (!this.filteredPostUuids.has(run.trace_id)) {\n                    sampled.push(run);\n                }\n                else if (run.id === run.trace_id) {\n                    this.filteredPostUuids.delete(run.trace_id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            // For new runs, sample at trace level to maintain consistency\n            const sampled = [];\n            for (const run of runs) {\n                const traceId = run.trace_id ?? run.id;\n                // If we've already made a decision about this trace, follow it\n                if (this.filteredPostUuids.has(traceId)) {\n                    continue;\n                }\n                // For new traces, apply sampling\n                if (run.id === traceId) {\n                    if (this._shouldSample()) {\n                        sampled.push(run);\n                    }\n                    else {\n                        this.filteredPostUuids.add(traceId);\n                    }\n                }\n                else {\n                    // Child runs follow their trace's sampling decision\n                    sampled.push(run);\n                }\n            }\n            return sampled;\n        }\n    }\n    async _getBatchSizeLimitBytes() {\n        const serverInfo = await this._ensureServerInfo();\n        return (this.batchSizeBytesLimit ??\n            serverInfo?.batch_ingest_config?.size_limit_bytes ??\n            DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES);\n    }\n    /**\n     * Get the maximum number of operations to batch in a single request.\n     */\n    async _getBatchSizeLimit() {\n        const serverInfo = await this._ensureServerInfo();\n        return (this.batchSizeLimit ??\n            serverInfo?.batch_ingest_config?.size_limit ??\n            DEFAULT_BATCH_SIZE_LIMIT);\n    }\n    async _getDatasetExamplesMultiPartSupport() {\n        const serverInfo = await this._ensureServerInfo();\n        return (serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false);\n    }\n    drainAutoBatchQueue({ batchSizeLimitBytes, batchSizeLimit, }) {\n        const promises = [];\n        while (this.autoBatchQueue.items.length > 0) {\n            const [batch, done] = this.autoBatchQueue.pop({\n                upToSizeBytes: batchSizeLimitBytes,\n                upToSize: batchSizeLimit,\n            });\n            if (!batch.length) {\n                done();\n                break;\n            }\n            const batchesByDestination = batch.reduce((acc, item) => {\n                const apiUrl = item.apiUrl ?? this.apiUrl;\n                const apiKey = item.apiKey ?? this.apiKey;\n                const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;\n                const batchKey = isDefault ? \"default\" : `${apiUrl}|${apiKey}`;\n                if (!acc[batchKey]) {\n                    acc[batchKey] = [];\n                }\n                acc[batchKey].push(item);\n                return acc;\n            }, {});\n            const batchPromises = [];\n            for (const [batchKey, batch] of Object.entries(batchesByDestination)) {\n                const batchPromise = this._processBatch(batch, {\n                    apiUrl: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[0],\n                    apiKey: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[1],\n                });\n                batchPromises.push(batchPromise);\n            }\n            // Wait for all batches to complete, then call the overall done callback\n            const allBatchesPromise = Promise.all(batchPromises).finally(done);\n            promises.push(allBatchesPromise);\n        }\n        return Promise.all(promises);\n    }\n    async _processBatch(batch, options) {\n        if (!batch.length) {\n            return;\n        }\n        // Calculate total batch size for queue tracking\n        const batchSizeBytes = batch.reduce((sum, item) => sum + (item.size ?? 0), 0);\n        try {\n            if (this.langSmithToOTELTranslator !== undefined) {\n                this._sendBatchToOTELTranslator(batch);\n            }\n            else {\n                const ingestParams = {\n                    runCreates: batch\n                        .filter((item) => item.action === \"create\")\n                        .map((item) => item.item),\n                    runUpdates: batch\n                        .filter((item) => item.action === \"update\")\n                        .map((item) => item.item),\n                };\n                const serverInfo = await this._ensureServerInfo();\n                const useMultipart = !this._multipartDisabled &&\n                    (serverInfo?.batch_ingest_config?.use_multipart_endpoint ?? true);\n                if (useMultipart) {\n                    const useGzip = serverInfo?.instance_flags?.gzip_body_enabled;\n                    try {\n                        await this.multipartIngestRuns(ingestParams, {\n                            ...options,\n                            useGzip,\n                            sizeBytes: batchSizeBytes,\n                        });\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    }\n                    catch (e) {\n                        if ((0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.isLangSmithNotFoundError)(e)) {\n                            // Fallback to batch ingest if multipart endpoint returns 404\n                            // Disable multipart for future requests\n                            this._multipartDisabled = true;\n                            await this.batchIngestRuns(ingestParams, {\n                                ...options,\n                                sizeBytes: batchSizeBytes,\n                            });\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                }\n                else {\n                    await this.batchIngestRuns(ingestParams, {\n                        ...options,\n                        sizeBytes: batchSizeBytes,\n                    });\n                }\n            }\n        }\n        catch (e) {\n            console.error(\"Error exporting batch:\", e);\n        }\n    }\n    _sendBatchToOTELTranslator(batch) {\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const otelContextMap = new Map();\n            const operations = [];\n            for (const item of batch) {\n                if (item.item.id && item.otelContext) {\n                    otelContextMap.set(item.item.id, item.otelContext);\n                    if (item.action === \"create\") {\n                        operations.push({\n                            operation: \"post\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item,\n                        });\n                    }\n                    else {\n                        operations.push({\n                            operation: \"patch\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item,\n                        });\n                    }\n                }\n            }\n            this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);\n        }\n    }\n    async processRunOperation(item) {\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        item.item = mergeRuntimeEnvIntoRun(item.item, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (this.manualFlushMode) {\n            // Rely on manual flushing in serverless environments\n            return itemPromise;\n        }\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        const sizeLimit = await this._getBatchSizeLimit();\n        if (this.autoBatchQueue.sizeBytes > sizeLimitBytes ||\n            this.autoBatchQueue.items.length > sizeLimit) {\n            void this.drainAutoBatchQueue({\n                batchSizeLimitBytes: sizeLimitBytes,\n                batchSizeLimit: sizeLimit,\n            });\n        }\n        if (this.autoBatchQueue.items.length > 0) {\n            this.autoBatchTimeout = setTimeout(() => {\n                this.autoBatchTimeout = undefined;\n                void this.drainAutoBatchQueue({\n                    batchSizeLimitBytes: sizeLimitBytes,\n                    batchSizeLimit: sizeLimit,\n                });\n            }, this.autoBatchAggregationDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/info`, {\n                method: \"GET\",\n                headers: { Accept: \"application/json\" },\n                signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT_MS),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get server info\");\n            return res;\n        });\n        const json = await response.json();\n        if (this.debug) {\n            console.log(\"\\n=== LangSmith Server Configuration ===\\n\" +\n                JSON.stringify(json, null, 2) +\n                \"\\n\");\n        }\n        return json;\n    }\n    async _ensureServerInfo() {\n        if (this._getServerInfoPromise === undefined) {\n            this._getServerInfoPromise = (async () => {\n                if (this._serverInfo === undefined) {\n                    try {\n                        this._serverInfo = await this._getServerInfo();\n                    }\n                    catch (e) {\n                        console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${e.status ?? \"Unspecified status code\"} ${e.message}`);\n                    }\n                }\n                return this._serverInfo ?? {};\n            })();\n        }\n        return this._getServerInfoPromise.then((serverInfo) => {\n            if (this._serverInfo === undefined) {\n                this._getServerInfoPromise = undefined;\n            }\n            return serverInfo;\n        });\n    }\n    async _getSettings() {\n        if (!this.settings) {\n            this.settings = this._get(\"/settings\");\n        }\n        return await this.settings;\n    }\n    /**\n     * Flushes current queued traces.\n     */\n    async flush() {\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        const sizeLimit = await this._getBatchSizeLimit();\n        await this.drainAutoBatchQueue({\n            batchSizeLimitBytes: sizeLimitBytes,\n            batchSizeLimit: sizeLimit,\n        });\n    }\n    _cloneCurrentOTELContext() {\n        const otel_trace = (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELTrace)();\n        const otel_context = (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELContext)();\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const currentSpan = otel_trace.getActiveSpan();\n            if (currentSpan) {\n                return otel_trace.setSpan(otel_context.active(), currentSpan);\n            }\n        }\n        return undefined;\n    }\n    async createRun(run, options) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = await this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n                otelContext,\n                apiKey: options?.apiKey,\n                apiUrl: options?.apiUrl,\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        if (options?.workspaceId !== undefined) {\n            headers[\"x-tenant-id\"] = options.workspaceId;\n        }\n        const body = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs`, {\n                method: \"POST\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create run\", true);\n            return res;\n        });\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = await Promise.all(runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? []);\n        let preparedUpdateParams = await Promise.all(runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? []);\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: preparedCreateParams,\n            patch: preparedUpdateParams,\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        const batchChunks = {\n            post: [],\n            patch: [],\n        };\n        for (const k of [\"post\", \"patch\"]) {\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while (batchItem !== undefined) {\n                // Type is wrong but this is a deprecated code path anyway\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            const runIds = batchChunks.post\n                .map((item) => item.id)\n                .concat(batchChunks.patch.map((item) => item.id))\n                .join(\",\");\n            await this._postBatchIngestRuns((0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(batchChunks, `Ingesting runs with ids: ${runIds}`), options);\n        }\n    }\n    async _postBatchIngestRuns(body, options) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        await this.batchIngestCaller.callWithOptions({ sizeBytes: options?.sizeBytes }, async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/batch`, {\n                method: \"POST\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"batch create run\", true);\n            return res;\n        });\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async multipartIngestRuns({ runCreates, runUpdates, }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        // transform and convert to dicts\n        const allAttachments = {};\n        let preparedCreateParams = [];\n        for (const create of runCreates ?? []) {\n            const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);\n            if (preparedCreate.id !== undefined &&\n                preparedCreate.attachments !== undefined) {\n                allAttachments[preparedCreate.id] = preparedCreate.attachments;\n            }\n            delete preparedCreate.attachments;\n            preparedCreateParams.push(preparedCreate);\n        }\n        let preparedUpdateParams = [];\n        for (const update of runUpdates ?? []) {\n            preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));\n        }\n        // require trace_id and dotted_order\n        const invalidRunCreate = preparedCreateParams.find((runCreate) => {\n            return (runCreate.trace_id === undefined || runCreate.dotted_order === undefined);\n        });\n        if (invalidRunCreate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run`);\n        }\n        const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {\n            return (runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined);\n        });\n        if (invalidRunUpdate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run`);\n        }\n        // combine post and patch dicts where possible\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        if (preparedCreateParams.length === 0 &&\n            preparedUpdateParams.length === 0) {\n            return;\n        }\n        // send the runs in multipart requests\n        const accumulatedContext = [];\n        const accumulatedParts = [];\n        for (const [method, payloads] of [\n            [\"post\", preparedCreateParams],\n            [\"patch\", preparedUpdateParams],\n        ]) {\n            for (const originalPayload of payloads) {\n                // collect fields to be sent as separate parts\n                const { inputs, outputs, events, extra, error, serialized, attachments, ...payload } = originalPayload;\n                const fields = { inputs, outputs, events, extra, error, serialized };\n                // encode the main run payload\n                const stringifiedPayload = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);\n                accumulatedParts.push({\n                    name: `${method}.${payload.id}`,\n                    payload: new Blob([stringifiedPayload], {\n                        type: `application/json; length=${stringifiedPayload.length}`, // encoding=gzip\n                    }),\n                });\n                // encode the fields we collected\n                for (const [key, value] of Object.entries(fields)) {\n                    if (value === undefined) {\n                        continue;\n                    }\n                    const stringifiedValue = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);\n                    accumulatedParts.push({\n                        name: `${method}.${payload.id}.${key}`,\n                        payload: new Blob([stringifiedValue], {\n                            type: `application/json; length=${stringifiedValue.length}`,\n                        }),\n                    });\n                }\n                // encode the attachments\n                if (payload.id !== undefined) {\n                    const attachments = allAttachments[payload.id];\n                    if (attachments) {\n                        delete allAttachments[payload.id];\n                        for (const [name, attachment] of Object.entries(attachments)) {\n                            let contentType;\n                            let content;\n                            if (Array.isArray(attachment)) {\n                                [contentType, content] = attachment;\n                            }\n                            else {\n                                contentType = attachment.mimeType;\n                                content = attachment.data;\n                            }\n                            // Validate that the attachment name doesn't contain a '.'\n                            if (name.includes(\".\")) {\n                                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. ` +\n                                    `Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);\n                                continue;\n                            }\n                            accumulatedParts.push({\n                                name: `attachment.${payload.id}.${name}`,\n                                payload: new Blob([content], {\n                                    type: `${contentType}; length=${content.byteLength}`,\n                                }),\n                            });\n                        }\n                    }\n                }\n                // compute context\n                accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);\n            }\n        }\n        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join(\"; \"), options);\n    }\n    async _createNodeFetchBody(parts, boundary) {\n        // Create multipart form data manually using Blobs\n        const chunks = [];\n        for (const part of parts) {\n            // Add field boundary\n            chunks.push(new Blob([`--${boundary}\\r\\n`]));\n            chunks.push(new Blob([\n                `Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`,\n                `Content-Type: ${part.payload.type}\\r\\n\\r\\n`,\n            ]));\n            chunks.push(part.payload);\n            chunks.push(new Blob([\"\\r\\n\"]));\n        }\n        // Add final boundary\n        chunks.push(new Blob([`--${boundary}--\\r\\n`]));\n        // Combine all chunks into a single Blob\n        const body = new Blob(chunks);\n        // Convert Blob to ArrayBuffer for compatibility\n        const arrayBuffer = await body.arrayBuffer();\n        return arrayBuffer;\n    }\n    async _createMultipartStream(parts, boundary) {\n        const encoder = new TextEncoder();\n        // Create a ReadableStream for streaming the multipart data\n        // Only do special handling if we're using node-fetch\n        const stream = new ReadableStream({\n            async start(controller) {\n                // Helper function to write a chunk to the stream\n                const writeChunk = async (chunk) => {\n                    if (typeof chunk === \"string\") {\n                        controller.enqueue(encoder.encode(chunk));\n                    }\n                    else {\n                        controller.enqueue(chunk);\n                    }\n                };\n                // Write each part to the stream\n                for (const part of parts) {\n                    // Write boundary and headers\n                    await writeChunk(`--${boundary}\\r\\n`);\n                    await writeChunk(`Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`);\n                    await writeChunk(`Content-Type: ${part.payload.type}\\r\\n\\r\\n`);\n                    // Write the payload\n                    const payloadStream = part.payload.stream();\n                    const reader = payloadStream.getReader();\n                    try {\n                        let result;\n                        while (!(result = await reader.read()).done) {\n                            controller.enqueue(result.value);\n                        }\n                    }\n                    finally {\n                        reader.releaseLock();\n                    }\n                    await writeChunk(\"\\r\\n\");\n                }\n                // Write final boundary\n                await writeChunk(`--${boundary}--\\r\\n`);\n                controller.close();\n            },\n        });\n        return stream;\n    }\n    async _sendMultipartRequest(parts, context, options) {\n        // Create multipart form data boundary\n        const boundary = \"----LangSmithFormBoundary\" + Math.random().toString(36).slice(2);\n        const isNodeFetch = (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_11__._globalFetchImplementationIsNodeFetch)();\n        const buildBuffered = () => this._createNodeFetchBody(parts, boundary);\n        const buildStream = () => this._createMultipartStream(parts, boundary);\n        const sendWithRetry = async (bodyFactory) => {\n            return this.batchIngestCaller.callWithOptions({ sizeBytes: options?.sizeBytes }, async () => {\n                const body = await bodyFactory();\n                const headers = {\n                    ...this.headers,\n                    \"Content-Type\": `multipart/form-data; boundary=${boundary}`,\n                };\n                if (options?.apiKey !== undefined) {\n                    headers[\"x-api-key\"] = options.apiKey;\n                }\n                let transformedBody = body;\n                if (options?.useGzip &&\n                    typeof body === \"object\" &&\n                    \"pipeThrough\" in body) {\n                    transformedBody = body.pipeThrough(new CompressionStream(\"gzip\"));\n                    headers[\"Content-Encoding\"] = \"gzip\";\n                }\n                const response = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/multipart`, {\n                    method: \"POST\",\n                    headers,\n                    body: transformedBody,\n                    duplex: \"half\",\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, `Failed to send multipart request`, true);\n                return response;\n            });\n        };\n        try {\n            let res;\n            let streamedAttempt = false;\n            // attempt stream only if not disabled and not using node-fetch or Bun\n            if (!isNodeFetch &&\n                !this.multipartStreamingDisabled &&\n                (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnv)() !== \"bun\") {\n                streamedAttempt = true;\n                res = await sendWithRetry(buildStream);\n            }\n            else {\n                res = await sendWithRetry(buildBuffered);\n            }\n            // if stream fails, fallback to buffered body\n            if ((!this.multipartStreamingDisabled || streamedAttempt) &&\n                res.status === 422 &&\n                (options?.apiUrl ?? this.apiUrl) !== DEFAULT_API_URL) {\n                console.warn(`Streaming multipart upload to ${options?.apiUrl ?? this.apiUrl}/runs/multipart failed. ` +\n                    `This usually means the host does not support chunked uploads. ` +\n                    `Retrying with a buffered upload for operation \"${context}\".`);\n                // Disable streaming for future requests\n                this.multipartStreamingDisabled = true;\n                // retry with fully-buffered body\n                res = await sendWithRetry(buildBuffered);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            // Re-throw 404 errors so caller can fall back to batch ingest\n            if ((0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.isLangSmithNotFoundError)(e)) {\n                throw e;\n            }\n            console.warn(`${e.message.trim()}\\n\\nContext: ${context}`);\n        }\n    }\n    async updateRun(runId, run, options) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        if (run.inputs) {\n            run.inputs = await this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = await this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            if (run.end_time !== undefined &&\n                data.parent_run_id === undefined &&\n                this.blockOnRootRunFinalization &&\n                !this.manualFlushMode) {\n                // Trigger batches as soon as a root trace ends and wait to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl,\n                }).catch(console.error);\n                return;\n            }\n            else {\n                void this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl,\n                }).catch(console.error);\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        if (options?.workspaceId !== undefined) {\n            headers[\"x-tenant-id\"] = options.workspaceId;\n        }\n        const body = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(run, `Serializing payload to update run with id: ${runId}`);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/${runId}`, {\n                method: \"PATCH\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update run\", true);\n            return res;\n        });\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            isRoot: false,\n            projectId: run.session_id,\n            traceId: run.trace_id,\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (childRun.dotted_order?.startsWith(run.dotted_order ?? \"\") &&\n                childRun.id !== run.id) {\n                if (!(childRun.parent_run_id in treemap)) {\n                    treemap[childRun.parent_run_id] = [];\n                }\n                treemap[childRun.parent_run_id].push(childRun);\n                runs[childRun.id] = childRun;\n            }\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param isRoot - Indicates whether to only return root runs.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param treeFilter - The filter string to apply on other runs in the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */\n    async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, order, } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [projectId];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName)\n                ? projectName\n                : [projectName];\n            const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const default_select = [\n            \"app_path\",\n            \"completion_cost\",\n            \"completion_tokens\",\n            \"dotted_order\",\n            \"end_time\",\n            \"error\",\n            \"events\",\n            \"extra\",\n            \"feedback_stats\",\n            \"first_token_time\",\n            \"id\",\n            \"inputs\",\n            \"name\",\n            \"outputs\",\n            \"parent_run_id\",\n            \"parent_run_ids\",\n            \"prompt_cost\",\n            \"prompt_tokens\",\n            \"reference_example_id\",\n            \"run_type\",\n            \"session_id\",\n            \"start_time\",\n            \"status\",\n            \"tags\",\n            \"total_cost\",\n            \"total_tokens\",\n            \"trace_id\",\n        ];\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n            select: select ? select : default_select,\n            is_root: isRoot,\n            order,\n        };\n        if (body.select.includes(\"child_run_ids\")) {\n            (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_7__.warnOnce)(\"Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.\");\n        }\n        let runsYielded = 0;\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            if (limit) {\n                if (runsYielded >= limit) {\n                    break;\n                }\n                if (runs.length + runsYielded > limit) {\n                    const newRuns = runs.slice(0, limit - runsYielded);\n                    yield* newRuns;\n                    break;\n                }\n                runsYielded += runs.length;\n                yield* runs;\n            }\n            else {\n                yield* runs;\n            }\n        }\n    }\n    async *listGroupRuns(props) {\n        const { projectId, projectName, groupBy, filter, startTime, endTime, limit, offset, } = props;\n        const sessionId = projectId || (await this.readProject({ projectName })).id;\n        const baseBody = {\n            session_id: sessionId,\n            group_by: groupBy,\n            filter,\n            start_time: startTime ? startTime.toISOString() : null,\n            end_time: endTime ? endTime.toISOString() : null,\n            limit: Number(limit) || 100,\n        };\n        let currentOffset = Number(offset) || 0;\n        const path = \"/runs/group\";\n        const url = `${this.apiUrl}${path}`;\n        while (true) {\n            const currentBody = {\n                ...baseBody,\n                offset: currentOffset,\n            };\n            // Remove undefined values from the payload\n            const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value]) => value !== undefined));\n            const body = JSON.stringify(filteredPayload);\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(url, {\n                    method: \"POST\",\n                    headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                    body,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `Failed to fetch ${path}`);\n                return res;\n            });\n            const items = await response.json();\n            const { groups, total } = items;\n            if (groups.length === 0) {\n                break;\n            }\n            for (const thread of groups) {\n                yield thread;\n            }\n            currentOffset += groups.length;\n            if (currentOffset >= total) {\n                break;\n            }\n        }\n    }\n    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType, }) {\n        let projectIds_ = projectIds || [];\n        if (projectNames) {\n            projectIds_ = [\n                ...(projectIds || []),\n                ...(await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))),\n            ];\n        }\n        const payload = {\n            id,\n            trace,\n            parent_run: parentRun,\n            run_type: runType,\n            session: projectIds_,\n            reference_example: referenceExampleIds,\n            start_time: startTime,\n            end_time: endTime,\n            error,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            is_root: isRoot,\n            data_source_type: dataSourceType,\n        };\n        // Remove undefined values from the payload\n        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== undefined));\n        const body = JSON.stringify(filteredPayload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/stats`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get run stats\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"](),\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"PUT\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"share run\");\n            return res;\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"unshare run\", true);\n            return res;\n        });\n    }\n    async readRunSharedLink(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read run shared link\");\n            return res;\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(shareToken);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"list shared runs\");\n            return res;\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read dataset shared schema\");\n            return res;\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"PUT\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"share dataset\");\n            return res;\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"unshare dataset\", true);\n            return res;\n        });\n    }\n    async readSharedDataset(shareToken) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(shareToken);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/datasets`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read shared dataset\");\n            return res;\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    /**\n     * Get shared examples.\n     *\n     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n     * @param {Object} [options] Additional options for listing the examples.\n     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n     * @returns {Promise<Example[]>} The shared examples.\n     */\n    async listSharedExamples(shareToken, options) {\n        const params = {};\n        if (options?.exampleIds) {\n            params.id = options.exampleIds;\n        }\n        const urlParams = new URLSearchParams();\n        Object.entries(params).forEach(([key, value]) => {\n            if (Array.isArray(value)) {\n                value.forEach((v) => urlParams.append(key, v));\n            }\n            else {\n                urlParams.append(key, value);\n            }\n        });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"list shared examples\");\n            return res;\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            if (\"detail\" in result) {\n                throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${Array.isArray(result.detail)\n                    ? result.detail.join(\"\\n\")\n                    : \"Unspecified error\"}`);\n            }\n            throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n        }\n        return result.map((example) => ({\n            ...example,\n            _hostUrl: this.getHostUrl(),\n        }));\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(endpoint, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create project\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = JSON.stringify({\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(endpoint, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update project\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async hasProject({ projectId, projectName, }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${path}?${params}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"has project\");\n            return res;\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async getProjectUrl({ projectId, projectName, }) {\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide either projectName or projectId\");\n        }\n        const project = await this.readProject({ projectId, projectName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n    }\n    async getDatasetUrl({ datasetId, datasetName, }) {\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const dataset = await this.readDataset({ datasetId, datasetName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, includeStats, datasetVersion, referenceFree, metadata, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        if (datasetVersion !== undefined) {\n            params.append(\"dataset_version\", datasetVersion);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId_);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/sessions/${projectId_}`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete session ${projectId_} (${projectName})`, true);\n            return res;\n        });\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"POST\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"upload CSV\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata, } = {}) {\n        const body = {\n            name,\n            description,\n            extra: metadata ? { metadata } : undefined,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        if (inputsSchema) {\n            body.inputs_schema_definition = inputsSchema;\n        }\n        if (outputsSchema) {\n            body.outputs_schema_definition = outputsSchema;\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create dataset\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async hasDataset({ datasetId, datasetName, }) {\n        try {\n            await this.readDataset({ datasetId, datasetName });\n            return true;\n        }\n        catch (e) {\n            if (\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            e instanceof Error &&\n                e.message.toLocaleLowerCase().includes(\"not found\")) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion, }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\"\n                ? fromVersion\n                : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString(),\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    /**\n     * Update a dataset\n     * @param props The dataset details to update\n     * @returns The updated dataset\n     */\n    async updateDataset(props) {\n        const { datasetId, datasetName, ...update } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(_datasetId);\n        const body = JSON.stringify(update);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update dataset\");\n            return res;\n        });\n        return (await response.json());\n    }\n    /**\n     * Updates a tag on a dataset.\n     *\n     * If the tag is already assigned to a different version of this dataset,\n     * the tag will be moved to the new version. The as_of parameter is used to\n     * determine which version of the dataset to apply the new tags to.\n     *\n     * It must be an exact version of the dataset to succeed. You can\n     * use the \"readDatasetVersion\" method to find the exact version\n     * to apply the tags to.\n     * @param params.datasetId The ID of the dataset to update. Must be provided if \"datasetName\" is not provided.\n     * @param params.datasetName The name of the dataset to update. Must be provided if \"datasetId\" is not provided.\n     * @param params.asOf The timestamp of the dataset to apply the new tags to.\n     * @param params.tag The new tag to apply to the dataset.\n     */\n    async updateDatasetTag(props) {\n        const { datasetId, datasetName, asOf, tag } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(_datasetId);\n        const body = JSON.stringify({\n            as_of: typeof asOf === \"string\" ? asOf : asOf.toISOString(),\n            tag,\n        });\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}/tags`, {\n                method: \"PUT\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update dataset tags\", true);\n            return res;\n        });\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async indexDataset({ datasetId, datasetName, tag, }) {\n        let datasetId_ = datasetId;\n        if (!datasetId_ && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (!datasetId_) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const data = {\n            tag: tag,\n        };\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/index`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"index dataset\");\n            return res;\n        });\n        await response.json();\n    }\n    /**\n     * Lets you run a similarity search query on a dataset.\n     *\n     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n     *\n     * @param inputs      The input on which to run the similarity search. Must have the\n     *                    same schema as the dataset.\n     *\n     * @param datasetId   The dataset to search for similar examples.\n     *\n     * @param limit       The maximum number of examples to return. Will return the top `limit` most\n     *                    similar examples in order of most similar to least similar. If no similar\n     *                    examples are found, random examples will be returned.\n     *\n     * @param filter      A filter string to apply to the search. Only examples will be returned that\n     *                    match the filter string. Some examples of filters\n     *\n     *                    - eq(metadata.mykey, \"value\")\n     *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n     *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n     *\n     * @returns           A list of similar examples.\n     *\n     *\n     * @example\n     * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n     * inputs = {\"text\": \"How many people live in Berlin?\"}\n     * limit = 5\n     * examples = await client.similarExamples(inputs, dataset_id, limit)\n     */\n    async similarExamples(inputs, datasetId, limit, { filter, } = {}) {\n        const data = {\n            limit: limit,\n            inputs: inputs,\n        };\n        if (filter !== undefined) {\n            data[\"filter\"] = filter;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/search`, {\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                method: \"POST\",\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"fetch similar examples\");\n            return res;\n        });\n        const result = await response.json();\n        return result[\"examples\"];\n    }\n    async createExample(inputsOrUpdate, outputs, options) {\n        if (isExampleCreate(inputsOrUpdate)) {\n            if (outputs !== undefined || options !== undefined) {\n                throw new Error(\"Cannot provide outputs or options when using ExampleCreate object\");\n            }\n        }\n        let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;\n        const datasetName_ = outputs\n            ? options?.datasetName\n            : inputsOrUpdate.dataset_name;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName: datasetName_ });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || new Date();\n        let data;\n        if (!isExampleCreate(inputsOrUpdate)) {\n            data = {\n                inputs: inputsOrUpdate,\n                outputs,\n                created_at: createdAt_?.toISOString(),\n                id: options?.exampleId,\n                metadata: options?.metadata,\n                split: options?.split,\n                source_run_id: options?.sourceRunId,\n                use_source_run_io: options?.useSourceRunIO,\n                use_source_run_attachments: options?.useSourceRunAttachments,\n                attachments: options?.attachments,\n            };\n        }\n        else {\n            data = inputsOrUpdate;\n        }\n        const response = await this._uploadExamplesMultipart(datasetId_, [data]);\n        const example = await this.readExample(response.example_ids?.[0] ?? uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"]());\n        return example;\n    }\n    async createExamples(propsOrUploads) {\n        if (Array.isArray(propsOrUploads)) {\n            if (propsOrUploads.length === 0) {\n                return [];\n            }\n            const uploads = propsOrUploads;\n            let datasetId_ = uploads[0].dataset_id;\n            const datasetName_ = uploads[0].dataset_name;\n            if (datasetId_ === undefined && datasetName_ === undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId\");\n            }\n            else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId, not both\");\n            }\n            else if (datasetId_ === undefined) {\n                const dataset = await this.readDataset({ datasetName: datasetName_ });\n                datasetId_ = dataset.id;\n            }\n            const response = await this._uploadExamplesMultipart(datasetId_, uploads);\n            const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));\n            return examples;\n        }\n        const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName, } = propsOrUploads;\n        if (inputs === undefined) {\n            throw new Error(\"Must provide inputs when using legacy parameters\");\n        }\n        let datasetId_ = datasetId;\n        const datasetName_ = datasetName;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName: datasetName_ });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs?.[idx],\n                metadata: metadata?.[idx],\n                split: splits?.[idx],\n                id: exampleIds?.[idx],\n                attachments: attachments?.[idx],\n                source_run_id: sourceRunIds?.[idx],\n                use_source_run_io: useSourceRunIOs?.[idx],\n                use_source_run_attachments: useSourceRunAttachments?.[idx],\n            };\n        });\n        const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);\n        const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));\n        return examples;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.isLangChainMessage)(message)) {\n                return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.convertLangChainMessageToExample)(message);\n            }\n            return message;\n        });\n        const finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.isLangChainMessage)(generations)\n            ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.convertLangChainMessageToExample)(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        const rawExample = await this._get(path);\n        const { attachment_urls, ...rest } = rawExample;\n        const example = rest;\n        if (attachment_urls) {\n            example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n                acc[key.slice(\"attachment.\".length)] = {\n                    presigned_url: value.presigned_url,\n                    mime_type: value.mime_type,\n                };\n                return acc;\n            }, {});\n        }\n        return example;\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (splits !== undefined) {\n            for (const split of splits) {\n                params.append(\"splits\", split);\n            }\n        }\n        if (metadata !== undefined) {\n            const serializedMetadata = JSON.stringify(metadata);\n            params.append(\"metadata\", serializedMetadata);\n        }\n        if (limit !== undefined) {\n            params.append(\"limit\", limit.toString());\n        }\n        if (offset !== undefined) {\n            params.append(\"offset\", offset.toString());\n        }\n        if (filter !== undefined) {\n            params.append(\"filter\", filter);\n        }\n        if (includeAttachments === true) {\n            [\"attachment_urls\", \"outputs\", \"metadata\"].forEach((field) => params.append(\"select\", field));\n        }\n        let i = 0;\n        for await (const rawExamples of this._getPaginated(\"/examples\", params)) {\n            for (const rawExample of rawExamples) {\n                const { attachment_urls, ...rest } = rawExample;\n                const example = rest;\n                if (attachment_urls) {\n                    example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n                        acc[key.slice(\"attachment.\".length)] = {\n                            presigned_url: value.presigned_url,\n                            mime_type: value.mime_type || undefined,\n                        };\n                        return acc;\n                    }, {});\n                }\n                yield example;\n                i++;\n            }\n            if (limit !== undefined && i >= limit) {\n                break;\n            }\n        }\n    }\n    async deleteExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    /**\n     * Delete multiple examples by ID.\n     * @param exampleIds - The IDs of the examples to delete\n     * @param options - Optional settings for deletion\n     * @param options.hardDelete - If true, permanently delete examples. If false (default), soft delete them.\n     */\n    async deleteExamples(exampleIds, options) {\n        // Validate all UUIDs\n        exampleIds.forEach((id) => (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id));\n        if (options?.hardDelete) {\n            // Hard delete uses POST to a different platform endpoint\n            const path = this._getPlatformEndpointPath(\"datasets/examples/delete\");\n            await this.caller.call(async () => {\n                const res = await this._fetch(`${this.apiUrl}${path}`, {\n                    method: \"POST\",\n                    headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                    body: JSON.stringify({\n                        example_ids: exampleIds,\n                        hard_delete: true,\n                    }),\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"hard delete examples\", true);\n                return res;\n            });\n        }\n        else {\n            // Soft delete uses DELETE with query params\n            const params = new URLSearchParams();\n            exampleIds.forEach((id) => params.append(\"example_ids\", id));\n            await this.caller.call(async () => {\n                const res = await this._fetch(`${this.apiUrl}/examples?${params.toString()}`, {\n                    method: \"DELETE\",\n                    headers: this.headers,\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete examples\", true);\n                return res;\n            });\n        }\n    }\n    async updateExample(exampleIdOrUpdate, update) {\n        let exampleId;\n        if (update) {\n            exampleId = exampleIdOrUpdate;\n        }\n        else {\n            exampleId = exampleIdOrUpdate.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        let updateToUse;\n        if (update) {\n            updateToUse = { id: exampleId, ...update };\n        }\n        else {\n            updateToUse = exampleIdOrUpdate;\n        }\n        let datasetId;\n        if (updateToUse.dataset_id !== undefined) {\n            datasetId = updateToUse.dataset_id;\n        }\n        else {\n            const example = await this.readExample(exampleId);\n            datasetId = example.dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, [updateToUse]);\n    }\n    async updateExamples(update) {\n        // We will naively get dataset id from first example and assume it works for all\n        let datasetId;\n        if (update[0].dataset_id === undefined) {\n            const example = await this.readExample(update[0].id);\n            datasetId = example.dataset_id;\n        }\n        else {\n            datasetId = update[0].dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, update);\n    }\n    /**\n     * Get dataset version by closest date or exact tag.\n     *\n     * Use this to resolve the nearest version to a given timestamp or for a given tag.\n     *\n     * @param options The options for getting the dataset version\n     * @param options.datasetId The ID of the dataset\n     * @param options.datasetName The name of the dataset\n     * @param options.asOf The timestamp of the dataset to retrieve\n     * @param options.tag The tag of the dataset to retrieve\n     * @returns The dataset version\n     */\n    async readDatasetVersion({ datasetId, datasetName, asOf, tag, }) {\n        let resolvedDatasetId;\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            resolvedDatasetId = dataset.id;\n        }\n        else {\n            resolvedDatasetId = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(resolvedDatasetId);\n        if ((asOf && tag) || (!asOf && !tag)) {\n            throw new Error(\"Exactly one of asOf and tag must be specified.\");\n        }\n        const params = new URLSearchParams();\n        if (asOf !== undefined) {\n            params.append(\"as_of\", typeof asOf === \"string\" ? asOf : asOf.toISOString());\n        }\n        if (tag !== undefined) {\n            params.append(\"tag\", tag);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {\n                method: \"GET\",\n                headers: { ...this.headers },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read dataset version\");\n            return res;\n        });\n        return await response.json();\n    }\n    async listDatasetSplits({ datasetId, datasetName, asOf, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const params = new URLSearchParams();\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n        return response;\n    }\n    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const data = {\n            split_name: splitName,\n            examples: exampleIds.map((id) => {\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id);\n                return id;\n            }),\n            remove,\n        };\n        const body = JSON.stringify(data);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/splits`, {\n                method: \"PUT\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update dataset splits\", true);\n            return res;\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId, }) {\n        if (!runId && !projectId) {\n            throw new Error(\"One of runId or projectId must be provided\");\n        }\n        if (runId && projectId) {\n            throw new Error(\"Only one of runId or projectId can be provided\");\n        }\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"](),\n            run_id: runId,\n            key,\n            score: _formatFeedbackScore(score),\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            comparative_experiment_id: comparativeExperimentId,\n            feedbackConfig,\n            session_id: projectId,\n        };\n        const body = JSON.stringify(feedback);\n        const url = `${this.apiUrl}/feedback`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create feedback\", true);\n            return res;\n        });\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = _formatFeedbackScore(score);\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const body = JSON.stringify(feedbackUpdate);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/feedback/${feedbackId}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update feedback\", true);\n            return res;\n        });\n    }\n    async readFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            for (const runId of runIds) {\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n                queryParams.append(\"run\", runId);\n            }\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId The ID of the run.\n     * @param feedbackKey The feedback key.\n     * @param options Additional options for the token.\n     * @param options.expiration The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */\n    async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig, } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig,\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            }\n            else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        }\n        else {\n            body[\"expires_in\"] = {\n                hours: 3,\n            };\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/feedback/tokens`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create presigned feedback token\");\n            return res;\n        });\n        return await response.json();\n    }\n    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id, }) {\n        if (experimentIds.length === 0) {\n            throw new Error(\"At least one experiment is required\");\n        }\n        if (!referenceDatasetId) {\n            referenceDatasetId = (await this.readProject({\n                projectId: experimentIds[0],\n            })).reference_dataset_id;\n        }\n        if (!referenceDatasetId == null) {\n            throw new Error(\"A reference dataset is required\");\n        }\n        const body = {\n            id,\n            name,\n            experiment_ids: experimentIds,\n            reference_dataset_id: referenceDatasetId,\n            description,\n            created_at: (createdAt ?? new Date())?.toISOString(),\n            extra: {},\n        };\n        if (metadata)\n            body.extra[\"metadata\"] = metadata;\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/comparative`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create comparative experiment\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */\n    async *listPresignedFeedbackTokens(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const params = new URLSearchParams({ run_id: runId });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n            yield* tokens;\n        }\n    }\n    _selectEvalResults(results) {\n        let results_;\n        if (\"results\" in results) {\n            results_ = results.results;\n        }\n        else if (Array.isArray(results)) {\n            results_ = results;\n        }\n        else {\n            results_ = [results];\n        }\n        return results_;\n    }\n    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const evalResults = this._selectEvalResults(evaluatorResponse);\n        const feedbacks = [];\n        for (const res of evalResults) {\n            let sourceInfo_ = sourceInfo || {};\n            if (res.evaluatorInfo) {\n                sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };\n            }\n            let runId_ = null;\n            if (res.targetRunId) {\n                runId_ = res.targetRunId;\n            }\n            else if (run) {\n                runId_ = run.id;\n            }\n            feedbacks.push(await this.createFeedback(runId_, res.key, {\n                score: res.score,\n                value: res.value,\n                comment: res.comment,\n                correction: res.correction,\n                sourceInfo: sourceInfo_,\n                sourceRunId: res.sourceRunId,\n                feedbackConfig: res.feedbackConfig,\n                feedbackSourceType: \"model\",\n            }));\n        }\n        return [evalResults, feedbacks];\n    }\n    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n        return results;\n    }\n    /**\n     * API for managing annotation queues\n     */\n    /**\n     * List the annotation queues on the LangSmith API.\n     * @param options - The options for listing annotation queues\n     * @param options.queueIds - The IDs of the queues to filter by\n     * @param options.name - The name of the queue to filter by\n     * @param options.nameContains - The substring that the queue name should contain\n     * @param options.limit - The maximum number of queues to return\n     * @returns An iterator of AnnotationQueue objects\n     */\n    async *listAnnotationQueues(options = {}) {\n        const { queueIds, name, nameContains, limit } = options;\n        const params = new URLSearchParams();\n        if (queueIds) {\n            queueIds.forEach((id, i) => {\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id, `queueIds[${i}]`);\n                params.append(\"ids\", id);\n            });\n        }\n        if (name)\n            params.append(\"name\", name);\n        if (nameContains)\n            params.append(\"name_contains\", nameContains);\n        params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n        let count = 0;\n        for await (const queues of this._getPaginated(\"/annotation-queues\", params)) {\n            yield* queues;\n            count++;\n            if (limit !== undefined && count >= limit)\n                break;\n        }\n    }\n    /**\n     * Create an annotation queue on the LangSmith API.\n     * @param options - The options for creating an annotation queue\n     * @param options.name - The name of the annotation queue\n     * @param options.description - The description of the annotation queue\n     * @param options.queueId - The ID of the annotation queue\n     * @returns The created AnnotationQueue object\n     */\n    async createAnnotationQueue(options) {\n        const { name, description, queueId, rubricInstructions } = options;\n        const body = {\n            name,\n            description,\n            id: queueId || uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"](),\n            rubric_instructions: rubricInstructions,\n        };\n        const serializedBody = JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== undefined)));\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Read an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to read\n     * @returns The AnnotationQueueWithDetails object\n     */\n    async readAnnotationQueue(queueId) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Update an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to update\n     * @param options - The options for updating the annotation queue\n     * @param options.name - The new name for the annotation queue\n     * @param options.description - The new description for the annotation queue\n     */\n    async updateAnnotationQueue(queueId, options) {\n        const { name, description, rubricInstructions } = options;\n        const body = JSON.stringify({\n            name,\n            description,\n            rubric_instructions: rubricInstructions,\n        });\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Delete an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to delete\n     */\n    async deleteAnnotationQueue(queueId) {\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n                method: \"DELETE\",\n                headers: { ...this.headers, Accept: \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Add runs to an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue\n     * @param runIds - The IDs of the runs to be added to the annotation queue\n     */\n    async addRunsToAnnotationQueue(queueId, runIds) {\n        const body = JSON.stringify(runIds.map((id, i) => (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id, `runIds[${i}]`).toString()));\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/runs`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"add runs to annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Get a run from an annotation queue at the specified index.\n     * @param queueId - The ID of the annotation queue\n     * @param index - The index of the run to retrieve\n     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n     * @throws {Error} If the run is not found at the given index or for other API-related errors\n     */\n    async getRunFromAnnotationQueue(queueId, index) {\n        const baseUrl = `/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/run`;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${baseUrl}/${index}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get run from annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Delete a run from an an annotation queue.\n     * @param queueId - The ID of the annotation queue to delete the run from\n     * @param queueRunId - The ID of the run to delete from the annotation queue\n     */\n    async deleteRunFromAnnotationQueue(queueId, queueRunId) {\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/runs/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueRunId, \"queueRunId\")}`, {\n                method: \"DELETE\",\n                headers: { ...this.headers, Accept: \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete run from annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Get the size of an annotation queue.\n     * @param queueId - The ID of the annotation queue\n     */\n    async getSizeFromAnnotationQueue(queueId) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/size`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get size from annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    async _currentTenantIsOwner(owner) {\n        const settings = await this._getSettings();\n        return owner == \"-\" || settings.tenant_handle === owner;\n    }\n    async _ownerConflictError(action, owner) {\n        const settings = await this._getSettings();\n        return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n    }\n    async _getLatestCommitHash(promptOwnerAndName) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get latest commit hash\");\n            return res;\n        });\n        const json = await response.json();\n        if (json.commits.length === 0) {\n            return undefined;\n        }\n        return json.commits[0].commit_hash;\n    }\n    async _likeOrUnlikePrompt(promptIdentifier, like) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const body = JSON.stringify({ like: like });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/likes/${owner}/${promptName}`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `${like ? \"like\" : \"unlike\"} prompt`);\n            return res;\n        });\n        return response.json();\n    }\n    async _getPromptUrl(promptIdentifier) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n            }\n            else {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n            }\n        }\n        else {\n            const settings = await this._getSettings();\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n            }\n            else {\n                return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n            }\n        }\n    }\n    async promptExists(promptIdentifier) {\n        const prompt = await this.getPrompt(promptIdentifier);\n        return !!prompt;\n    }\n    async likePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, true);\n    }\n    async unlikePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, false);\n    }\n    async *listCommits(promptOwnerAndName) {\n        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {\n            yield* commits;\n        }\n    }\n    async *listPrompts(options) {\n        const params = new URLSearchParams();\n        params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n        params.append(\"sort_direction\", \"desc\");\n        params.append(\"is_archived\", (!!options?.isArchived).toString());\n        if (options?.isPublic !== undefined) {\n            params.append(\"is_public\", options.isPublic.toString());\n        }\n        if (options?.query) {\n            params.append(\"query\", options.query);\n        }\n        for await (const prompts of this._getPaginated(\"/repos\", params, (res) => res.repos)) {\n            yield* prompts;\n        }\n    }\n    async getPrompt(promptIdentifier) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            if (res?.status === 404) {\n                return null;\n            }\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get prompt\");\n            return res;\n        });\n        const result = await response?.json();\n        if (result?.repo) {\n            return result.repo;\n        }\n        else {\n            return null;\n        }\n    }\n    async createPrompt(promptIdentifier, options) {\n        const settings = await this._getSettings();\n        if (options?.isPublic && !settings.tenant_handle) {\n            throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle.\n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"create a prompt\", owner);\n        }\n        const data = {\n            repo_handle: promptName,\n            ...(options?.description && { description: options.description }),\n            ...(options?.readme && { readme: options.readme }),\n            ...(options?.tags && { tags: options.tags }),\n            is_public: !!options?.isPublic,\n        };\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create prompt\");\n            return res;\n        });\n        const { repo } = await response.json();\n        return repo;\n    }\n    async createCommit(promptIdentifier, object, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash\n            ? await this._getLatestCommitHash(`${owner}/${promptName}`)\n            : options?.parentCommitHash;\n        const payload = {\n            manifest: JSON.parse(JSON.stringify(object)),\n            parent_commit: resolvedParentCommitHash,\n        };\n        const body = JSON.stringify(payload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create commit\");\n            return res;\n        });\n        const result = await response.json();\n        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n    }\n    /**\n     * Update examples with attachments using multipart form data.\n     * @param updates List of ExampleUpdateWithAttachments objects to upsert\n     * @returns Promise with the update response\n     */\n    async updateExamplesMultipart(datasetId, updates = []) {\n        return this._updateExamplesMultipart(datasetId, updates);\n    }\n    async _updateExamplesMultipart(datasetId, updates = []) {\n        if (!(await this._getDatasetExamplesMultiPartSupport())) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of updates) {\n            const exampleId = example.id;\n            // Prepare the main example body\n            const exampleBody = {\n                ...(example.metadata && { metadata: example.metadata }),\n                ...(example.split && { split: example.split }),\n            };\n            // Add main example data\n            const stringifiedExample = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(exampleBody, `Serializing body for example with id: ${exampleId}`);\n            const exampleBlob = new Blob([stringifiedExample], {\n                type: \"application/json\",\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(example.inputs, `Serializing inputs for example with id: ${exampleId}`);\n                const inputsBlob = new Blob([stringifiedInputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);\n                const outputsBlob = new Blob([stringifiedOutputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)) {\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    }\n                    else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([data], {\n                        type: `${mimeType}; length=${data.byteLength}`,\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n            if (example.attachments_operations) {\n                const stringifiedAttachmentsOperations = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);\n                const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);\n            }\n        }\n        const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {\n                method: \"PATCH\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update examples\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Upload examples with attachments using multipart form data.\n     * @param uploads List of ExampleUploadWithAttachments objects to upload\n     * @returns Promise with the upload response\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead\n     */\n    async uploadExamplesMultipart(datasetId, uploads = []) {\n        return this._uploadExamplesMultipart(datasetId, uploads);\n    }\n    async _uploadExamplesMultipart(datasetId, uploads = []) {\n        if (!(await this._getDatasetExamplesMultiPartSupport())) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of uploads) {\n            const exampleId = (example.id ?? uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"]()).toString();\n            // Prepare the main example body\n            const exampleBody = {\n                created_at: example.created_at,\n                ...(example.metadata && { metadata: example.metadata }),\n                ...(example.split && { split: example.split }),\n                ...(example.source_run_id && { source_run_id: example.source_run_id }),\n                ...(example.use_source_run_io && {\n                    use_source_run_io: example.use_source_run_io,\n                }),\n                ...(example.use_source_run_attachments && {\n                    use_source_run_attachments: example.use_source_run_attachments,\n                }),\n            };\n            // Add main example data\n            const stringifiedExample = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);\n            const exampleBlob = new Blob([stringifiedExample], {\n                type: \"application/json\",\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);\n                const inputsBlob = new Blob([stringifiedInputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_12__.serialize)(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);\n                const outputsBlob = new Blob([stringifiedOutputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)) {\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    }\n                    else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([data], {\n                        type: `${mimeType}; length=${data.byteLength}`,\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {\n                method: \"POST\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"upload examples\");\n            return res;\n        });\n        return response.json();\n    }\n    async updatePrompt(promptIdentifier, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"update a prompt\", owner);\n        }\n        const payload = {};\n        if (options?.description !== undefined)\n            payload.description = options.description;\n        if (options?.readme !== undefined)\n            payload.readme = options.readme;\n        if (options?.tags !== undefined)\n            payload.tags = options.tags;\n        if (options?.isPublic !== undefined)\n            payload.is_public = options.isPublic;\n        if (options?.isArchived !== undefined)\n            payload.is_archived = options.isArchived;\n        // Check if payload is empty\n        if (Object.keys(payload).length === 0) {\n            throw new Error(\"No valid update options provided\");\n        }\n        const body = JSON.stringify(payload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"PATCH\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\",\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update prompt\");\n            return res;\n        });\n        return response.json();\n    }\n    async deletePrompt(promptIdentifier) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"delete a prompt\", owner);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete prompt\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Generate a cache key for a prompt.\n     * Format: \"{identifier}\" or \"{identifier}:with_model\"\n     */\n    _getPromptCacheKey(promptIdentifier, includeModel) {\n        const suffix = includeModel ? \":with_model\" : \"\";\n        return `${promptIdentifier}${suffix}`;\n    }\n    /**\n     * Fetch a prompt commit directly from the API (bypassing cache).\n     */\n    async _fetchPromptFromApi(promptIdentifier, options) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"pull prompt commit\");\n            return res;\n        });\n        const result = await response.json();\n        return {\n            owner,\n            repo: promptName,\n            commit_hash: result.commit_hash,\n            manifest: result.manifest,\n            examples: result.examples,\n        };\n    }\n    async pullPromptCommit(promptIdentifier, options) {\n        // Check cache first if not skipped\n        if (!options?.skipCache && this._cache) {\n            const cacheKey = this._getPromptCacheKey(promptIdentifier, options?.includeModel);\n            const cached = this._cache.get(cacheKey);\n            if (cached) {\n                return cached;\n            }\n            // Cache miss - fetch from API and cache it\n            const result = await this._fetchPromptFromApi(promptIdentifier, options);\n            this._cache.set(cacheKey, result);\n            return result;\n        }\n        // No cache or skip cache - fetch directly\n        return this._fetchPromptFromApi(promptIdentifier, options);\n    }\n    /**\n     * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n     * @private\n     */\n    async _pullPrompt(promptIdentifier, options) {\n        const promptObject = await this.pullPromptCommit(promptIdentifier, {\n            includeModel: options?.includeModel,\n            skipCache: options?.skipCache,\n        });\n        const prompt = JSON.stringify(promptObject.manifest);\n        return prompt;\n    }\n    async pushPrompt(promptIdentifier, options) {\n        // Create or update prompt metadata\n        if (await this.promptExists(promptIdentifier)) {\n            if (options && Object.keys(options).some((key) => key !== \"object\")) {\n                await this.updatePrompt(promptIdentifier, {\n                    description: options?.description,\n                    readme: options?.readme,\n                    tags: options?.tags,\n                    isPublic: options?.isPublic,\n                });\n            }\n        }\n        else {\n            await this.createPrompt(promptIdentifier, {\n                description: options?.description,\n                readme: options?.readme,\n                tags: options?.tags,\n                isPublic: options?.isPublic,\n            });\n        }\n        if (!options?.object) {\n            return await this._getPromptUrl(promptIdentifier);\n        }\n        // Create a commit with the new manifest\n        const url = await this.createCommit(promptIdentifier, options?.object, {\n            parentCommitHash: options?.parentCommitHash,\n        });\n        return url;\n    }\n    /**\n     * Clone a public dataset to your own langsmith tenant.\n     * This operation is idempotent. If you already have a dataset with the given name,\n     * this function will do nothing.\n  \n     * @param {string} tokenOrUrl The token of the public dataset to clone.\n     * @param {Object} [options] Additional options for cloning the dataset.\n     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n     * @returns {Promise<void>}\n     */\n    async clonePublicDataset(tokenOrUrl, options = {}) {\n        const { sourceApiUrl = this.apiUrl, datasetName } = options;\n        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n        const sourceClient = new Client({\n            apiUrl: parsedApiUrl,\n            // Placeholder API key not needed anymore in most cases, but\n            // some private deployments may have API key-based rate limiting\n            // that would cause this to fail if we provide no value.\n            apiKey: \"placeholder\",\n        });\n        const ds = await sourceClient.readSharedDataset(tokenUuid);\n        const finalDatasetName = datasetName || ds.name;\n        try {\n            if (await this.hasDataset({ datasetId: finalDatasetName })) {\n                console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n                return;\n            }\n        }\n        catch (_) {\n            // `.hasDataset` will throw an error if the dataset does not exist.\n            // no-op in that case\n        }\n        // Fetch examples first, then create the dataset\n        const examples = await sourceClient.listSharedExamples(tokenUuid);\n        const dataset = await this.createDataset(finalDatasetName, {\n            description: ds.description,\n            dataType: ds.data_type || \"kv\",\n            inputsSchema: ds.inputs_schema_definition ?? undefined,\n            outputsSchema: ds.outputs_schema_definition ?? undefined,\n        });\n        try {\n            await this.createExamples({\n                inputs: examples.map((e) => e.inputs),\n                outputs: examples.flatMap((e) => (e.outputs ? [e.outputs] : [])),\n                datasetId: dataset.id,\n            });\n        }\n        catch (e) {\n            console.error(`An error occurred while creating dataset ${finalDatasetName}. ` +\n                \"You should delete it manually.\");\n            throw e;\n        }\n    }\n    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n        // Try parsing as UUID\n        try {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(urlOrToken); // Will throw if it's not a UUID.\n            return [apiUrl, urlOrToken];\n        }\n        catch (_) {\n            // no-op if it's not a uuid\n        }\n        // Parse as URL\n        try {\n            const parsedUrl = new URL(urlOrToken);\n            const pathParts = parsedUrl.pathname\n                .split(\"/\")\n                .filter((part) => part !== \"\");\n            if (pathParts.length >= numParts) {\n                const tokenUuid = pathParts[pathParts.length - numParts];\n                return [apiUrl, tokenUuid];\n            }\n            else {\n                throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n        }\n    }\n    /**\n     * Get the cache instance, if caching is enabled.\n     * Useful for accessing cache metrics or manually managing the cache.\n     */\n    get cache() {\n        return this._cache;\n    }\n    /**\n     * Cleanup resources held by the client.\n     * Stops the cache's background refresh timer.\n     */\n    cleanup() {\n        if (this._cache) {\n            this._cache.stop();\n        }\n    }\n    /**\n     * Awaits all pending trace batches. Useful for environments where\n     * you need to be sure that all tracing requests finish before execution ends,\n     * such as serverless environments.\n     *\n     * @example\n     * ```\n     * import { Client } from \"langsmith\";\n     *\n     * const client = new Client();\n     *\n     * try {\n     *   // Tracing happens here\n     *   ...\n     * } finally {\n     *   await client.awaitPendingTraceBatches();\n     * }\n     * ```\n     *\n     * @returns A promise that resolves once all currently pending traces have sent.\n     */\n    async awaitPendingTraceBatches() {\n        if (this.manualFlushMode) {\n            console.warn(\"[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.\");\n            return Promise.resolve();\n        }\n        /**\n         * traceables use a backgrounded promise before updating runs to avoid blocking\n         * and to allow waiting for child runs to end. Waiting a small amount of time\n         * here ensures that they are able to enqueue their run operation before we await\n         * queued run operations below:\n         *\n         * ```ts\n         * const run = await traceable(async () => {\n         *   return \"Hello, world!\";\n         * }, { client })();\n         *\n         * await client.awaitPendingTraceBatches();\n         * ```\n         */\n        await new Promise((resolve) => setTimeout(resolve, 1));\n        await Promise.all([\n            ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),\n            this.batchIngestCaller.queue.onIdle(),\n        ]);\n        if (this.langSmithToOTELTranslator !== undefined) {\n            await (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOTLPTracerComponents)()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();\n        }\n    }\n}\nfunction isExampleCreate(input) {\n    return \"dataset_id\" in input || \"dataset_name\" in input;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkI7QUFDa0Q7QUFDc0I7QUFDL0M7QUFDc0M7QUFDMEU7QUFDN0g7QUFDSztBQUNIO0FBQ2dCO0FBQ2lCO0FBQzNCO0FBQ3VEO0FBQ1Q7QUFDeEY7QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0VBQXFCO0FBQzVDLHFDQUFxQywwRUFBMkI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOEVBQStCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csYUFBYTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPLG1EQUFtRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQiwrRUFBMEIsd0NBQXdDLGFBQWE7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG1CQUFtQix5Q0FBeUMsYUFBYTtBQUNoSSx1Q0FBdUMsZ0JBQWdCLDZCQUE2QixNQUFNO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQ0FBMkMsOEVBQXVCO0FBQ2xFO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFFQUFzQjtBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFFQUFzQjtBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw4RUFBK0I7QUFDM0Y7QUFDQSwwQkFBMEIsK0RBQVc7QUFDckMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1GQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXVpZCBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgTGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciwgfSBmcm9tIFwiLi9leHBlcmltZW50YWwvb3RlbC90cmFuc2xhdG9yLmpzXCI7XG5pbXBvcnQgeyBnZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMsIGdldE9URUxUcmFjZSwgZ2V0T1RFTENvbnRleHQsIH0gZnJvbSBcIi4vc2luZ2xldG9ucy9vdGVsLmpzXCI7XG5pbXBvcnQgeyBBc3luY0NhbGxlciB9IGZyb20gXCIuL3V0aWxzL2FzeW5jX2NhbGxlci5qc1wiO1xuaW1wb3J0IHsgY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUsIGlzTGFuZ0NoYWluTWVzc2FnZSwgfSBmcm9tIFwiLi91dGlscy9tZXNzYWdlcy5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0TGFuZ1NtaXRoRW52VmFyc01ldGFkYXRhLCBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRSdW50aW1lRW52aXJvbm1lbnQsIGdldE90ZWxFbmFibGVkLCBnZXRFbnYsIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBfX3ZlcnNpb25fXyB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRVdWlkIH0gZnJvbSBcIi4vdXRpbHMvX3V1aWQuanNcIjtcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSBcIi4vdXRpbHMvd2Fybi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VQcm9tcHRJZGVudGlmaWVyIH0gZnJvbSBcIi4vdXRpbHMvcHJvbXB0cy5qc1wiO1xuaW1wb3J0IHsgcmFpc2VGb3JTdGF0dXMsIGlzTGFuZ1NtaXRoTm90Rm91bmRFcnJvciB9IGZyb20gXCIuL3V0aWxzL2Vycm9yLmpzXCI7XG5pbXBvcnQgeyBDYWNoZSB9IGZyb20gXCIuL3V0aWxzL3Byb21wdHNfY2FjaGUuanNcIjtcbmltcG9ydCB7IF9nbG9iYWxGZXRjaEltcGxlbWVudGF0aW9uSXNOb2RlRmV0Y2gsIF9nZXRGZXRjaEltcGxlbWVudGF0aW9uLCB9IGZyb20gXCIuL3NpbmdsZXRvbnMvZmV0Y2guanNcIjtcbmltcG9ydCB7IHNlcmlhbGl6ZSBhcyBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyB9IGZyb20gXCIuL3V0aWxzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuKHJ1biwgY2FjaGVkRW52VmFycywgb21pdFRyYWNlZFJ1bnRpbWVJbmZvKSB7XG4gICAgaWYgKG9taXRUcmFjZWRSdW50aW1lSW5mbykge1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBjb25zdCBydW50aW1lRW52ID0gZ2V0UnVudGltZUVudmlyb25tZW50KCk7XG4gICAgY29uc3QgZW52VmFycyA9IGNhY2hlZEVudlZhcnMgPz8gZ2V0TGFuZ1NtaXRoRW52VmFyc01ldGFkYXRhKCk7XG4gICAgY29uc3QgZXh0cmEgPSBydW4uZXh0cmEgPz8ge307XG4gICAgY29uc3QgbWV0YWRhdGEgPSBleHRyYS5tZXRhZGF0YTtcbiAgICBydW4uZXh0cmEgPSB7XG4gICAgICAgIC4uLmV4dHJhLFxuICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAuLi5ydW50aW1lRW52LFxuICAgICAgICAgICAgLi4uZXh0cmE/LnJ1bnRpbWUsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAuLi5lbnZWYXJzLFxuICAgICAgICAgICAgLi4uKGVudlZhcnMucmV2aXNpb25faWQgfHwgKFwicmV2aXNpb25faWRcIiBpbiBydW4gJiYgcnVuLnJldmlzaW9uX2lkKVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICByZXZpc2lvbl9pZDogKFwicmV2aXNpb25faWRcIiBpbiBydW4gPyBydW4ucmV2aXNpb25faWQgOiB1bmRlZmluZWQpID8/XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnZWYXJzLnJldmlzaW9uX2lkLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHJ1bjtcbn1cbmNvbnN0IGdldFRyYWNpbmdTYW1wbGluZ1JhdGUgPSAoY29uZmlnUmF0ZSkgPT4ge1xuICAgIGNvbnN0IHNhbXBsaW5nUmF0ZVN0ciA9IGNvbmZpZ1JhdGU/LnRvU3RyaW5nKCkgPz9cbiAgICAgICAgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlRSQUNJTkdfU0FNUExJTkdfUkFURVwiKTtcbiAgICBpZiAoc2FtcGxpbmdSYXRlU3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc2FtcGxpbmdSYXRlID0gcGFyc2VGbG9hdChzYW1wbGluZ1JhdGVTdHIpO1xuICAgIGlmIChzYW1wbGluZ1JhdGUgPCAwIHx8IHNhbXBsaW5nUmF0ZSA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMQU5HU01JVEhfVFJBQ0lOR19TQU1QTElOR19SQVRFIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxIGlmIHNldC4gR290OiAke3NhbXBsaW5nUmF0ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNhbXBsaW5nUmF0ZTtcbn07XG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuY29uc3QgaXNMb2NhbGhvc3QgPSAodXJsKSA9PiB7XG4gICAgY29uc3Qgc3RyaXBwZWRVcmwgPSB1cmwucmVwbGFjZShcImh0dHA6Ly9cIiwgXCJcIikucmVwbGFjZShcImh0dHBzOi8vXCIsIFwiXCIpO1xuICAgIGNvbnN0IGhvc3RuYW1lID0gc3RyaXBwZWRVcmwuc3BsaXQoXCIvXCIpWzBdLnNwbGl0KFwiOlwiKVswXTtcbiAgICByZXR1cm4gKGhvc3RuYW1lID09PSBcImxvY2FsaG9zdFwiIHx8IGhvc3RuYW1lID09PSBcIjEyNy4wLjAuMVwiIHx8IGhvc3RuYW1lID09PSBcIjo6MVwiKTtcbn07XG5hc3luYyBmdW5jdGlvbiB0b0FycmF5KGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHJpbVF1b3RlcyhzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKC9eXCIoLiopXCIkLywgXCIkMVwiKVxuICAgICAgICAucmVwbGFjZSgvXicoLiopJyQvLCBcIiQxXCIpO1xufVxuY29uc3QgaGFuZGxlNDI5ID0gYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKHJlc3BvbnNlPy5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gcGFyc2VJbnQocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJyZXRyeS1hZnRlclwiKSA/PyBcIjEwXCIsIDEwKSAqIDEwMDA7XG4gICAgICAgIGlmIChyZXRyeUFmdGVyID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlBZnRlcikpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGRpcmVjdGx5IGFmdGVyIGNhbGxpbmcgdGhpcyBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmFsbCBiYWNrIHRvIGV4aXN0aW5nIHN0YXR1cyBjaGVja3NcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZnVuY3Rpb24gX2Zvcm1hdEZlZWRiYWNrU2NvcmUoc2NvcmUpIHtcbiAgICBpZiAodHlwZW9mIHNjb3JlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8vIFRydW5jYXRlIGF0IDQgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgcmV0dXJuIE51bWJlcihzY29yZS50b0ZpeGVkKDQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3JlO1xufVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVU5DT01QUkVTU0VEX0JBVENIX1NJWkVfTElNSVRfQllURVMgPSAyNCAqIDEwMjQgKiAxMDI0O1xuLyoqIERlZmF1bHQgbWF4aW11bSBtZW1vcnkgKDFHQikgZm9yIHF1ZXVlIHNpemUgbGltaXRzLiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX1NJWkVfQllURVMgPSAxMDI0ICogMTAyNCAqIDEwMjQ7IC8vIDFHQlxuY29uc3QgU0VSVkVSX0lORk9fUkVRVUVTVF9USU1FT1VUX01TID0gMTAwMDA7XG4vKiogTWF4aW11bSBudW1iZXIgb2Ygb3BlcmF0aW9ucyB0byBiYXRjaCBpbiBhIHNpbmdsZSByZXF1ZXN0LiAqL1xuY29uc3QgREVGQVVMVF9CQVRDSF9TSVpFX0xJTUlUID0gMTAwO1xuY29uc3QgREVGQVVMVF9BUElfVVJMID0gXCJodHRwczovL2FwaS5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG5leHBvcnQgY2xhc3MgQXV0b0JhdGNoUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKG1heFNpemVCeXRlcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpdGVtc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpemVCeXRlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4U2l6ZUJ5dGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4U2l6ZUJ5dGVzID0gbWF4U2l6ZUJ5dGVzID8/IERFRkFVTFRfTUFYX1NJWkVfQllURVM7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zWzBdO1xuICAgIH1cbiAgICBwdXNoKGl0ZW0pIHtcbiAgICAgICAgbGV0IGl0ZW1Qcm9taXNlUmVzb2x2ZTtcbiAgICAgICAgY29uc3QgaXRlbVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgLy8gU2V0dGluZyBpdGVtUHJvbWlzZVJlc29sdmUgaXMgc3luY2hyb25vdXMgd2l0aCBwcm9taXNlIGNyZWF0aW9uOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9Qcm9taXNlXG4gICAgICAgICAgICBpdGVtUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGl0ZW0uaXRlbSwgYFNlcmlhbGl6aW5nIHJ1biB3aXRoIGlkOiAke2l0ZW0uaXRlbS5pZH1gKS5sZW5ndGg7XG4gICAgICAgIC8vIENoZWNrIGlmIGFkZGluZyB0aGlzIGl0ZW0gd291bGQgZXhjZWVkIHRoZSBzaXplIGxpbWl0XG4gICAgICAgIC8vIEFsbG93IHRoZSBydW4gaWYgdGhlIHF1ZXVlIGlzIGVtcHR5ICh0byBzdXBwb3J0IGxhcmdlIHNpbmdsZSB0cmFjZXMpXG4gICAgICAgIGlmICh0aGlzLnNpemVCeXRlcyArIHNpemUgPiB0aGlzLm1heFNpemVCeXRlcyAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQXV0b0JhdGNoUXVldWUgc2l6ZSBsaW1pdCAoJHt0aGlzLm1heFNpemVCeXRlc30gYnl0ZXMpIGV4Y2VlZGVkLiBEcm9wcGluZyBydW4gd2l0aCBpZDogJHtpdGVtLml0ZW0uaWR9LiBgICtcbiAgICAgICAgICAgICAgICBgQ3VycmVudCBxdWV1ZSBzaXplOiAke3RoaXMuc2l6ZUJ5dGVzfSBieXRlcywgYXR0ZW1wdGVkIGFkZGl0aW9uOiAke3NpemV9IGJ5dGVzLmApO1xuICAgICAgICAgICAgLy8gUmVzb2x2ZSBpbW1lZGlhdGVseSB0byBhdm9pZCBibG9ja2luZyBjYWxsZXJcbiAgICAgICAgICAgIGl0ZW1Qcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICBhY3Rpb246IGl0ZW0uYWN0aW9uLFxuICAgICAgICAgICAgcGF5bG9hZDogaXRlbS5pdGVtLFxuICAgICAgICAgICAgb3RlbENvbnRleHQ6IGl0ZW0ub3RlbENvbnRleHQsXG4gICAgICAgICAgICBhcGlLZXk6IGl0ZW0uYXBpS2V5LFxuICAgICAgICAgICAgYXBpVXJsOiBpdGVtLmFwaVVybCxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBpdGVtUHJvbWlzZVJlc29sdmU6IGl0ZW1Qcm9taXNlUmVzb2x2ZSxcbiAgICAgICAgICAgIGl0ZW1Qcm9taXNlLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2l6ZUJ5dGVzICs9IHNpemU7XG4gICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICB9XG4gICAgcG9wKHsgdXBUb1NpemVCeXRlcywgdXBUb1NpemUsIH0pIHtcbiAgICAgICAgaWYgKHVwVG9TaXplQnl0ZXMgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgb2YgYnl0ZXMgdG8gcG9wIG9mZiBtYXkgbm90IGJlIGxlc3MgdGhhbiAxLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3BwZWQgPSBbXTtcbiAgICAgICAgbGV0IHBvcHBlZFNpemVCeXRlcyA9IDA7XG4gICAgICAgIC8vIFBvcCBpdGVtcyB1bnRpbCB3ZSByZWFjaCBvciBleGNlZWQgdGhlIHNpemUgbGltaXRcbiAgICAgICAgd2hpbGUgKHBvcHBlZFNpemVCeXRlcyArICh0aGlzLnBlZWsoKT8uc2l6ZSA/PyAwKSA8IHVwVG9TaXplQnl0ZXMgJiZcbiAgICAgICAgICAgIHRoaXMuaXRlbXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgcG9wcGVkLmxlbmd0aCA8IHVwVG9TaXplKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBwb3BwZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBwb3BwZWRTaXplQnl0ZXMgKz0gaXRlbS5zaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZUJ5dGVzIC09IGl0ZW0uc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIG9uIHRoZSBxdWV1ZSB3ZSB3ZXJlIHVuYWJsZSB0byBwb3AsXG4gICAgICAgIC8vIGp1c3QgcmV0dXJuIGl0IGFzIGEgc2luZ2xlIGJhdGNoLlxuICAgICAgICBpZiAocG9wcGVkLmxlbmd0aCA9PT0gMCAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zLnNoaWZ0KCk7XG4gICAgICAgICAgICBwb3BwZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHBvcHBlZFNpemVCeXRlcyArPSBpdGVtLnNpemU7XG4gICAgICAgICAgICB0aGlzLnNpemVCeXRlcyAtPSBpdGVtLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBvcHBlZC5tYXAoKGl0KSA9PiAoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogaXQuYWN0aW9uLFxuICAgICAgICAgICAgICAgIGl0ZW06IGl0LnBheWxvYWQsXG4gICAgICAgICAgICAgICAgb3RlbENvbnRleHQ6IGl0Lm90ZWxDb250ZXh0LFxuICAgICAgICAgICAgICAgIGFwaUtleTogaXQuYXBpS2V5LFxuICAgICAgICAgICAgICAgIGFwaVVybDogaXQuYXBpVXJsLFxuICAgICAgICAgICAgICAgIHNpemU6IGl0LnNpemUsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAoKSA9PiBwb3BwZWQuZm9yRWFjaCgoaXQpID0+IGl0Lml0ZW1Qcm9taXNlUmVzb2x2ZSgpKSxcbiAgICAgICAgXTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2xpZW50IHtcbiAgICBnZXQgX2ZldGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uIHx8IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndlYlVybFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3b3Jrc3BhY2VJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hJbmdlc3RDYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGltZW91dF9tc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGVuYW50SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhpZGVJbnB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGlkZU91dHB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib21pdFRyYWNlZFJ1bnRpbWVJbmZvXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNpbmdTYW1wbGVSYXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbHRlcmVkUG9zdFV1aWRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRyYWNpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRpbWVvdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoQWdncmVnYXRpb25EZWxheU1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAyNTBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhdGNoU2l6ZUJ5dGVzTGltaXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hTaXplTGltaXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmV0Y2hPcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldHRpbmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR1NNSVRIX1RSQUNJTkdfQkFDS0dST1VORFwiKSA9PT0gXCJmYWxzZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjZUJhdGNoQ29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zZXJ2ZXJJbmZvXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYW51YWxGbHVzaE1vZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYW5nU21pdGhUb09URUxUcmFuc2xhdG9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZldGNoSW1wbGVtZW50YXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FjaGVkTFNFbnZWYXJzRm9yTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NhY2hlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm11bHRpcGFydFN0cmVhbWluZ0Rpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX211bHRpcGFydERpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVidWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HU01JVEhfREVCVUdcIikgPT09IFwidHJ1ZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gQ2xpZW50LmdldERlZmF1bHRDbGllbnRDb25maWcoKTtcbiAgICAgICAgdGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9IGdldFRyYWNpbmdTYW1wbGluZ1JhdGUoY29uZmlnLnRyYWNpbmdTYW1wbGluZ1JhdGUpO1xuICAgICAgICB0aGlzLmFwaVVybCA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaVVybCA/PyBkZWZhdWx0Q29uZmlnLmFwaVVybCkgPz8gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuYXBpVXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgdGhpcy5hcGlVcmwgPSB0aGlzLmFwaVVybC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGlLZXkgPSB0cmltUXVvdGVzKGNvbmZpZy5hcGlLZXkgPz8gZGVmYXVsdENvbmZpZy5hcGlLZXkpO1xuICAgICAgICB0aGlzLndlYlVybCA9IHRyaW1RdW90ZXMoY29uZmlnLndlYlVybCA/PyBkZWZhdWx0Q29uZmlnLndlYlVybCk7XG4gICAgICAgIGlmICh0aGlzLndlYlVybD8uZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IHRoaXMud2ViVXJsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndvcmtzcGFjZUlkID0gdHJpbVF1b3Rlcyhjb25maWcud29ya3NwYWNlSWQgPz8gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIldPUktTUEFDRV9JRFwiKSk7XG4gICAgICAgIHRoaXMudGltZW91dF9tcyA9IGNvbmZpZy50aW1lb3V0X21zID8/IDkwXzAwMDtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgLi4uKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KSxcbiAgICAgICAgICAgIG1heFJldHJpZXM6IDQsXG4gICAgICAgICAgICBkZWJ1ZzogY29uZmlnLmRlYnVnID8/IHRoaXMuZGVidWcsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYWNlQmF0Y2hDb25jdXJyZW5jeSA9XG4gICAgICAgICAgICBjb25maWcudHJhY2VCYXRjaENvbmN1cnJlbmN5ID8/IHRoaXMudHJhY2VCYXRjaENvbmN1cnJlbmN5O1xuICAgICAgICBpZiAodGhpcy50cmFjZUJhdGNoQ29uY3VycmVuY3kgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFjZSBiYXRjaCBjb25jdXJyZW5jeSBtdXN0IGJlIHBvc2l0aXZlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnID0gY29uZmlnLmRlYnVnID8/IHRoaXMuZGVidWc7XG4gICAgICAgIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGNvbmZpZy5mZXRjaEltcGxlbWVudGF0aW9uO1xuICAgICAgICAvLyBVc2UgbWF4SW5nZXN0TWVtb3J5Qnl0ZXMgZm9yIGJvdGggcXVldWVzXG4gICAgICAgIGNvbnN0IG1heE1lbW9yeSA9IGNvbmZpZy5tYXhJbmdlc3RNZW1vcnlCeXRlcyA/PyBERUZBVUxUX01BWF9TSVpFX0JZVEVTO1xuICAgICAgICB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyID0gbmV3IEFzeW5jQ2FsbGVyKHtcbiAgICAgICAgICAgIG1heFJldHJpZXM6IDQsXG4gICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogdGhpcy50cmFjZUJhdGNoQ29uY3VycmVuY3ksXG4gICAgICAgICAgICBtYXhRdWV1ZVNpemVCeXRlczogbWF4TWVtb3J5LFxuICAgICAgICAgICAgLi4uKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KSxcbiAgICAgICAgICAgIG9uRmFpbGVkUmVzcG9uc2VIb29rOiBoYW5kbGU0MjksXG4gICAgICAgICAgICBkZWJ1ZzogY29uZmlnLmRlYnVnID8/IHRoaXMuZGVidWcsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhpZGVJbnB1dHMgPVxuICAgICAgICAgICAgY29uZmlnLmhpZGVJbnB1dHMgPz8gY29uZmlnLmFub255bWl6ZXIgPz8gZGVmYXVsdENvbmZpZy5oaWRlSW5wdXRzO1xuICAgICAgICB0aGlzLmhpZGVPdXRwdXRzID1cbiAgICAgICAgICAgIGNvbmZpZy5oaWRlT3V0cHV0cyA/PyBjb25maWcuYW5vbnltaXplciA/PyBkZWZhdWx0Q29uZmlnLmhpZGVPdXRwdXRzO1xuICAgICAgICB0aGlzLm9taXRUcmFjZWRSdW50aW1lSW5mbyA9IGNvbmZpZy5vbWl0VHJhY2VkUnVudGltZUluZm8gPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0b0JhdGNoVHJhY2luZyA9IGNvbmZpZy5hdXRvQmF0Y2hUcmFjaW5nID8/IHRoaXMuYXV0b0JhdGNoVHJhY2luZztcbiAgICAgICAgdGhpcy5hdXRvQmF0Y2hRdWV1ZSA9IG5ldyBBdXRvQmF0Y2hRdWV1ZShtYXhNZW1vcnkpO1xuICAgICAgICB0aGlzLmJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uID1cbiAgICAgICAgICAgIGNvbmZpZy5ibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvbiA/PyB0aGlzLmJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZUJ5dGVzTGltaXQgPSBjb25maWcuYmF0Y2hTaXplQnl0ZXNMaW1pdDtcbiAgICAgICAgdGhpcy5iYXRjaFNpemVMaW1pdCA9IGNvbmZpZy5iYXRjaFNpemVMaW1pdDtcbiAgICAgICAgdGhpcy5mZXRjaE9wdGlvbnMgPSBjb25maWcuZmV0Y2hPcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm1hbnVhbEZsdXNoTW9kZSA9IGNvbmZpZy5tYW51YWxGbHVzaE1vZGUgPz8gdGhpcy5tYW51YWxGbHVzaE1vZGU7XG4gICAgICAgIGlmIChnZXRPdGVsRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3IgPSBuZXcgTGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhY2hlIG1ldGFkYXRhIGVudiB2YXJzIG9uY2UgZHVyaW5nIGNvbnN0cnVjdGlvbiB0byBhdm9pZCByZXBlYXRlZGx5IHNjYW5uaW5nIHByb2Nlc3MuZW52XG4gICAgICAgIHRoaXMuY2FjaGVkTFNFbnZWYXJzRm9yTWV0YWRhdGEgPSBnZXRMYW5nU21pdGhFbnZWYXJzTWV0YWRhdGEoKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjYWNoZVxuICAgICAgICBpZiAoY29uZmlnLmNhY2hlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5jYWNoZSAmJiB0eXBlb2YgY29uZmlnLmNhY2hlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IGNvbmZpZy5jYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q2xpZW50Q29uZmlnKCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiQVBJX0tFWVwiKTtcbiAgICAgICAgY29uc3QgYXBpVXJsID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkVORFBPSU5UXCIpID8/IERFRkFVTFRfQVBJX1VSTDtcbiAgICAgICAgY29uc3QgaGlkZUlucHV0cyA9IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJISURFX0lOUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGNvbnN0IGhpZGVPdXRwdXRzID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkhJREVfT1VUUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcGlVcmw6IGFwaVVybCxcbiAgICAgICAgICAgIGFwaUtleTogYXBpS2V5LFxuICAgICAgICAgICAgd2ViVXJsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoaWRlSW5wdXRzOiBoaWRlSW5wdXRzLFxuICAgICAgICAgICAgaGlkZU91dHB1dHM6IGhpZGVPdXRwdXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRIb3N0VXJsKCkge1xuICAgICAgICBpZiAodGhpcy53ZWJVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xvY2FsaG9zdCh0aGlzLmFwaVVybCkpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwOi8vbG9jYWxob3N0OjMwMDBcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5lbmRzV2l0aChcIi9hcGkvdjFcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gdGhpcy5hcGlVcmwucmVwbGFjZShcIi9hcGkvdjFcIiwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuaW5jbHVkZXMoXCIvYXBpXCIpICYmXG4gICAgICAgICAgICAhdGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmVuZHNXaXRoKFwiYXBpXCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IHRoaXMuYXBpVXJsLnJlcGxhY2UoXCIvYXBpXCIsIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5pbmNsdWRlcyhcImRldlwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vZGV2LnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uaW5jbHVkZXMoXCJldVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vZXUuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5pbmNsdWRlcyhcImJldGFcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL2JldGEuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJVc2VyLUFnZW50XCI6IGBsYW5nc21pdGgtanMvJHtfX3ZlcnNpb25fX31gLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBgJHt0aGlzLmFwaUtleX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndvcmtzcGFjZUlkKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC10ZW5hbnQtaWRcIl0gPSB0aGlzLndvcmtzcGFjZUlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBfZ2V0UGxhdGZvcm1FbmRwb2ludFBhdGgocGF0aCkge1xuICAgICAgICAvLyBDaGVjayBpZiBhcGlVcmwgYWxyZWFkeSBlbmRzIHdpdGggL3YxIG9yIC92MS8gdG8gYXZvaWQgZG91YmxlIC92MS92MS8gcGF0aHNcbiAgICAgICAgY29uc3QgbmVlZHNWMVByZWZpeCA9IHRoaXMuYXBpVXJsLnNsaWNlKC0zKSAhPT0gXCIvdjFcIiAmJiB0aGlzLmFwaVVybC5zbGljZSgtNCkgIT09IFwiL3YxL1wiO1xuICAgICAgICByZXR1cm4gbmVlZHNWMVByZWZpeCA/IGAvdjEvcGxhdGZvcm0vJHtwYXRofWAgOiBgL3BsYXRmb3JtLyR7cGF0aH1gO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzSW5wdXRzKGlucHV0cykge1xuICAgICAgICBpZiAodGhpcy5oaWRlSW5wdXRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaWRlSW5wdXRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmhpZGVJbnB1dHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZUlucHV0cyhpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NPdXRwdXRzKG91dHB1dHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZU91dHB1dHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaWRlT3V0cHV0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5oaWRlT3V0cHV0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlT3V0cHV0cyhvdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHJ1bikge1xuICAgICAgICBjb25zdCBydW5QYXJhbXMgPSB7IC4uLnJ1biB9O1xuICAgICAgICBpZiAocnVuUGFyYW1zLmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5QYXJhbXMuaW5wdXRzID0gYXdhaXQgdGhpcy5wcm9jZXNzSW5wdXRzKHJ1blBhcmFtcy5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5QYXJhbXMub3V0cHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5QYXJhbXMub3V0cHV0cyA9IGF3YWl0IHRoaXMucHJvY2Vzc091dHB1dHMocnVuUGFyYW1zLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5QYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRSZXNwb25zZShwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCBwYXJhbXNTdHJpbmcgPSBxdWVyeVBhcmFtcz8udG9TdHJpbmcoKSA/PyBcIlwiO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zU3RyaW5nfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIGBmZXRjaCAke3BhdGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0KHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0UmVzcG9uc2UocGF0aCwgcXVlcnlQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyAqX2dldFBhZ2luYXRlZChwYXRoLCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgdHJhbnNmb3JtKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBOdW1iZXIocXVlcnlQYXJhbXMuZ2V0KFwib2Zmc2V0XCIpKSB8fCAwO1xuICAgICAgICBjb25zdCBsaW1pdCA9IE51bWJlcihxdWVyeVBhcmFtcy5nZXQoXCJsaW1pdFwiKSkgfHwgMTAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KFwib2Zmc2V0XCIsIFN0cmluZyhvZmZzZXQpKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnNldChcImxpbWl0XCIsIFN0cmluZyhsaW1pdCkpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3F1ZXJ5UGFyYW1zfWA7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgYGZldGNoICR7cGF0aH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtKGF3YWl0IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGl0ZW1zO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpfZ2V0Q3Vyc29yUGFnaW5hdGVkTGlzdChwYXRoLCBib2R5ID0gbnVsbCwgcmVxdWVzdE1ldGhvZCA9IFwiUE9TVFwiLCBkYXRhS2V5ID0gXCJydW5zXCIpIHtcbiAgICAgICAgY29uc3QgYm9keVBhcmFtcyA9IGJvZHkgPyB7IC4uLmJvZHkgfSA6IHt9O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHlQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0ke3BhdGh9YCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3RNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBgZmV0Y2ggJHtwYXRofWApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlQm9keVtkYXRhS2V5XSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgcmVzcG9uc2VCb2R5W2RhdGFLZXldO1xuICAgICAgICAgICAgY29uc3QgY3Vyc29ycyA9IHJlc3BvbnNlQm9keS5jdXJzb3JzO1xuICAgICAgICAgICAgaWYgKCFjdXJzb3JzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1cnNvcnMubmV4dCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keVBhcmFtcy5jdXJzb3IgPSBjdXJzb3JzLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWxsb3dzIG1vY2tpbmcgZm9yIHRlc3RzXG4gICAgX3Nob3VsZFNhbXBsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2luZ1NhbXBsZVJhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPCB0aGlzLnRyYWNpbmdTYW1wbGVSYXRlO1xuICAgIH1cbiAgICBfZmlsdGVyRm9yU2FtcGxpbmcocnVucywgcGF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVucztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuIG9mIHJ1bnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuaGFzKHJ1bi50cmFjZV9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlZC5wdXNoKHJ1bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bi5pZCA9PT0gcnVuLnRyYWNlX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuZGVsZXRlKHJ1bi50cmFjZV9pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgbmV3IHJ1bnMsIHNhbXBsZSBhdCB0cmFjZSBsZXZlbCB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW4gb2YgcnVucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlSWQgPSBydW4udHJhY2VfaWQgPz8gcnVuLmlkO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgbWFkZSBhIGRlY2lzaW9uIGFib3V0IHRoaXMgdHJhY2UsIGZvbGxvdyBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcmVkUG9zdFV1aWRzLmhhcyh0cmFjZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm9yIG5ldyB0cmFjZXMsIGFwcGx5IHNhbXBsaW5nXG4gICAgICAgICAgICAgICAgaWYgKHJ1bi5pZCA9PT0gdHJhY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkU2FtcGxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZFBvc3RVdWlkcy5hZGQodHJhY2VJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoaWxkIHJ1bnMgZm9sbG93IHRoZWlyIHRyYWNlJ3Mgc2FtcGxpbmcgZGVjaXNpb25cbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlZC5wdXNoKHJ1bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2dldEJhdGNoU2l6ZUxpbWl0Qnl0ZXMoKSB7XG4gICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9lbnN1cmVTZXJ2ZXJJbmZvKCk7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXRjaFNpemVCeXRlc0xpbWl0ID8/XG4gICAgICAgICAgICBzZXJ2ZXJJbmZvPy5iYXRjaF9pbmdlc3RfY29uZmlnPy5zaXplX2xpbWl0X2J5dGVzID8/XG4gICAgICAgICAgICBERUZBVUxUX1VOQ09NUFJFU1NFRF9CQVRDSF9TSVpFX0xJTUlUX0JZVEVTKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBvcGVyYXRpb25zIHRvIGJhdGNoIGluIGEgc2luZ2xlIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgX2dldEJhdGNoU2l6ZUxpbWl0KCkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZW5zdXJlU2VydmVySW5mbygpO1xuICAgICAgICByZXR1cm4gKHRoaXMuYmF0Y2hTaXplTGltaXQgPz9cbiAgICAgICAgICAgIHNlcnZlckluZm8/LmJhdGNoX2luZ2VzdF9jb25maWc/LnNpemVfbGltaXQgPz9cbiAgICAgICAgICAgIERFRkFVTFRfQkFUQ0hfU0laRV9MSU1JVCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXREYXRhc2V0RXhhbXBsZXNNdWx0aVBhcnRTdXBwb3J0KCkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZW5zdXJlU2VydmVySW5mbygpO1xuICAgICAgICByZXR1cm4gKHNlcnZlckluZm8uaW5zdGFuY2VfZmxhZ3M/LmRhdGFzZXRfZXhhbXBsZXNfbXVsdGlwYXJ0X2VuYWJsZWQgPz8gZmFsc2UpO1xuICAgIH1cbiAgICBkcmFpbkF1dG9CYXRjaFF1ZXVlKHsgYmF0Y2hTaXplTGltaXRCeXRlcywgYmF0Y2hTaXplTGltaXQsIH0pIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgW2JhdGNoLCBkb25lXSA9IHRoaXMuYXV0b0JhdGNoUXVldWUucG9wKHtcbiAgICAgICAgICAgICAgICB1cFRvU2l6ZUJ5dGVzOiBiYXRjaFNpemVMaW1pdEJ5dGVzLFxuICAgICAgICAgICAgICAgIHVwVG9TaXplOiBiYXRjaFNpemVMaW1pdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFiYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiYXRjaGVzQnlEZXN0aW5hdGlvbiA9IGJhdGNoLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBpVXJsID0gaXRlbS5hcGlVcmwgPz8gdGhpcy5hcGlVcmw7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBpS2V5ID0gaXRlbS5hcGlLZXkgPz8gdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEZWZhdWx0ID0gaXRlbS5hcGlLZXkgPT09IHRoaXMuYXBpS2V5ICYmIGl0ZW0uYXBpVXJsID09PSB0aGlzLmFwaVVybDtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaEtleSA9IGlzRGVmYXVsdCA/IFwiZGVmYXVsdFwiIDogYCR7YXBpVXJsfXwke2FwaUtleX1gO1xuICAgICAgICAgICAgICAgIGlmICghYWNjW2JhdGNoS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbYmF0Y2hLZXldID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY1tiYXRjaEtleV0ucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hLZXksIGJhdGNoXSBvZiBPYmplY3QuZW50cmllcyhiYXRjaGVzQnlEZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaFByb21pc2UgPSB0aGlzLl9wcm9jZXNzQmF0Y2goYmF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBiYXRjaEtleSA9PT0gXCJkZWZhdWx0XCIgPyB1bmRlZmluZWQgOiBiYXRjaEtleS5zcGxpdChcInxcIilbMF0sXG4gICAgICAgICAgICAgICAgICAgIGFwaUtleTogYmF0Y2hLZXkgPT09IFwiZGVmYXVsdFwiID8gdW5kZWZpbmVkIDogYmF0Y2hLZXkuc3BsaXQoXCJ8XCIpWzFdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJhdGNoUHJvbWlzZXMucHVzaChiYXRjaFByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2FpdCBmb3IgYWxsIGJhdGNoZXMgdG8gY29tcGxldGUsIHRoZW4gY2FsbCB0aGUgb3ZlcmFsbCBkb25lIGNhbGxiYWNrXG4gICAgICAgICAgICBjb25zdCBhbGxCYXRjaGVzUHJvbWlzZSA9IFByb21pc2UuYWxsKGJhdGNoUHJvbWlzZXMpLmZpbmFsbHkoZG9uZSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGFsbEJhdGNoZXNQcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICBhc3luYyBfcHJvY2Vzc0JhdGNoKGJhdGNoLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghYmF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIGJhdGNoIHNpemUgZm9yIHF1ZXVlIHRyYWNraW5nXG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZUJ5dGVzID0gYmF0Y2gucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIChpdGVtLnNpemUgPz8gMCksIDApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZEJhdGNoVG9PVEVMVHJhbnNsYXRvcihiYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmdlc3RQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bkNyZWF0ZXM6IGJhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmFjdGlvbiA9PT0gXCJjcmVhdGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaXRlbSksXG4gICAgICAgICAgICAgICAgICAgIHJ1blVwZGF0ZXM6IGJhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaXRlbSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZW5zdXJlU2VydmVySW5mbygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZU11bHRpcGFydCA9ICF0aGlzLl9tdWx0aXBhcnREaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VydmVySW5mbz8uYmF0Y2hfaW5nZXN0X2NvbmZpZz8udXNlX211bHRpcGFydF9lbmRwb2ludCA/PyB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlTXVsdGlwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZUd6aXAgPSBzZXJ2ZXJJbmZvPy5pbnN0YW5jZV9mbGFncz8uZ3ppcF9ib2R5X2VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm11bHRpcGFydEluZ2VzdFJ1bnMoaW5nZXN0UGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VHemlwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVCeXRlczogYmF0Y2hTaXplQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xhbmdTbWl0aE5vdEZvdW5kRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBiYXRjaCBpbmdlc3QgaWYgbXVsdGlwYXJ0IGVuZHBvaW50IHJldHVybnMgNDA0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBtdWx0aXBhcnQgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX211bHRpcGFydERpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0UnVucyhpbmdlc3RQYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUJ5dGVzOiBiYXRjaFNpemVCeXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYmF0Y2hJbmdlc3RSdW5zKGluZ2VzdFBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVCeXRlczogYmF0Y2hTaXplQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGV4cG9ydGluZyBiYXRjaDpcIiwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NlbmRCYXRjaFRvT1RFTFRyYW5zbGF0b3IoYmF0Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMubGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvdGVsQ29udGV4dE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBiYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW0uaWQgJiYgaXRlbS5vdGVsQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBvdGVsQ29udGV4dE1hcC5zZXQoaXRlbS5pdGVtLmlkLCBpdGVtLm90ZWxDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uYWN0aW9uID09PSBcImNyZWF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwb3N0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogaXRlbS5pdGVtLnRyYWNlX2lkID8/IGl0ZW0uaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW46IGl0ZW0uaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicGF0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiBpdGVtLml0ZW0udHJhY2VfaWQgPz8gaXRlbS5pdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bjogaXRlbS5pdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3IuZXhwb3J0QmF0Y2gob3BlcmF0aW9ucywgb3RlbENvbnRleHRNYXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NSdW5PcGVyYXRpb24oaXRlbSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvQmF0Y2hUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpdGVtLml0ZW0gPSBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuKGl0ZW0uaXRlbSwgdGhpcy5jYWNoZWRMU0VudlZhcnNGb3JNZXRhZGF0YSwgdGhpcy5vbWl0VHJhY2VkUnVudGltZUluZm8pO1xuICAgICAgICBjb25zdCBpdGVtUHJvbWlzZSA9IHRoaXMuYXV0b0JhdGNoUXVldWUucHVzaChpdGVtKTtcbiAgICAgICAgaWYgKHRoaXMubWFudWFsRmx1c2hNb2RlKSB7XG4gICAgICAgICAgICAvLyBSZWx5IG9uIG1hbnVhbCBmbHVzaGluZyBpbiBzZXJ2ZXJsZXNzIGVudmlyb25tZW50c1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpemVMaW1pdEJ5dGVzID0gYXdhaXQgdGhpcy5fZ2V0QmF0Y2hTaXplTGltaXRCeXRlcygpO1xuICAgICAgICBjb25zdCBzaXplTGltaXQgPSBhd2FpdCB0aGlzLl9nZXRCYXRjaFNpemVMaW1pdCgpO1xuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hRdWV1ZS5zaXplQnl0ZXMgPiBzaXplTGltaXRCeXRlcyB8fFxuICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hRdWV1ZS5pdGVtcy5sZW5ndGggPiBzaXplTGltaXQpIHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5kcmFpbkF1dG9CYXRjaFF1ZXVlKHtcbiAgICAgICAgICAgICAgICBiYXRjaFNpemVMaW1pdEJ5dGVzOiBzaXplTGltaXRCeXRlcyxcbiAgICAgICAgICAgICAgICBiYXRjaFNpemVMaW1pdDogc2l6ZUxpbWl0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5kcmFpbkF1dG9CYXRjaFF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplTGltaXRCeXRlczogc2l6ZUxpbWl0Qnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZUxpbWl0OiBzaXplTGltaXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzLmF1dG9CYXRjaEFnZ3JlZ2F0aW9uRGVsYXlNcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1Qcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0U2VydmVySW5mbygpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9pbmZvYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoU0VSVkVSX0lORk9fUkVRVUVTVF9USU1FT1VUX01TKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImdldCBzZXJ2ZXIgaW5mb1wiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJcXG49PT0gTGFuZ1NtaXRoIFNlcnZlciBDb25maWd1cmF0aW9uID09PVxcblwiICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShqc29uLCBudWxsLCAyKSArXG4gICAgICAgICAgICAgICAgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGFzeW5jIF9lbnN1cmVTZXJ2ZXJJbmZvKCkge1xuICAgICAgICBpZiAodGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZXJ2ZXJJbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJJbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0xBTkdTTUlUSF06IEZhaWxlZCB0byBmZXRjaCBpbmZvIG9uIHN1cHBvcnRlZCBvcGVyYXRpb25zLiBGYWxsaW5nIGJhY2sgdG8gYmF0Y2ggb3BlcmF0aW9ucyBhbmQgZGVmYXVsdCBsaW1pdHMuIEluZm86ICR7ZS5zdGF0dXMgPz8gXCJVbnNwZWNpZmllZCBzdGF0dXMgY29kZVwifSAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVySW5mbyA/PyB7fTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNlcnZlckluZm9Qcm9taXNlLnRoZW4oKHNlcnZlckluZm8pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZXJ2ZXJJbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJJbmZvO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFNldHRpbmdzKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSB0aGlzLl9nZXQoXCIvc2V0dGluZ3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0dGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgY3VycmVudCBxdWV1ZWQgdHJhY2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgICBjb25zdCBzaXplTGltaXRCeXRlcyA9IGF3YWl0IHRoaXMuX2dldEJhdGNoU2l6ZUxpbWl0Qnl0ZXMoKTtcbiAgICAgICAgY29uc3Qgc2l6ZUxpbWl0ID0gYXdhaXQgdGhpcy5fZ2V0QmF0Y2hTaXplTGltaXQoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kcmFpbkF1dG9CYXRjaFF1ZXVlKHtcbiAgICAgICAgICAgIGJhdGNoU2l6ZUxpbWl0Qnl0ZXM6IHNpemVMaW1pdEJ5dGVzLFxuICAgICAgICAgICAgYmF0Y2hTaXplTGltaXQ6IHNpemVMaW1pdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9jbG9uZUN1cnJlbnRPVEVMQ29udGV4dCgpIHtcbiAgICAgICAgY29uc3Qgb3RlbF90cmFjZSA9IGdldE9URUxUcmFjZSgpO1xuICAgICAgICBjb25zdCBvdGVsX2NvbnRleHQgPSBnZXRPVEVMQ29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5sYW5nU21pdGhUb09URUxUcmFuc2xhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTcGFuID0gb3RlbF90cmFjZS5nZXRBY3RpdmVTcGFuKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNwYW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RlbF90cmFjZS5zZXRTcGFuKG90ZWxfY29udGV4dC5hY3RpdmUoKSwgY3VycmVudFNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVJ1bihydW4sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJGb3JTYW1wbGluZyhbcnVuXSkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXNzaW9uX25hbWUgPSBydW4ucHJvamVjdF9uYW1lO1xuICAgICAgICBkZWxldGUgcnVuLnByb2plY3RfbmFtZTtcbiAgICAgICAgY29uc3QgcnVuQ3JlYXRlID0gYXdhaXQgdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMoe1xuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lLFxuICAgICAgICAgICAgLi4ucnVuLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuLnN0YXJ0X3RpbWUgPz8gRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFRyYWNpbmcgJiZcbiAgICAgICAgICAgIHJ1bkNyZWF0ZS50cmFjZV9pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBydW5DcmVhdGUuZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG90ZWxDb250ZXh0ID0gdGhpcy5fY2xvbmVDdXJyZW50T1RFTENvbnRleHQoKTtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5wcm9jZXNzUnVuT3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiY3JlYXRlXCIsXG4gICAgICAgICAgICAgICAgaXRlbTogcnVuQ3JlYXRlLFxuICAgICAgICAgICAgICAgIG90ZWxDb250ZXh0LFxuICAgICAgICAgICAgICAgIGFwaUtleTogb3B0aW9ucz8uYXBpS2V5LFxuICAgICAgICAgICAgICAgIGFwaVVybDogb3B0aW9ucz8uYXBpVXJsLFxuICAgICAgICAgICAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVyZ2VkUnVuQ3JlYXRlUGFyYW0gPSBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuKHJ1bkNyZWF0ZSwgdGhpcy5jYWNoZWRMU0VudlZhcnNGb3JNZXRhZGF0YSwgdGhpcy5vbWl0VHJhY2VkUnVudGltZUluZm8pO1xuICAgICAgICBpZiAob3B0aW9ucz8uYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBvcHRpb25zLmFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucz8ud29ya3NwYWNlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIngtdGVuYW50LWlkXCJdID0gb3B0aW9ucy53b3Jrc3BhY2VJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcobWVyZ2VkUnVuQ3JlYXRlUGFyYW0sIGBDcmVhdGluZyBydW4gd2l0aCBpZDogJHttZXJnZWRSdW5DcmVhdGVQYXJhbS5pZH1gKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHtvcHRpb25zPy5hcGlVcmwgPz8gdGhpcy5hcGlVcmx9L3J1bnNgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJjcmVhdGUgcnVuXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhdGNoIGluZ2VzdC91cHNlcnQgbXVsdGlwbGUgcnVucyBpbiB0aGUgTGFuZ3NtaXRoIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gcnVuc1xuICAgICAqL1xuICAgIGFzeW5jIGJhdGNoSW5nZXN0UnVucyh7IHJ1bkNyZWF0ZXMsIHJ1blVwZGF0ZXMsIH0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHJ1bkNyZWF0ZXMgPT09IHVuZGVmaW5lZCAmJiBydW5VcGRhdGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBhd2FpdCBQcm9taXNlLmFsbChydW5DcmVhdGVzPy5tYXAoKGNyZWF0ZSkgPT4gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMoY3JlYXRlKSkgPz8gW10pO1xuICAgICAgICBsZXQgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBhd2FpdCBQcm9taXNlLmFsbChydW5VcGRhdGVzPy5tYXAoKHVwZGF0ZSkgPT4gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHModXBkYXRlKSkgPz8gW10pO1xuICAgICAgICBpZiAocHJlcGFyZWRDcmVhdGVQYXJhbXMubGVuZ3RoID4gMCAmJiBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVCeUlkID0gcHJlcGFyZWRDcmVhdGVQYXJhbXMucmVkdWNlKChwYXJhbXMsIHJ1bikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcnVuLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtc1tydW4uaWRdID0gcnVuO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBjb25zdCBzdGFuZGFsb25lVXBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCB1cGRhdGVQYXJhbSBvZiBwcmVwYXJlZFVwZGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVQYXJhbS5pZCAhPT0gdW5kZWZpbmVkICYmIGNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51cGRhdGVQYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYWxvbmVVcGRhdGVzLnB1c2godXBkYXRlUGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gT2JqZWN0LnZhbHVlcyhjcmVhdGVCeUlkKTtcbiAgICAgICAgICAgIHByZXBhcmVkVXBkYXRlUGFyYW1zID0gc3RhbmRhbG9uZVVwZGF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3QmF0Y2ggPSB7XG4gICAgICAgICAgICBwb3N0OiBwcmVwYXJlZENyZWF0ZVBhcmFtcyxcbiAgICAgICAgICAgIHBhdGNoOiBwcmVwYXJlZFVwZGF0ZVBhcmFtcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFyYXdCYXRjaC5wb3N0Lmxlbmd0aCAmJiAhcmF3QmF0Y2gucGF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmF0Y2hDaHVua3MgPSB7XG4gICAgICAgICAgICBwb3N0OiBbXSxcbiAgICAgICAgICAgIHBhdGNoOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIFtcInBvc3RcIiwgXCJwYXRjaFwiXSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaztcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoSXRlbXMgPSByYXdCYXRjaFtrZXldLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxldCBiYXRjaEl0ZW0gPSBiYXRjaEl0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgd2hpbGUgKGJhdGNoSXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZSBpcyB3cm9uZyBidXQgdGhpcyBpcyBhIGRlcHJlY2F0ZWQgY29kZSBwYXRoIGFueXdheVxuICAgICAgICAgICAgICAgIGJhdGNoQ2h1bmtzW2tleV0ucHVzaChiYXRjaEl0ZW0pO1xuICAgICAgICAgICAgICAgIGJhdGNoSXRlbSA9IGJhdGNoSXRlbXMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhdGNoQ2h1bmtzLnBvc3QubGVuZ3RoID4gMCB8fCBiYXRjaENodW5rcy5wYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBydW5JZHMgPSBiYXRjaENodW5rcy5wb3N0XG4gICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pZClcbiAgICAgICAgICAgICAgICAuY29uY2F0KGJhdGNoQ2h1bmtzLnBhdGNoLm1hcCgoaXRlbSkgPT4gaXRlbS5pZCkpXG4gICAgICAgICAgICAgICAgLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcG9zdEJhdGNoSW5nZXN0UnVucyhzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhiYXRjaENodW5rcywgYEluZ2VzdGluZyBydW5zIHdpdGggaWRzOiAke3J1bklkc31gKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3Bvc3RCYXRjaEluZ2VzdFJ1bnMoYm9keSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucz8uYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBvcHRpb25zLmFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyLmNhbGxXaXRoT3B0aW9ucyh7IHNpemVCeXRlczogb3B0aW9ucz8uc2l6ZUJ5dGVzIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke29wdGlvbnM/LmFwaVVybCA/PyB0aGlzLmFwaVVybH0vcnVucy9iYXRjaGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImJhdGNoIGNyZWF0ZSBydW5cIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmF0Y2ggaW5nZXN0L3Vwc2VydCBtdWx0aXBsZSBydW5zIGluIHRoZSBMYW5nc21pdGggc3lzdGVtLlxuICAgICAqIEBwYXJhbSBydW5zXG4gICAgICovXG4gICAgYXN5bmMgbXVsdGlwYXJ0SW5nZXN0UnVucyh7IHJ1bkNyZWF0ZXMsIHJ1blVwZGF0ZXMsIH0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHJ1bkNyZWF0ZXMgPT09IHVuZGVmaW5lZCAmJiBydW5VcGRhdGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmFuc2Zvcm0gYW5kIGNvbnZlcnQgdG8gZGljdHNcbiAgICAgICAgY29uc3QgYWxsQXR0YWNobWVudHMgPSB7fTtcbiAgICAgICAgbGV0IHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY3JlYXRlIG9mIHJ1bkNyZWF0ZXMgPz8gW10pIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkQ3JlYXRlID0gYXdhaXQgdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMoY3JlYXRlKTtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZS5pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGUuYXR0YWNobWVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFsbEF0dGFjaG1lbnRzW3ByZXBhcmVkQ3JlYXRlLmlkXSA9IHByZXBhcmVkQ3JlYXRlLmF0dGFjaG1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHByZXBhcmVkQ3JlYXRlLmF0dGFjaG1lbnRzO1xuICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMucHVzaChwcmVwYXJlZENyZWF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXBhcmVkVXBkYXRlUGFyYW1zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHJ1blVwZGF0ZXMgPz8gW10pIHtcbiAgICAgICAgICAgIHByZXBhcmVkVXBkYXRlUGFyYW1zLnB1c2goYXdhaXQgdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHModXBkYXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVxdWlyZSB0cmFjZV9pZCBhbmQgZG90dGVkX29yZGVyXG4gICAgICAgIGNvbnN0IGludmFsaWRSdW5DcmVhdGUgPSBwcmVwYXJlZENyZWF0ZVBhcmFtcy5maW5kKChydW5DcmVhdGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocnVuQ3JlYXRlLnRyYWNlX2lkID09PSB1bmRlZmluZWQgfHwgcnVuQ3JlYXRlLmRvdHRlZF9vcmRlciA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnZhbGlkUnVuQ3JlYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwYXJ0IGluZ2VzdCByZXF1aXJlcyBcInRyYWNlX2lkXCIgYW5kIFwiZG90dGVkX29yZGVyXCIgdG8gYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBydW5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnZhbGlkUnVuVXBkYXRlID0gcHJlcGFyZWRVcGRhdGVQYXJhbXMuZmluZCgocnVuVXBkYXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHJ1blVwZGF0ZS50cmFjZV9pZCA9PT0gdW5kZWZpbmVkIHx8IHJ1blVwZGF0ZS5kb3R0ZWRfb3JkZXIgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW52YWxpZFJ1blVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGFydCBpbmdlc3QgcmVxdWlyZXMgXCJ0cmFjZV9pZFwiIGFuZCBcImRvdHRlZF9vcmRlclwiIHRvIGJlIHNldCB3aGVuIHVwZGF0aW5nIGEgcnVuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tYmluZSBwb3N0IGFuZCBwYXRjaCBkaWN0cyB3aGVyZSBwb3NzaWJsZVxuICAgICAgICBpZiAocHJlcGFyZWRDcmVhdGVQYXJhbXMubGVuZ3RoID4gMCAmJiBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVCeUlkID0gcHJlcGFyZWRDcmVhdGVQYXJhbXMucmVkdWNlKChwYXJhbXMsIHJ1bikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcnVuLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtc1tydW4uaWRdID0gcnVuO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBjb25zdCBzdGFuZGFsb25lVXBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCB1cGRhdGVQYXJhbSBvZiBwcmVwYXJlZFVwZGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVQYXJhbS5pZCAhPT0gdW5kZWZpbmVkICYmIGNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51cGRhdGVQYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYWxvbmVVcGRhdGVzLnB1c2godXBkYXRlUGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gT2JqZWN0LnZhbHVlcyhjcmVhdGVCeUlkKTtcbiAgICAgICAgICAgIHByZXBhcmVkVXBkYXRlUGFyYW1zID0gc3RhbmRhbG9uZVVwZGF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlUGFyYW1zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VuZCB0aGUgcnVucyBpbiBtdWx0aXBhcnQgcmVxdWVzdHNcbiAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRDb250ZXh0ID0gW107XG4gICAgICAgIGNvbnN0IGFjY3VtdWxhdGVkUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbbWV0aG9kLCBwYXlsb2Fkc10gb2YgW1xuICAgICAgICAgICAgW1wicG9zdFwiLCBwcmVwYXJlZENyZWF0ZVBhcmFtc10sXG4gICAgICAgICAgICBbXCJwYXRjaFwiLCBwcmVwYXJlZFVwZGF0ZVBhcmFtc10sXG4gICAgICAgIF0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3JpZ2luYWxQYXlsb2FkIG9mIHBheWxvYWRzKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCBmaWVsZHMgdG8gYmUgc2VudCBhcyBzZXBhcmF0ZSBwYXJ0c1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5wdXRzLCBvdXRwdXRzLCBldmVudHMsIGV4dHJhLCBlcnJvciwgc2VyaWFsaXplZCwgYXR0YWNobWVudHMsIC4uLnBheWxvYWQgfSA9IG9yaWdpbmFsUGF5bG9hZDtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSB7IGlucHV0cywgb3V0cHV0cywgZXZlbnRzLCBleHRyYSwgZXJyb3IsIHNlcmlhbGl6ZWQgfTtcbiAgICAgICAgICAgICAgICAvLyBlbmNvZGUgdGhlIG1haW4gcnVuIHBheWxvYWRcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZFBheWxvYWQgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhwYXlsb2FkLCBgU2VyaWFsaXppbmcgZm9yIG11bHRpcGFydCBpbmdlc3Rpb24gb2YgcnVuIHdpdGggaWQ6ICR7cGF5bG9hZC5pZH1gKTtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHttZXRob2R9LiR7cGF5bG9hZC5pZH1gLFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBuZXcgQmxvYihbc3RyaW5naWZpZWRQYXlsb2FkXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYGFwcGxpY2F0aW9uL2pzb247IGxlbmd0aD0ke3N0cmluZ2lmaWVkUGF5bG9hZC5sZW5ndGh9YCwgLy8gZW5jb2Rpbmc9Z3ppcFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBlbmNvZGUgdGhlIGZpZWxkcyB3ZSBjb2xsZWN0ZWRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZFZhbHVlID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcodmFsdWUsIGBTZXJpYWxpemluZyAke2tleX0gZm9yIG11bHRpcGFydCBpbmdlc3Rpb24gb2YgcnVuIHdpdGggaWQ6ICR7cGF5bG9hZC5pZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke21ldGhvZH0uJHtwYXlsb2FkLmlkfS4ke2tleX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogbmV3IEJsb2IoW3N0cmluZ2lmaWVkVmFsdWVdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYGFwcGxpY2F0aW9uL2pzb247IGxlbmd0aD0ke3N0cmluZ2lmaWVkVmFsdWUubGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuY29kZSB0aGUgYXR0YWNobWVudHNcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGFjaG1lbnRzID0gYWxsQXR0YWNobWVudHNbcGF5bG9hZC5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFsbEF0dGFjaG1lbnRzW3BheWxvYWQuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgYXR0YWNobWVudF0gb2YgT2JqZWN0LmVudHJpZXMoYXR0YWNobWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dGFjaG1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb250ZW50VHlwZSwgY29udGVudF0gPSBhdHRhY2htZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBhdHRhY2htZW50Lm1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gYXR0YWNobWVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBhdHRhY2htZW50IG5hbWUgZG9lc24ndCBjb250YWluIGEgJy4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2tpcHBpbmcgYXR0YWNobWVudCAnJHtuYW1lfScgZm9yIHJ1biAke3BheWxvYWQuaWR9OiBJbnZhbGlkIGF0dGFjaG1lbnQgbmFtZS4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgQXR0YWNobWVudCBuYW1lcyBtdXN0IG5vdCBjb250YWluIHBlcmlvZHMgKCcuJykuIFBsZWFzZSByZW5hbWUgdGhlIGF0dGFjaG1lbnQgYW5kIHRyeSBhZ2Fpbi5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGBhdHRhY2htZW50LiR7cGF5bG9hZC5pZH0uJHtuYW1lfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG5ldyBCbG9iKFtjb250ZW50XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYCR7Y29udGVudFR5cGV9OyBsZW5ndGg9JHtjb250ZW50LmJ5dGVMZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRDb250ZXh0LnB1c2goYHRyYWNlPSR7cGF5bG9hZC50cmFjZV9pZH0saWQ9JHtwYXlsb2FkLmlkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuX3NlbmRNdWx0aXBhcnRSZXF1ZXN0KGFjY3VtdWxhdGVkUGFydHMsIGFjY3VtdWxhdGVkQ29udGV4dC5qb2luKFwiOyBcIiksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBfY3JlYXRlTm9kZUZldGNoQm9keShwYXJ0cywgYm91bmRhcnkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG11bHRpcGFydCBmb3JtIGRhdGEgbWFudWFsbHkgdXNpbmcgQmxvYnNcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgLy8gQWRkIGZpZWxkIGJvdW5kYXJ5XG4gICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQmxvYihbYC0tJHtib3VuZGFyeX1cXHJcXG5gXSkpO1xuICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IEJsb2IoW1xuICAgICAgICAgICAgICAgIGBDb250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCIke3BhcnQubmFtZX1cIlxcclxcbmAsXG4gICAgICAgICAgICAgICAgYENvbnRlbnQtVHlwZTogJHtwYXJ0LnBheWxvYWQudHlwZX1cXHJcXG5cXHJcXG5gLFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgY2h1bmtzLnB1c2gocGFydC5wYXlsb2FkKTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBCbG9iKFtcIlxcclxcblwiXSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBmaW5hbCBib3VuZGFyeVxuICAgICAgICBjaHVua3MucHVzaChuZXcgQmxvYihbYC0tJHtib3VuZGFyeX0tLVxcclxcbmBdKSk7XG4gICAgICAgIC8vIENvbWJpbmUgYWxsIGNodW5rcyBpbnRvIGEgc2luZ2xlIEJsb2JcbiAgICAgICAgY29uc3QgYm9keSA9IG5ldyBCbG9iKGNodW5rcyk7XG4gICAgICAgIC8vIENvbnZlcnQgQmxvYiB0byBBcnJheUJ1ZmZlciBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGFycmF5QnVmZmVyO1xuICAgIH1cbiAgICBhc3luYyBfY3JlYXRlTXVsdGlwYXJ0U3RyZWFtKHBhcnRzLCBib3VuZGFyeSkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIFJlYWRhYmxlU3RyZWFtIGZvciBzdHJlYW1pbmcgdGhlIG11bHRpcGFydCBkYXRhXG4gICAgICAgIC8vIE9ubHkgZG8gc3BlY2lhbCBoYW5kbGluZyBpZiB3ZSdyZSB1c2luZyBub2RlLWZldGNoXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHdyaXRlIGEgY2h1bmsgdG8gdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlQ2h1bmsgPSBhc3luYyAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKGNodW5rKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSBlYWNoIHBhcnQgdG8gdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXcml0ZSBib3VuZGFyeSBhbmQgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZUNodW5rKGAtLSR7Ym91bmRhcnl9XFxyXFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlQ2h1bmsoYENvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIiR7cGFydC5uYW1lfVwiXFxyXFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlQ2h1bmsoYENvbnRlbnQtVHlwZTogJHtwYXJ0LnBheWxvYWQudHlwZX1cXHJcXG5cXHJcXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGUgdGhlIHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZFN0cmVhbSA9IHBhcnQucGF5bG9hZC5zdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gcGF5bG9hZFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIShyZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZUNodW5rKFwiXFxyXFxuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXcml0ZSBmaW5hbCBib3VuZGFyeVxuICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlQ2h1bmsoYC0tJHtib3VuZGFyeX0tLVxcclxcbmApO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZE11bHRpcGFydFJlcXVlc3QocGFydHMsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG11bHRpcGFydCBmb3JtIGRhdGEgYm91bmRhcnlcbiAgICAgICAgY29uc3QgYm91bmRhcnkgPSBcIi0tLS1MYW5nU21pdGhGb3JtQm91bmRhcnlcIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuICAgICAgICBjb25zdCBpc05vZGVGZXRjaCA9IF9nbG9iYWxGZXRjaEltcGxlbWVudGF0aW9uSXNOb2RlRmV0Y2goKTtcbiAgICAgICAgY29uc3QgYnVpbGRCdWZmZXJlZCA9ICgpID0+IHRoaXMuX2NyZWF0ZU5vZGVGZXRjaEJvZHkocGFydHMsIGJvdW5kYXJ5KTtcbiAgICAgICAgY29uc3QgYnVpbGRTdHJlYW0gPSAoKSA9PiB0aGlzLl9jcmVhdGVNdWx0aXBhcnRTdHJlYW0ocGFydHMsIGJvdW5kYXJ5KTtcbiAgICAgICAgY29uc3Qgc2VuZFdpdGhSZXRyeSA9IGFzeW5jIChib2R5RmFjdG9yeSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIuY2FsbFdpdGhPcHRpb25zKHsgc2l6ZUJ5dGVzOiBvcHRpb25zPy5zaXplQnl0ZXMgfSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCBib2R5RmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7Ym91bmRhcnl9YCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zPy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gb3B0aW9ucy5hcGlLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZEJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zPy51c2VHemlwICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBib2R5ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgIFwicGlwZVRocm91Z2hcIiBpbiBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkQm9keSA9IGJvZHkucGlwZVRocm91Z2gobmV3IENvbXByZXNzaW9uU3RyZWFtKFwiZ3ppcFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LUVuY29kaW5nXCJdID0gXCJnemlwXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7b3B0aW9ucz8uYXBpVXJsID8/IHRoaXMuYXBpVXJsfS9ydW5zL211bHRpcGFydGAsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogdHJhbnNmb3JtZWRCb2R5LFxuICAgICAgICAgICAgICAgICAgICBkdXBsZXg6IFwiaGFsZlwiLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBGYWlsZWQgdG8gc2VuZCBtdWx0aXBhcnQgcmVxdWVzdGAsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlcztcbiAgICAgICAgICAgIGxldCBzdHJlYW1lZEF0dGVtcHQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGF0dGVtcHQgc3RyZWFtIG9ubHkgaWYgbm90IGRpc2FibGVkIGFuZCBub3QgdXNpbmcgbm9kZS1mZXRjaCBvciBCdW5cbiAgICAgICAgICAgIGlmICghaXNOb2RlRmV0Y2ggJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5tdWx0aXBhcnRTdHJlYW1pbmdEaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgIGdldEVudigpICE9PSBcImJ1blwiKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtZWRBdHRlbXB0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBzZW5kV2l0aFJldHJ5KGJ1aWxkU3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IHNlbmRXaXRoUmV0cnkoYnVpbGRCdWZmZXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBzdHJlYW0gZmFpbHMsIGZhbGxiYWNrIHRvIGJ1ZmZlcmVkIGJvZHlcbiAgICAgICAgICAgIGlmICgoIXRoaXMubXVsdGlwYXJ0U3RyZWFtaW5nRGlzYWJsZWQgfHwgc3RyZWFtZWRBdHRlbXB0KSAmJlxuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMgPT09IDQyMiAmJlxuICAgICAgICAgICAgICAgIChvcHRpb25zPy5hcGlVcmwgPz8gdGhpcy5hcGlVcmwpICE9PSBERUZBVUxUX0FQSV9VUkwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFN0cmVhbWluZyBtdWx0aXBhcnQgdXBsb2FkIHRvICR7b3B0aW9ucz8uYXBpVXJsID8/IHRoaXMuYXBpVXJsfS9ydW5zL211bHRpcGFydCBmYWlsZWQuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgVGhpcyB1c3VhbGx5IG1lYW5zIHRoZSBob3N0IGRvZXMgbm90IHN1cHBvcnQgY2h1bmtlZCB1cGxvYWRzLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFJldHJ5aW5nIHdpdGggYSBidWZmZXJlZCB1cGxvYWQgZm9yIG9wZXJhdGlvbiBcIiR7Y29udGV4dH1cIi5gKTtcbiAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIHN0cmVhbWluZyBmb3IgZnV0dXJlIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBhcnRTdHJlYW1pbmdEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgd2l0aCBmdWxseS1idWZmZXJlZCBib2R5XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgc2VuZFdpdGhSZXRyeShidWlsZEJ1ZmZlcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFJlLXRocm93IDQwNCBlcnJvcnMgc28gY2FsbGVyIGNhbiBmYWxsIGJhY2sgdG8gYmF0Y2ggaW5nZXN0XG4gICAgICAgICAgICBpZiAoaXNMYW5nU21pdGhOb3RGb3VuZEVycm9yKGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtlLm1lc3NhZ2UudHJpbSgpfVxcblxcbkNvbnRleHQ6ICR7Y29udGV4dH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVSdW4ocnVuSWQsIHJ1biwgb3B0aW9ucykge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgaWYgKHJ1bi5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJ1bi5pbnB1dHMgPSBhd2FpdCB0aGlzLnByb2Nlc3NJbnB1dHMocnVuLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bi5vdXRwdXRzKSB7XG4gICAgICAgICAgICBydW4ub3V0cHV0cyA9IGF3YWl0IHRoaXMucHJvY2Vzc091dHB1dHMocnVuLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFVudGFuZ2xlIHR5cGVzXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7IC4uLnJ1biwgaWQ6IHJ1bklkIH07XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVyRm9yU2FtcGxpbmcoW2RhdGFdLCB0cnVlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hUcmFjaW5nICYmXG4gICAgICAgICAgICBkYXRhLnRyYWNlX2lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGRhdGEuZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG90ZWxDb250ZXh0ID0gdGhpcy5fY2xvbmVDdXJyZW50T1RFTENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChydW4uZW5kX3RpbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIGRhdGEucGFyZW50X3J1bl9pZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvbiAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm1hbnVhbEZsdXNoTW9kZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgYmF0Y2hlcyBhcyBzb29uIGFzIGEgcm9vdCB0cmFjZSBlbmRzIGFuZCB3YWl0IHRvIGVuc3VyZSB0cmFjZSBmaW5pc2hlc1xuICAgICAgICAgICAgICAgIC8vIGluIHNlcnZlcmxlc3MgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgb3RlbENvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGFwaUtleTogb3B0aW9ucz8uYXBpS2V5LFxuICAgICAgICAgICAgICAgICAgICBhcGlVcmw6IG9wdGlvbnM/LmFwaVVybCxcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgb3RlbENvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGFwaUtleTogb3B0aW9ucz8uYXBpS2V5LFxuICAgICAgICAgICAgICAgICAgICBhcGlVcmw6IG9wdGlvbnM/LmFwaVVybCxcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zPy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIngtYXBpLWtleVwiXSA9IG9wdGlvbnMuYXBpS2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zPy53b3Jrc3BhY2VJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC10ZW5hbnQtaWRcIl0gPSBvcHRpb25zLndvcmtzcGFjZUlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhydW4sIGBTZXJpYWxpemluZyBwYXlsb2FkIHRvIHVwZGF0ZSBydW4gd2l0aCBpZDogJHtydW5JZH1gKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHtvcHRpb25zPy5hcGlVcmwgPz8gdGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidXBkYXRlIHJ1blwiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyByZWFkUnVuKHJ1bklkLCB7IGxvYWRDaGlsZFJ1bnMgfSA9IHsgbG9hZENoaWxkUnVuczogZmFsc2UgfSkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgbGV0IHJ1biA9IGF3YWl0IHRoaXMuX2dldChgL3J1bnMvJHtydW5JZH1gKTtcbiAgICAgICAgaWYgKGxvYWRDaGlsZFJ1bnMpIHtcbiAgICAgICAgICAgIHJ1biA9IGF3YWl0IHRoaXMuX2xvYWRDaGlsZFJ1bnMocnVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBnZXRSdW5VcmwoeyBydW5JZCwgcnVuLCBwcm9qZWN0T3B0cywgfSkge1xuICAgICAgICBpZiAocnVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBzZXNzaW9uSWQ7XG4gICAgICAgICAgICBpZiAocnVuLnNlc3Npb25faWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBydW4uc2Vzc2lvbl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2plY3RPcHRzPy5wcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWU6IHByb2plY3RPcHRzPy5wcm9qZWN0TmFtZSB9KSkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9qZWN0T3B0cz8ucHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gcHJvamVjdE9wdHM/LnByb2plY3RJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2plY3QgPSBhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdE5hbWU6IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJQUk9KRUNUXCIpIHx8IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHByb2plY3QuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF3YWl0IHRoaXMuX2dldFRlbmFudElkKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vcHJvamVjdHMvcC8ke3Nlc3Npb25JZH0vci8ke3J1bi5pZH0/cG9sbD10cnVlYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBydW5fID0gYXdhaXQgdGhpcy5yZWFkUnVuKHJ1bklkKTtcbiAgICAgICAgICAgIGlmICghcnVuXy5hcHBfcGF0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVuICR7cnVuSWR9IGhhcyBubyBhcHBfcGF0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0SG9zdFVybCgpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9JHtydW5fLmFwcF9wYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHJ1bklkIG9yIHJ1blwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbG9hZENoaWxkUnVucyhydW4pIHtcbiAgICAgICAgY29uc3QgY2hpbGRSdW5zID0gYXdhaXQgdG9BcnJheSh0aGlzLmxpc3RSdW5zKHtcbiAgICAgICAgICAgIGlzUm9vdDogZmFsc2UsXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHJ1bi5zZXNzaW9uX2lkLFxuICAgICAgICAgICAgdHJhY2VJZDogcnVuLnRyYWNlX2lkLFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHRyZWVtYXAgPSB7fTtcbiAgICAgICAgY29uc3QgcnVucyA9IHt9O1xuICAgICAgICAvLyBUT0RPOiBtYWtlIGRvdHRlZCBvcmRlciByZXF1aXJlZCB3aGVuIHRoZSBtaWdyYXRpb24gZmluaXNoZXNcbiAgICAgICAgY2hpbGRSdW5zLnNvcnQoKGEsIGIpID0+IChhPy5kb3R0ZWRfb3JkZXIgPz8gXCJcIikubG9jYWxlQ29tcGFyZShiPy5kb3R0ZWRfb3JkZXIgPz8gXCJcIikpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkUnVuIG9mIGNoaWxkUnVucykge1xuICAgICAgICAgICAgaWYgKGNoaWxkUnVuLnBhcmVudF9ydW5faWQgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHJ1biAke2NoaWxkUnVuLmlkfSBoYXMgbm8gcGFyZW50YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRSdW4uZG90dGVkX29yZGVyPy5zdGFydHNXaXRoKHJ1bi5kb3R0ZWRfb3JkZXIgPz8gXCJcIikgJiZcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bi5pZCAhPT0gcnVuLmlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY2hpbGRSdW4ucGFyZW50X3J1bl9pZCBpbiB0cmVlbWFwKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyZWVtYXBbY2hpbGRSdW4ucGFyZW50X3J1bl9pZF0ucHVzaChjaGlsZFJ1bik7XG4gICAgICAgICAgICAgICAgcnVuc1tjaGlsZFJ1bi5pZF0gPSBjaGlsZFJ1bjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBydW4uY2hpbGRfcnVucyA9IHRyZWVtYXBbcnVuLmlkXSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCBydW5JZCBpbiB0cmVlbWFwKSB7XG4gICAgICAgICAgICBpZiAocnVuSWQgIT09IHJ1bi5pZCkge1xuICAgICAgICAgICAgICAgIHJ1bnNbcnVuSWRdLmNoaWxkX3J1bnMgPSB0cmVlbWFwW3J1bklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHJ1bnMgZnJvbSB0aGUgTGFuZ1NtaXRoIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gcHJvamVjdElkIC0gVGhlIElEIG9mIHRoZSBwcm9qZWN0IHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHBhcmVudFJ1bklkIC0gVGhlIElEIG9mIHRoZSBwYXJlbnQgcnVuIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gdHJhY2VJZCAtIFRoZSBJRCBvZiB0aGUgdHJhY2UgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSByZWZlcmVuY2VFeGFtcGxlSWQgLSBUaGUgSUQgb2YgdGhlIHJlZmVyZW5jZSBleGFtcGxlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIC0gVGhlIHN0YXJ0IHRpbWUgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBpc1Jvb3QgLSBJbmRpY2F0ZXMgd2hldGhlciB0byBvbmx5IHJldHVybiByb290IHJ1bnMuXG4gICAgICogQHBhcmFtIHJ1blR5cGUgLSBUaGUgcnVuIHR5cGUgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBlcnJvciAtIEluZGljYXRlcyB3aGV0aGVyIHRvIGZpbHRlciBieSBlcnJvciBydW5zLlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgcnVuIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgc3RyaW5nIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIC0gVGhlIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgdG8gdGhlIHJ1biBzcGFucy5cbiAgICAgKiBAcGFyYW0gdHJhY2VGaWx0ZXIgLSBUaGUgZmlsdGVyIHN0cmluZyB0byBhcHBseSBvbiB0aGUgcm9vdCBydW4gb2YgdGhlIHRyYWNlLlxuICAgICAqIEBwYXJhbSB0cmVlRmlsdGVyIC0gVGhlIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgb24gb3RoZXIgcnVucyBpbiB0aGUgdHJhY2UuXG4gICAgICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJ1bnMgdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMge0FzeW5jSXRlcmFibGU8UnVuPn0gLSBUaGUgcnVucy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyBpbiBhIHByb2plY3RcbiAgICAgKiBjb25zdCBwcm9qZWN0UnVucyA9IGNsaWVudC5saXN0UnVucyh7IHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIgfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgTExNIGFuZCBDaGF0IHJ1bnMgaW4gdGhlIGxhc3QgMjQgaG91cnNcbiAgICAgKiBjb25zdCB0b2RheXNMTE1SdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBzdGFydF90aW1lOiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMjQgKiA2MCAqIDYwICogMTAwMCksXG4gICAgICogICBydW5fdHlwZTogXCJsbG1cIixcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCB0cmFjZXMgaW4gYSBwcm9qZWN0XG4gICAgICogY29uc3Qgcm9vdFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGV4ZWN1dGlvbl9vcmRlcjogMSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBydW5zIHdpdGhvdXQgZXJyb3JzXG4gICAgICogY29uc3QgY29ycmVjdFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGVycm9yOiBmYWxzZSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBydW5zIGJ5IHJ1biBJRFxuICAgICAqIGNvbnN0IHJ1bklkcyA9IFtcbiAgICAgKiAgIFwiYTM2MDkyZDItNGFkNS00ZmI0LTljMGQtMGRiYTlhMmVkODM2XCIsXG4gICAgICogICBcIjkzOThlNmJlLTk2NGYtNGFhNC04YWU5LWFkNzhjZDRiNzA3NFwiLFxuICAgICAqIF07XG4gICAgICogY29uc3Qgc2VsZWN0ZWRSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHsgcnVuX2lkczogcnVuSWRzIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBcImNoYWluXCIgdHlwZSBydW5zIHRoYXQgdG9vayBtb3JlIHRoYW4gMTAgc2Vjb25kcyBhbmQgaGFkIGB0b3RhbF90b2tlbnNgIGdyZWF0ZXIgdGhhbiA1MDAwXG4gICAgICogY29uc3QgY2hhaW5SdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdhbmQoZXEocnVuX3R5cGUsIFwiY2hhaW5cIiksIGd0KGxhdGVuY3ksIDEwKSwgZ3QodG90YWxfdG9rZW5zLCA1MDAwKSknLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIGNhbGxlZCBcImV4dHJhY3RvclwiIHdob3NlIHJvb3Qgb2YgdGhlIHRyYWNlIHdhcyBhc3NpZ25lZCBmZWVkYmFjayBcInVzZXJfc2NvcmVcIiBzY29yZSBvZiAxXG4gICAgICogY29uc3QgZ29vZEV4dHJhY3RvclJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2VxKG5hbWUsIFwiZXh0cmFjdG9yXCIpJyxcbiAgICAgKiAgIHRyYWNlRmlsdGVyOiAnYW5kKGVxKGZlZWRiYWNrX2tleSwgXCJ1c2VyX3Njb3JlXCIpLCBlcShmZWVkYmFja19zY29yZSwgMSkpJyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyB0aGF0IHN0YXJ0ZWQgYWZ0ZXIgYSBzcGVjaWZpYyB0aW1lc3RhbXAgYW5kIGVpdGhlciBoYXZlIFwiZXJyb3JcIiBub3QgZXF1YWwgdG8gbnVsbCBvciBhIFwiQ29ycmVjdG5lc3NcIiBmZWVkYmFjayBzY29yZSBlcXVhbCB0byAwXG4gICAgICogY29uc3QgY29tcGxleFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChndChzdGFydF90aW1lLCBcIjIwMjMtMDctMTVUMTI6MzQ6NTZaXCIpLCBvcihuZXEoZXJyb3IsIG51bGwpLCBhbmQoZXEoZmVlZGJhY2tfa2V5LCBcIkNvcnJlY3RuZXNzXCIpLCBlcShmZWVkYmFja19zY29yZSwgMC4wKSkpKScsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgd2hlcmUgYHRhZ3NgIGluY2x1ZGUgXCJleHBlcmltZW50YWxcIiBvciBcImJldGFcIiBhbmQgYGxhdGVuY3lgIGlzIGdyZWF0ZXIgdGhhbiAyIHNlY29uZHNcbiAgICAgKiBjb25zdCB0YWdnZWRSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdhbmQob3IoaGFzKHRhZ3MsIFwiZXhwZXJpbWVudGFsXCIpLCBoYXModGFncywgXCJiZXRhXCIpKSwgZ3QobGF0ZW5jeSwgMikpJyxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhc3luYyAqbGlzdFJ1bnMocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBwYXJlbnRSdW5JZCwgdHJhY2VJZCwgcmVmZXJlbmNlRXhhbXBsZUlkLCBzdGFydFRpbWUsIGV4ZWN1dGlvbk9yZGVyLCBpc1Jvb3QsIHJ1blR5cGUsIGVycm9yLCBpZCwgcXVlcnksIGZpbHRlciwgdHJhY2VGaWx0ZXIsIHRyZWVGaWx0ZXIsIGxpbWl0LCBzZWxlY3QsIG9yZGVyLCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBwcm9qZWN0SWRzID0gW107XG4gICAgICAgIGlmIChwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZHMgPSBBcnJheS5pc0FycmF5KHByb2plY3RJZCkgPyBwcm9qZWN0SWQgOiBbcHJvamVjdElkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3ROYW1lcyA9IEFycmF5LmlzQXJyYXkocHJvamVjdE5hbWUpXG4gICAgICAgICAgICAgICAgPyBwcm9qZWN0TmFtZVxuICAgICAgICAgICAgICAgIDogW3Byb2plY3ROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RJZHNfID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvamVjdE5hbWVzLm1hcCgobmFtZSkgPT4gdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lOiBuYW1lIH0pLnRoZW4oKHByb2plY3QpID0+IHByb2plY3QuaWQpKSk7XG4gICAgICAgICAgICBwcm9qZWN0SWRzLnB1c2goLi4ucHJvamVjdElkc18pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRfc2VsZWN0ID0gW1xuICAgICAgICAgICAgXCJhcHBfcGF0aFwiLFxuICAgICAgICAgICAgXCJjb21wbGV0aW9uX2Nvc3RcIixcbiAgICAgICAgICAgIFwiY29tcGxldGlvbl90b2tlbnNcIixcbiAgICAgICAgICAgIFwiZG90dGVkX29yZGVyXCIsXG4gICAgICAgICAgICBcImVuZF90aW1lXCIsXG4gICAgICAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICBcImV2ZW50c1wiLFxuICAgICAgICAgICAgXCJleHRyYVwiLFxuICAgICAgICAgICAgXCJmZWVkYmFja19zdGF0c1wiLFxuICAgICAgICAgICAgXCJmaXJzdF90b2tlbl90aW1lXCIsXG4gICAgICAgICAgICBcImlkXCIsXG4gICAgICAgICAgICBcImlucHV0c1wiLFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICBcIm91dHB1dHNcIixcbiAgICAgICAgICAgIFwicGFyZW50X3J1bl9pZFwiLFxuICAgICAgICAgICAgXCJwYXJlbnRfcnVuX2lkc1wiLFxuICAgICAgICAgICAgXCJwcm9tcHRfY29zdFwiLFxuICAgICAgICAgICAgXCJwcm9tcHRfdG9rZW5zXCIsXG4gICAgICAgICAgICBcInJlZmVyZW5jZV9leGFtcGxlX2lkXCIsXG4gICAgICAgICAgICBcInJ1bl90eXBlXCIsXG4gICAgICAgICAgICBcInNlc3Npb25faWRcIixcbiAgICAgICAgICAgIFwic3RhcnRfdGltZVwiLFxuICAgICAgICAgICAgXCJzdGF0dXNcIixcbiAgICAgICAgICAgIFwidGFnc1wiLFxuICAgICAgICAgICAgXCJ0b3RhbF9jb3N0XCIsXG4gICAgICAgICAgICBcInRvdGFsX3Rva2Vuc1wiLFxuICAgICAgICAgICAgXCJ0cmFjZV9pZFwiLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgc2Vzc2lvbjogcHJvamVjdElkcy5sZW5ndGggPyBwcm9qZWN0SWRzIDogbnVsbCxcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW5UeXBlLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGU6IHJlZmVyZW5jZUV4YW1wbGVJZCxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgdHJhY2VfZmlsdGVyOiB0cmFjZUZpbHRlcixcbiAgICAgICAgICAgIHRyZWVfZmlsdGVyOiB0cmVlRmlsdGVyLFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25PcmRlcixcbiAgICAgICAgICAgIHBhcmVudF9ydW46IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogc3RhcnRUaW1lID8gc3RhcnRUaW1lLnRvSVNPU3RyaW5nKCkgOiBudWxsLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgICAgdHJhY2U6IHRyYWNlSWQsXG4gICAgICAgICAgICBzZWxlY3Q6IHNlbGVjdCA/IHNlbGVjdCA6IGRlZmF1bHRfc2VsZWN0LFxuICAgICAgICAgICAgaXNfcm9vdDogaXNSb290LFxuICAgICAgICAgICAgb3JkZXIsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChib2R5LnNlbGVjdC5pbmNsdWRlcyhcImNoaWxkX3J1bl9pZHNcIikpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFwiRGVwcmVjYXRlZDogJ2NoaWxkX3J1bl9pZHMnIGluIHRoZSBsaXN0UnVucyBzZWxlY3QgcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcnVuc1lpZWxkZWQgPSAwO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHJ1bnMgb2YgdGhpcy5fZ2V0Q3Vyc29yUGFnaW5hdGVkTGlzdChcIi9ydW5zL3F1ZXJ5XCIsIGJvZHkpKSB7XG4gICAgICAgICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAocnVuc1lpZWxkZWQgPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5zLmxlbmd0aCArIHJ1bnNZaWVsZGVkID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UnVucyA9IHJ1bnMuc2xpY2UoMCwgbGltaXQgLSBydW5zWWllbGRlZCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiBuZXdSdW5zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVuc1lpZWxkZWQgKz0gcnVucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgeWllbGQqIHJ1bnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogcnVucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqbGlzdEdyb3VwUnVucyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIGdyb3VwQnksIGZpbHRlciwgc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW1pdCwgb2Zmc2V0LCB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHByb2plY3RJZCB8fCAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgY29uc3QgYmFzZUJvZHkgPSB7XG4gICAgICAgICAgICBzZXNzaW9uX2lkOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICBncm91cF9ieTogZ3JvdXBCeSxcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHN0YXJ0VGltZSA/IHN0YXJ0VGltZS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgICAgIGVuZF90aW1lOiBlbmRUaW1lID8gZW5kVGltZS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgICAgIGxpbWl0OiBOdW1iZXIobGltaXQpIHx8IDEwMCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGN1cnJlbnRPZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwO1xuICAgICAgICBjb25zdCBwYXRoID0gXCIvcnVucy9ncm91cFwiO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0ke3BhdGh9YDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCb2R5ID0ge1xuICAgICAgICAgICAgICAgIC4uLmJhc2VCb2R5LFxuICAgICAgICAgICAgICAgIG9mZnNldDogY3VycmVudE9mZnNldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBSZW1vdmUgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFBheWxvYWQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY3VycmVudEJvZHkpLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGZpbHRlcmVkUGF5bG9hZCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgYEZhaWxlZCB0byBmZXRjaCAke3BhdGh9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zdCB7IGdyb3VwcywgdG90YWwgfSA9IGl0ZW1zO1xuICAgICAgICAgICAgaWYgKGdyb3Vwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdGhyZWFkIG9mIGdyb3Vwcykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRocmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRPZmZzZXQgKz0gZ3JvdXBzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50T2Zmc2V0ID49IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UnVuU3RhdHMoeyBpZCwgdHJhY2UsIHBhcmVudFJ1biwgcnVuVHlwZSwgcHJvamVjdE5hbWVzLCBwcm9qZWN0SWRzLCByZWZlcmVuY2VFeGFtcGxlSWRzLCBzdGFydFRpbWUsIGVuZFRpbWUsIGVycm9yLCBxdWVyeSwgZmlsdGVyLCB0cmFjZUZpbHRlciwgdHJlZUZpbHRlciwgaXNSb290LCBkYXRhU291cmNlVHlwZSwgfSkge1xuICAgICAgICBsZXQgcHJvamVjdElkc18gPSBwcm9qZWN0SWRzIHx8IFtdO1xuICAgICAgICBpZiAocHJvamVjdE5hbWVzKSB7XG4gICAgICAgICAgICBwcm9qZWN0SWRzXyA9IFtcbiAgICAgICAgICAgICAgICAuLi4ocHJvamVjdElkcyB8fCBbXSksXG4gICAgICAgICAgICAgICAgLi4uKGF3YWl0IFByb21pc2UuYWxsKHByb2plY3ROYW1lcy5tYXAoKG5hbWUpID0+IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogbmFtZSB9KS50aGVuKChwcm9qZWN0KSA9PiBwcm9qZWN0LmlkKSkpKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdHJhY2UsXG4gICAgICAgICAgICBwYXJlbnRfcnVuOiBwYXJlbnRSdW4sXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuVHlwZSxcbiAgICAgICAgICAgIHNlc3Npb246IHByb2plY3RJZHNfLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGU6IHJlZmVyZW5jZUV4YW1wbGVJZHMsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUsXG4gICAgICAgICAgICBlbmRfdGltZTogZW5kVGltZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICB0cmFjZV9maWx0ZXI6IHRyYWNlRmlsdGVyLFxuICAgICAgICAgICAgdHJlZV9maWx0ZXI6IHRyZWVGaWx0ZXIsXG4gICAgICAgICAgICBpc19yb290OiBpc1Jvb3QsXG4gICAgICAgICAgICBkYXRhX3NvdXJjZV90eXBlOiBkYXRhU291cmNlVHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSB0aGUgcGF5bG9hZFxuICAgICAgICBjb25zdCBmaWx0ZXJlZFBheWxvYWQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocGF5bG9hZCkuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShmaWx0ZXJlZFBheWxvYWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3J1bnMvc3RhdHNgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiZ2V0IHJ1biBzdGF0c1wiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlUnVuKHJ1bklkLCB7IHNoYXJlSWQgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgc2hhcmVfdG9rZW46IHNoYXJlSWQgfHwgdXVpZC52NCgpLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwic2hhcmUgcnVuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlUnVuKHJ1bklkKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1bnNoYXJlIHJ1blwiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyByZWFkUnVuU2hhcmVkTGluayhydW5JZCkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJyZWFkIHJ1biBzaGFyZWQgbGlua1wiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgIShcInNoYXJlX3Rva2VuXCIgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3Jlc3VsdFtcInNoYXJlX3Rva2VuXCJdfS9yYDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdFNoYXJlZFJ1bnMoc2hhcmVUb2tlbiwgeyBydW5JZHMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgc2hhcmVfdG9rZW46IHNoYXJlVG9rZW4sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocnVuSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuSWQgb2YgcnVuSWRzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwiaWRcIiwgcnVuSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoc2hhcmVUb2tlbik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vcnVucyR7cXVlcnlQYXJhbXN9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJsaXN0IHNoYXJlZCBydW5zXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJ1bnMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBydW5zO1xuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YXNldFNoYXJlZFNjaGVtYShkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJyZWFkIGRhdGFzZXQgc2hhcmVkIHNjaGVtYVwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaGFyZVNjaGVtYSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2hhcmVTY2hlbWEudXJsID0gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3NoYXJlU2NoZW1hLnNoYXJlX3Rva2VufS9kYDtcbiAgICAgICAgcmV0dXJuIHNoYXJlU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyBzaGFyZURhdGFzZXQoZGF0YXNldElkLCBkYXRhc2V0TmFtZSkge1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciBkYXRhc2V0SWQgb3IgZGF0YXNldE5hbWUgbXVzdCBiZSBnaXZlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGRhdGFzZXRfaWQ6IGRhdGFzZXRJZCxcbiAgICAgICAgfTtcbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInNoYXJlIGRhdGFzZXRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2hhcmVTY2hlbWEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNoYXJlU2NoZW1hLnVybCA9IGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtzaGFyZVNjaGVtYS5zaGFyZV90b2tlbn0vZGA7XG4gICAgICAgIHJldHVybiBzaGFyZVNjaGVtYTtcbiAgICB9XG4gICAgYXN5bmMgdW5zaGFyZURhdGFzZXQoZGF0YXNldElkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1bnNoYXJlIGRhdGFzZXRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFNoYXJlZERhdGFzZXQoc2hhcmVUb2tlbikge1xuICAgICAgICBhc3NlcnRVdWlkKHNoYXJlVG9rZW4pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3B1YmxpYy8ke3NoYXJlVG9rZW59L2RhdGFzZXRzYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJyZWFkIHNoYXJlZCBkYXRhc2V0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2hhcmVkIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNoYXJlVG9rZW4gVGhlIHNoYXJlIHRva2VuIHRvIGdldCBleGFtcGxlcyBmb3IuIEEgc2hhcmUgdG9rZW4gaXMgdGhlIFVVSUQgKG9yIExhbmdTbWl0aCBVUkwsIGluY2x1ZGluZyBVVUlEKSBnZW5lcmF0ZWQgd2hlbiBleHBsaWNpdGx5IG1hcmtpbmcgYW4gZXhhbXBsZSBhcyBwdWJsaWMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxpc3RpbmcgdGhlIGV4YW1wbGVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW10gfCB1bmRlZmluZWR9IFtvcHRpb25zLmV4YW1wbGVJZHNdIEEgbGlzdCBvZiBleGFtcGxlIElEcyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RXhhbXBsZVtdPn0gVGhlIHNoYXJlZCBleGFtcGxlcy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0U2hhcmVkRXhhbXBsZXMoc2hhcmVUb2tlbiwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmV4YW1wbGVJZHMpIHtcbiAgICAgICAgICAgIHBhcmFtcy5pZCA9IG9wdGlvbnMuZXhhbXBsZUlkcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB1cmxQYXJhbXMuYXBwZW5kKGtleSwgdikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vZXhhbXBsZXM/JHt1cmxQYXJhbXMudG9TdHJpbmcoKX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImxpc3Qgc2hhcmVkIGV4YW1wbGVzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgaWYgKFwiZGV0YWlsXCIgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCBzaGFyZWQgZXhhbXBsZXMuXFxuU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31cXG5NZXNzYWdlOiAke0FycmF5LmlzQXJyYXkocmVzdWx0LmRldGFpbClcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQuZGV0YWlsLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICAgICAgICAgICAgOiBcIlVuc3BlY2lmaWVkIGVycm9yXCJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsaXN0IHNoYXJlZCBleGFtcGxlczogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcCgoZXhhbXBsZSkgPT4gKHtcbiAgICAgICAgICAgIC4uLmV4YW1wbGUsXG4gICAgICAgICAgICBfaG9zdFVybDogdGhpcy5nZXRIb3N0VXJsKCksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUHJvamVjdCh7IHByb2plY3ROYW1lLCBkZXNjcmlwdGlvbiA9IG51bGwsIG1ldGFkYXRhID0gbnVsbCwgdXBzZXJ0ID0gZmFsc2UsIHByb2plY3RFeHRyYSA9IG51bGwsIHJlZmVyZW5jZURhdGFzZXRJZCA9IG51bGwsIH0pIHtcbiAgICAgICAgY29uc3QgdXBzZXJ0XyA9IHVwc2VydCA/IGA/dXBzZXJ0PXRydWVgIDogXCJcIjtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMke3Vwc2VydF99YDtcbiAgICAgICAgY29uc3QgZXh0cmEgPSBwcm9qZWN0RXh0cmEgfHwge307XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZXh0cmFbXCJtZXRhZGF0YVwiXSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lOiBwcm9qZWN0TmFtZSxcbiAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZWZlcmVuY2VEYXRhc2V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGJvZHlbXCJyZWZlcmVuY2VfZGF0YXNldF9pZFwiXSA9IHJlZmVyZW5jZURhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpYWxpemVkQm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHk6IHNlcmlhbGl6ZWRCb2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiY3JlYXRlIHByb2plY3RcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVQcm9qZWN0KHByb2plY3RJZCwgeyBuYW1lID0gbnVsbCwgZGVzY3JpcHRpb24gPSBudWxsLCBtZXRhZGF0YSA9IG51bGwsIHByb2plY3RFeHRyYSA9IG51bGwsIGVuZFRpbWUgPSBudWxsLCB9KSB7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5hcGlVcmx9L3Nlc3Npb25zLyR7cHJvamVjdElkfWA7XG4gICAgICAgIGxldCBleHRyYSA9IHByb2plY3RFeHRyYTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBleHRyYSA9IHsgLi4uKGV4dHJhIHx8IHt9KSwgbWV0YWRhdGEgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBlbmRfdGltZTogZW5kVGltZSA/IG5ldyBEYXRlKGVuZFRpbWUpLnRvSVNPU3RyaW5nKCkgOiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwZGF0ZSBwcm9qZWN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgaGFzUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIH0pIHtcbiAgICAgICAgLy8gVE9ETzogQWRkIGEgaGVhZCByZXF1ZXN0XG4gICAgICAgIGxldCBwYXRoID0gXCIvc2Vzc2lvbnNcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKHByb2plY3RJZCk7XG4gICAgICAgICAgICBwYXRoICs9IGAvJHtwcm9qZWN0SWR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBwcm9qZWN0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiaGFzIHByb2plY3RcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBPSyBhbmQgd2UncmUgcXVlcnlpbmcgYnkgbmFtZSwgbmVlZCB0byBjaGVjayB0aGUgbGlzdCBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9qZWN0SWQgcXVlcnlpbmdcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZFByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBpbmNsdWRlU3RhdHMsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVTdGF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5jbHVkZV9zdGF0c1wiLCBpbmNsdWRlU3RhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9qZWN0W2lkPSR7cHJvamVjdElkfSwgbmFtZT0ke3Byb2plY3ROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGdldFByb2plY3RVcmwoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9qZWN0ID0gYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUgfSk7XG4gICAgICAgIGNvbnN0IHRlbmFudElkID0gYXdhaXQgdGhpcy5fZ2V0VGVuYW50SWQoKTtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9vLyR7dGVuYW50SWR9L3Byb2plY3RzL3AvJHtwcm9qZWN0LmlkfWA7XG4gICAgfVxuICAgIGFzeW5jIGdldERhdGFzZXRVcmwoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgIGNvbnN0IHRlbmFudElkID0gYXdhaXQgdGhpcy5fZ2V0VGVuYW50SWQoKTtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9vLyR7dGVuYW50SWR9L2RhdGFzZXRzLyR7ZGF0YXNldC5pZH1gO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VGVuYW50SWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZW5hbnRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RlbmFudElkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGxpbWl0OiBcIjFcIiB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9qZWN0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvc2Vzc2lvbnNcIiwgcXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICB0aGlzLl90ZW5hbnRJZCA9IHByb2plY3RzWzBdLnRlbmFudF9pZDtcbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0c1swXS50ZW5hbnRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvamVjdHMgZm91bmQgdG8gcmVzb2x2ZSB0ZW5hbnQuXCIpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdFByb2plY3RzKHsgcHJvamVjdElkcywgbmFtZSwgbmFtZUNvbnRhaW5zLCByZWZlcmVuY2VEYXRhc2V0SWQsIHJlZmVyZW5jZURhdGFzZXROYW1lLCBpbmNsdWRlU3RhdHMsIGRhdGFzZXRWZXJzaW9uLCByZWZlcmVuY2VGcmVlLCBtZXRhZGF0YSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9qZWN0SWQgb2YgcHJvamVjdElkcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZFwiLCBwcm9qZWN0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lQ29udGFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVfY29udGFpbnNcIiwgbmFtZUNvbnRhaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmZXJlbmNlRGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZGF0YXNldFwiLCByZWZlcmVuY2VEYXRhc2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZmVyZW5jZURhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0TmFtZTogcmVmZXJlbmNlRGF0YXNldE5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZGF0YXNldFwiLCBkYXRhc2V0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZVN0YXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpbmNsdWRlX3N0YXRzXCIsIGluY2x1ZGVTdGF0cy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldFZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImRhdGFzZXRfdmVyc2lvblwiLCBkYXRhc2V0VmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZUZyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9mcmVlXCIsIHJlZmVyZW5jZUZyZWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJtZXRhZGF0YVwiLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcHJvamVjdHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL3Nlc3Npb25zXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBwcm9qZWN0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWxldGVQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcHJvamVjdElkXztcbiAgICAgICAgaWYgKHByb2plY3RJZCA9PT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3RJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9qZWN0SWRfID0gKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZSB9KSkuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9qZWN0SWRfID0gcHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkXyk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3Nlc3Npb25zLyR7cHJvamVjdElkX31gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBgZGVsZXRlIHNlc3Npb24gJHtwcm9qZWN0SWRffSAoJHtwcm9qZWN0TmFtZX0pYCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkQ3N2KHsgY3N2RmlsZSwgZmlsZU5hbWUsIGlucHV0S2V5cywgb3V0cHV0S2V5cywgZGVzY3JpcHRpb24sIGRhdGFUeXBlLCBuYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy91cGxvYWRgO1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGNzdkZpbGUsIGZpbGVOYW1lKTtcbiAgICAgICAgaW5wdXRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiaW5wdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm91dHB1dF9rZXlzXCIsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRhdGFfdHlwZVwiLCBkYXRhVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidXBsb2FkIENTVlwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZURhdGFzZXQobmFtZSwgeyBkZXNjcmlwdGlvbiwgZGF0YVR5cGUsIGlucHV0c1NjaGVtYSwgb3V0cHV0c1NjaGVtYSwgbWV0YWRhdGEsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGJvZHkuZGF0YV90eXBlID0gZGF0YVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0c1NjaGVtYSkge1xuICAgICAgICAgICAgYm9keS5pbnB1dHNfc2NoZW1hX2RlZmluaXRpb24gPSBpbnB1dHNTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dHB1dHNTY2hlbWEpIHtcbiAgICAgICAgICAgIGJvZHkub3V0cHV0c19zY2hlbWFfZGVmaW5pdGlvbiA9IG91dHB1dHNTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHk6IHNlcmlhbGl6ZWRCb2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiY3JlYXRlIGRhdGFzZXRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICAvLyBsaW1pdCB0byAxIHJlc3VsdFxuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgbGltaXQ6IFwiMVwiIH0pO1xuICAgICAgICBpZiAoZGF0YXNldElkICYmIGRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgICAgICBwYXRoICs9IGAvJHtkYXRhc2V0SWR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgZGF0YXNldE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFzZXRbaWQ9JHtkYXRhc2V0SWR9LCBuYW1lPSR7ZGF0YXNldE5hbWV9XSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgaGFzRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgIGUubWVzc2FnZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluY2x1ZGVzKFwibm90IGZvdW5kXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkaWZmRGF0YXNldFZlcnNpb25zKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgZnJvbVZlcnNpb24sIHRvVmVyc2lvbiwgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgZnJvbV92ZXJzaW9uOiB0eXBlb2YgZnJvbVZlcnNpb24gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGZyb21WZXJzaW9uXG4gICAgICAgICAgICAgICAgOiBmcm9tVmVyc2lvbi50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdG9fdmVyc2lvbjogdHlwZW9mIHRvVmVyc2lvbiA9PT0gXCJzdHJpbmdcIiA/IHRvVmVyc2lvbiA6IHRvVmVyc2lvbi50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQoYC9kYXRhc2V0cy8ke2RhdGFzZXRJZF99L3ZlcnNpb25zL2RpZmZgLCB1cmxQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0T3BlbmFpRmluZXR1bmluZyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXRSZXNwb25zZShgJHtwYXRofS8ke2RhdGFzZXRJZH0vb3BlbmFpX2Z0YCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldFRleHRcbiAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgIC5zcGxpdChcIlxcblwiKVxuICAgICAgICAgICAgLm1hcCgobGluZSkgPT4gSlNPTi5wYXJzZShsaW5lKSk7XG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgICBhc3luYyAqbGlzdERhdGFzZXRzKHsgbGltaXQgPSAxMDAsIG9mZnNldCA9IDAsIGRhdGFzZXRJZHMsIGRhdGFzZXROYW1lLCBkYXRhc2V0TmFtZUNvbnRhaW5zLCBtZXRhZGF0YSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGxpbWl0OiBsaW1pdC50b1N0cmluZygpLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfIG9mIGRhdGFzZXRJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgaWRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgZGF0YXNldE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0TmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIGRhdGFzZXROYW1lQ29udGFpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGRhdGFzZXRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChwYXRoLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZGF0YXNldHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgZGF0YXNldFxuICAgICAqIEBwYXJhbSBwcm9wcyBUaGUgZGF0YXNldCBkZXRhaWxzIHRvIHVwZGF0ZVxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGRhdGFzZXRcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVEYXRhc2V0KHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgLi4udXBkYXRlIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQgJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfZGF0YXNldElkID0gZGF0YXNldElkID8/IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICBhc3NlcnRVdWlkKF9kYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkodXBkYXRlKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke19kYXRhc2V0SWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1cGRhdGUgZGF0YXNldFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSB0YWcgb24gYSBkYXRhc2V0LlxuICAgICAqXG4gICAgICogSWYgdGhlIHRhZyBpcyBhbHJlYWR5IGFzc2lnbmVkIHRvIGEgZGlmZmVyZW50IHZlcnNpb24gb2YgdGhpcyBkYXRhc2V0LFxuICAgICAqIHRoZSB0YWcgd2lsbCBiZSBtb3ZlZCB0byB0aGUgbmV3IHZlcnNpb24uIFRoZSBhc19vZiBwYXJhbWV0ZXIgaXMgdXNlZCB0b1xuICAgICAqIGRldGVybWluZSB3aGljaCB2ZXJzaW9uIG9mIHRoZSBkYXRhc2V0IHRvIGFwcGx5IHRoZSBuZXcgdGFncyB0by5cbiAgICAgKlxuICAgICAqIEl0IG11c3QgYmUgYW4gZXhhY3QgdmVyc2lvbiBvZiB0aGUgZGF0YXNldCB0byBzdWNjZWVkLiBZb3UgY2FuXG4gICAgICogdXNlIHRoZSBcInJlYWREYXRhc2V0VmVyc2lvblwiIG1ldGhvZCB0byBmaW5kIHRoZSBleGFjdCB2ZXJzaW9uXG4gICAgICogdG8gYXBwbHkgdGhlIHRhZ3MgdG8uXG4gICAgICogQHBhcmFtIHBhcmFtcy5kYXRhc2V0SWQgVGhlIElEIG9mIHRoZSBkYXRhc2V0IHRvIHVwZGF0ZS4gTXVzdCBiZSBwcm92aWRlZCBpZiBcImRhdGFzZXROYW1lXCIgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSBwYXJhbXMuZGF0YXNldE5hbWUgVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gdXBkYXRlLiBNdXN0IGJlIHByb3ZpZGVkIGlmIFwiZGF0YXNldElkXCIgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSBwYXJhbXMuYXNPZiBUaGUgdGltZXN0YW1wIG9mIHRoZSBkYXRhc2V0IHRvIGFwcGx5IHRoZSBuZXcgdGFncyB0by5cbiAgICAgKiBAcGFyYW0gcGFyYW1zLnRhZyBUaGUgbmV3IHRhZyB0byBhcHBseSB0byB0aGUgZGF0YXNldC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVEYXRhc2V0VGFnKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgYXNPZiwgdGFnIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQgJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfZGF0YXNldElkID0gZGF0YXNldElkID8/IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICBhc3NlcnRVdWlkKF9kYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgYXNfb2Y6IHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiID8gYXNPZiA6IGFzT2YudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHRhZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7X2RhdGFzZXRJZH0vdGFnc2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwZGF0ZSBkYXRhc2V0IHRhZ3NcIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZF99YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaCh0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIGBkZWxldGUgJHtwYXRofWAsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGluZGV4RGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIHRhZywgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWRfICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAmJiBkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkYXRhc2V0SWRfKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWRffS9pbmRleGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJpbmRleCBkYXRhc2V0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGV0cyB5b3UgcnVuIGEgc2ltaWxhcml0eSBzZWFyY2ggcXVlcnkgb24gYSBkYXRhc2V0LlxuICAgICAqXG4gICAgICogUmVxdWlyZXMgdGhlIGRhdGFzZXQgdG8gYmUgaW5kZXhlZC4gUGxlYXNlIHNlZSB0aGUgYGluZGV4RGF0YXNldGAgbWV0aG9kIHRvIHNldCB1cCBpbmRleGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dHMgICAgICBUaGUgaW5wdXQgb24gd2hpY2ggdG8gcnVuIHRoZSBzaW1pbGFyaXR5IHNlYXJjaC4gTXVzdCBoYXZlIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICBzYW1lIHNjaGVtYSBhcyB0aGUgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhc2V0SWQgICBUaGUgZGF0YXNldCB0byBzZWFyY2ggZm9yIHNpbWlsYXIgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGltaXQgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGV4YW1wbGVzIHRvIHJldHVybi4gV2lsbCByZXR1cm4gdGhlIHRvcCBgbGltaXRgIG1vc3RcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgc2ltaWxhciBleGFtcGxlcyBpbiBvcmRlciBvZiBtb3N0IHNpbWlsYXIgdG8gbGVhc3Qgc2ltaWxhci4gSWYgbm8gc2ltaWxhclxuICAgICAqICAgICAgICAgICAgICAgICAgICBleGFtcGxlcyBhcmUgZm91bmQsIHJhbmRvbSBleGFtcGxlcyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbHRlciAgICAgIEEgZmlsdGVyIHN0cmluZyB0byBhcHBseSB0byB0aGUgc2VhcmNoLiBPbmx5IGV4YW1wbGVzIHdpbGwgYmUgcmV0dXJuZWQgdGhhdFxuICAgICAqICAgICAgICAgICAgICAgICAgICBtYXRjaCB0aGUgZmlsdGVyIHN0cmluZy4gU29tZSBleGFtcGxlcyBvZiBmaWx0ZXJzXG4gICAgICpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBlcShtZXRhZGF0YS5teWtleSwgXCJ2YWx1ZVwiKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIGFuZChuZXEobWV0YWRhdGEubXkubmVzdGVkLmtleSwgXCJ2YWx1ZVwiKSwgbmVxKG1ldGFkYXRhLm15a2V5LCBcInZhbHVlXCIpKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIG9yKGVxKG1ldGFkYXRhLm15a2V5LCBcInZhbHVlXCIpLCBlcShtZXRhZGF0YS5teWtleSwgXCJvdGhlcnZhbHVlXCIpKVxuICAgICAqXG4gICAgICogQHJldHVybnMgICAgICAgICAgIEEgbGlzdCBvZiBzaW1pbGFyIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGFzZXRfaWQgPSBcIjEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMFwiXG4gICAgICogaW5wdXRzID0ge1widGV4dFwiOiBcIkhvdyBtYW55IHBlb3BsZSBsaXZlIGluIEJlcmxpbj9cIn1cbiAgICAgKiBsaW1pdCA9IDVcbiAgICAgKiBleGFtcGxlcyA9IGF3YWl0IGNsaWVudC5zaW1pbGFyRXhhbXBsZXMoaW5wdXRzLCBkYXRhc2V0X2lkLCBsaW1pdClcbiAgICAgKi9cbiAgICBhc3luYyBzaW1pbGFyRXhhbXBsZXMoaW5wdXRzLCBkYXRhc2V0SWQsIGxpbWl0LCB7IGZpbHRlciwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICBpbnB1dHM6IGlucHV0cyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhW1wiZmlsdGVyXCJdID0gZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zZWFyY2hgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiZmV0Y2ggc2ltaWxhciBleGFtcGxlc1wiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHRbXCJleGFtcGxlc1wiXTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRXhhbXBsZShpbnB1dHNPclVwZGF0ZSwgb3V0cHV0cywgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNFeGFtcGxlQ3JlYXRlKGlucHV0c09yVXBkYXRlKSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dHMgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcHJvdmlkZSBvdXRwdXRzIG9yIG9wdGlvbnMgd2hlbiB1c2luZyBFeGFtcGxlQ3JlYXRlIG9iamVjdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YXNldElkXyA9IG91dHB1dHMgPyBvcHRpb25zPy5kYXRhc2V0SWQgOiBpbnB1dHNPclVwZGF0ZS5kYXRhc2V0X2lkO1xuICAgICAgICBjb25zdCBkYXRhc2V0TmFtZV8gPSBvdXRwdXRzXG4gICAgICAgICAgICA/IG9wdGlvbnM/LmRhdGFzZXROYW1lXG4gICAgICAgICAgICA6IGlucHV0c09yVXBkYXRlLmRhdGFzZXRfbmFtZTtcbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lOiBkYXRhc2V0TmFtZV8gfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVkQXRfID0gKG91dHB1dHMgPyBvcHRpb25zPy5jcmVhdGVkQXQgOiBpbnB1dHNPclVwZGF0ZS5jcmVhdGVkX2F0KSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKCFpc0V4YW1wbGVDcmVhdGUoaW5wdXRzT3JVcGRhdGUpKSB7XG4gICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGlucHV0czogaW5wdXRzT3JVcGRhdGUsXG4gICAgICAgICAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBjcmVhdGVkQXRfPy50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGlkOiBvcHRpb25zPy5leGFtcGxlSWQsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG9wdGlvbnM/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHNwbGl0OiBvcHRpb25zPy5zcGxpdCxcbiAgICAgICAgICAgICAgICBzb3VyY2VfcnVuX2lkOiBvcHRpb25zPy5zb3VyY2VSdW5JZCxcbiAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9pbzogb3B0aW9ucz8udXNlU291cmNlUnVuSU8sXG4gICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHM6IG9wdGlvbnM/LnVzZVNvdXJjZVJ1bkF0dGFjaG1lbnRzLFxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBvcHRpb25zPy5hdHRhY2htZW50cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gaW5wdXRzT3JVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl91cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWRfLCBbZGF0YV0pO1xuICAgICAgICBjb25zdCBleGFtcGxlID0gYXdhaXQgdGhpcy5yZWFkRXhhbXBsZShyZXNwb25zZS5leGFtcGxlX2lkcz8uWzBdID8/IHV1aWQudjQoKSk7XG4gICAgICAgIHJldHVybiBleGFtcGxlO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlcyhwcm9wc09yVXBsb2Fkcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wc09yVXBsb2FkcykpIHtcbiAgICAgICAgICAgIGlmIChwcm9wc09yVXBsb2Fkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cGxvYWRzID0gcHJvcHNPclVwbG9hZHM7XG4gICAgICAgICAgICBsZXQgZGF0YXNldElkXyA9IHVwbG9hZHNbMF0uZGF0YXNldF9pZDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXROYW1lXyA9IHVwbG9hZHNbMF0uZGF0YXNldF9uYW1lO1xuICAgICAgICAgICAgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZTogZGF0YXNldE5hbWVfIH0pO1xuICAgICAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl91cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWRfLCB1cGxvYWRzKTtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzcG9uc2UuZXhhbXBsZV9pZHMubWFwKChpZCkgPT4gdGhpcy5yZWFkRXhhbXBsZShpZCkpKTtcbiAgICAgICAgICAgIHJldHVybiBleGFtcGxlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgbWV0YWRhdGEsIHNwbGl0cywgc291cmNlUnVuSWRzLCB1c2VTb3VyY2VSdW5JT3MsIHVzZVNvdXJjZVJ1bkF0dGFjaG1lbnRzLCBhdHRhY2htZW50cywgZXhhbXBsZUlkcywgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSA9IHByb3BzT3JVcGxvYWRzO1xuICAgICAgICBpZiAoaW5wdXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBpbnB1dHMgd2hlbiB1c2luZyBsZWdhY3kgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgY29uc3QgZGF0YXNldE5hbWVfID0gZGF0YXNldE5hbWU7XG4gICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZTogZGF0YXNldE5hbWVfIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRXhhbXBsZXMgPSBpbnB1dHMubWFwKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGFzZXRfaWQ6IGRhdGFzZXRJZF8sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzPy5baWR4XSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGE/LltpZHhdLFxuICAgICAgICAgICAgICAgIHNwbGl0OiBzcGxpdHM/LltpZHhdLFxuICAgICAgICAgICAgICAgIGlkOiBleGFtcGxlSWRzPy5baWR4XSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogYXR0YWNobWVudHM/LltpZHhdLFxuICAgICAgICAgICAgICAgIHNvdXJjZV9ydW5faWQ6IHNvdXJjZVJ1bklkcz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5faW86IHVzZVNvdXJjZVJ1bklPcz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHM6IHVzZVNvdXJjZVJ1bkF0dGFjaG1lbnRzPy5baWR4XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3VwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZF8sIGZvcm1hdHRlZEV4YW1wbGVzKTtcbiAgICAgICAgY29uc3QgZXhhbXBsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXNwb25zZS5leGFtcGxlX2lkcy5tYXAoKGlkKSA9PiB0aGlzLnJlYWRFeGFtcGxlKGlkKSkpO1xuICAgICAgICByZXR1cm4gZXhhbXBsZXM7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUxMTUV4YW1wbGUoaW5wdXQsIGdlbmVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0IH0sIHsgb3V0cHV0OiBnZW5lcmF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDaGF0RXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxJbnB1dCA9IGlucHV0Lm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzTGFuZ0NoYWluTWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmluYWxPdXRwdXQgPSBpc0xhbmdDaGFpbk1lc3NhZ2UoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA/IGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKGdlbmVyYXRpb25zKVxuICAgICAgICAgICAgOiBnZW5lcmF0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0OiBmaW5hbElucHV0IH0sIHsgb3V0cHV0OiBmaW5hbE91dHB1dCB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEV4YW1wbGUoZXhhbXBsZUlkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZXhhbXBsZUlkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZXhhbXBsZXMvJHtleGFtcGxlSWR9YDtcbiAgICAgICAgY29uc3QgcmF3RXhhbXBsZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICAgICAgY29uc3QgeyBhdHRhY2htZW50X3VybHMsIC4uLnJlc3QgfSA9IHJhd0V4YW1wbGU7XG4gICAgICAgIGNvbnN0IGV4YW1wbGUgPSByZXN0O1xuICAgICAgICBpZiAoYXR0YWNobWVudF91cmxzKSB7XG4gICAgICAgICAgICBleGFtcGxlLmF0dGFjaG1lbnRzID0gT2JqZWN0LmVudHJpZXMoYXR0YWNobWVudF91cmxzKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2tleS5zbGljZShcImF0dGFjaG1lbnQuXCIubGVuZ3RoKV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNpZ25lZF91cmw6IHZhbHVlLnByZXNpZ25lZF91cmwsXG4gICAgICAgICAgICAgICAgICAgIG1pbWVfdHlwZTogdmFsdWUubWltZV90eXBlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhhbXBsZTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RFeGFtcGxlcyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGV4YW1wbGVJZHMsIGFzT2YsIHNwbGl0cywgaW5saW5lUzNVcmxzLCBtZXRhZGF0YSwgbGltaXQsIG9mZnNldCwgZmlsdGVyLCBpbmNsdWRlQXR0YWNobWVudHMsIH0gPSB7fSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXztcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgYSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGRhdGFzZXQ6IGRhdGFzZXRJZF8gfSk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRfdmVyc2lvbiA9IGFzT2ZcbiAgICAgICAgICAgID8gdHlwZW9mIGFzT2YgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGFzT2ZcbiAgICAgICAgICAgICAgICA6IGFzT2Y/LnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGF0YXNldF92ZXJzaW9uKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiYXNfb2ZcIiwgZGF0YXNldF92ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmxpbmVTM1VybHNfID0gaW5saW5lUzNVcmxzID8/IHRydWU7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpbmxpbmVfczNfdXJsc1wiLCBpbmxpbmVTM1VybHNfLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoZXhhbXBsZUlkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkXyBvZiBleGFtcGxlSWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIGlkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNwbGl0IG9mIHNwbGl0cykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJzcGxpdHNcIiwgc3BsaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkTWV0YWRhdGEgPSBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSk7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibWV0YWRhdGFcIiwgc2VyaWFsaXplZE1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImxpbWl0XCIsIGxpbWl0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm9mZnNldFwiLCBvZmZzZXQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiZmlsdGVyXCIsIGZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVBdHRhY2htZW50cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgW1wiYXR0YWNobWVudF91cmxzXCIsIFwib3V0cHV0c1wiLCBcIm1ldGFkYXRhXCJdLmZvckVhY2goKGZpZWxkKSA9PiBwYXJhbXMuYXBwZW5kKFwic2VsZWN0XCIsIGZpZWxkKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHJhd0V4YW1wbGVzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9leGFtcGxlc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJhd0V4YW1wbGUgb2YgcmF3RXhhbXBsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF0dGFjaG1lbnRfdXJscywgLi4ucmVzdCB9ID0gcmF3RXhhbXBsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBleGFtcGxlID0gcmVzdDtcbiAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudF91cmxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4YW1wbGUuYXR0YWNobWVudHMgPSBPYmplY3QuZW50cmllcyhhdHRhY2htZW50X3VybHMpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1trZXkuc2xpY2UoXCJhdHRhY2htZW50LlwiLmxlbmd0aCldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNpZ25lZF91cmw6IHZhbHVlLnByZXNpZ25lZF91cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZV90eXBlOiB2YWx1ZS5taW1lX3R5cGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgZXhhbXBsZTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCAmJiBpID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgYGRlbGV0ZSAke3BhdGh9YCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIG11bHRpcGxlIGV4YW1wbGVzIGJ5IElELlxuICAgICAqIEBwYXJhbSBleGFtcGxlSWRzIC0gVGhlIElEcyBvZiB0aGUgZXhhbXBsZXMgdG8gZGVsZXRlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBzZXR0aW5ncyBmb3IgZGVsZXRpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oYXJkRGVsZXRlIC0gSWYgdHJ1ZSwgcGVybWFuZW50bHkgZGVsZXRlIGV4YW1wbGVzLiBJZiBmYWxzZSAoZGVmYXVsdCksIHNvZnQgZGVsZXRlIHRoZW0uXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlRXhhbXBsZXMoZXhhbXBsZUlkcywgb3B0aW9ucykge1xuICAgICAgICAvLyBWYWxpZGF0ZSBhbGwgVVVJRHNcbiAgICAgICAgZXhhbXBsZUlkcy5mb3JFYWNoKChpZCkgPT4gYXNzZXJ0VXVpZChpZCkpO1xuICAgICAgICBpZiAob3B0aW9ucz8uaGFyZERlbGV0ZSkge1xuICAgICAgICAgICAgLy8gSGFyZCBkZWxldGUgdXNlcyBQT1NUIHRvIGEgZGlmZmVyZW50IHBsYXRmb3JtIGVuZHBvaW50XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5fZ2V0UGxhdGZvcm1FbmRwb2ludFBhdGgoXCJkYXRhc2V0cy9leGFtcGxlcy9kZWxldGVcIik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0ke3BhdGh9YCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhhbXBsZV9pZHM6IGV4YW1wbGVJZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXJkX2RlbGV0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiaGFyZCBkZWxldGUgZXhhbXBsZXNcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU29mdCBkZWxldGUgdXNlcyBERUxFVEUgd2l0aCBxdWVyeSBwYXJhbXNcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIGV4YW1wbGVJZHMuZm9yRWFjaCgoaWQpID0+IHBhcmFtcy5hcHBlbmQoXCJleGFtcGxlX2lkc1wiLCBpZCkpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2V4YW1wbGVzPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJkZWxldGUgZXhhbXBsZXNcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGUoZXhhbXBsZUlkT3JVcGRhdGUsIHVwZGF0ZSkge1xuICAgICAgICBsZXQgZXhhbXBsZUlkO1xuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICBleGFtcGxlSWQgPSBleGFtcGxlSWRPclVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4YW1wbGVJZCA9IGV4YW1wbGVJZE9yVXBkYXRlLmlkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZXhhbXBsZUlkKTtcbiAgICAgICAgbGV0IHVwZGF0ZVRvVXNlO1xuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICB1cGRhdGVUb1VzZSA9IHsgaWQ6IGV4YW1wbGVJZCwgLi4udXBkYXRlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVUb1VzZSA9IGV4YW1wbGVJZE9yVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhc2V0SWQ7XG4gICAgICAgIGlmICh1cGRhdGVUb1VzZS5kYXRhc2V0X2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IHVwZGF0ZVRvVXNlLmRhdGFzZXRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlID0gYXdhaXQgdGhpcy5yZWFkRXhhbXBsZShleGFtcGxlSWQpO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZXhhbXBsZS5kYXRhc2V0X2lkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIFt1cGRhdGVUb1VzZV0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVFeGFtcGxlcyh1cGRhdGUpIHtcbiAgICAgICAgLy8gV2Ugd2lsbCBuYWl2ZWx5IGdldCBkYXRhc2V0IGlkIGZyb20gZmlyc3QgZXhhbXBsZSBhbmQgYXNzdW1lIGl0IHdvcmtzIGZvciBhbGxcbiAgICAgICAgbGV0IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKHVwZGF0ZVswXS5kYXRhc2V0X2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGUgPSBhd2FpdCB0aGlzLnJlYWRFeGFtcGxlKHVwZGF0ZVswXS5pZCk7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSBleGFtcGxlLmRhdGFzZXRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSB1cGRhdGVbMF0uZGF0YXNldF9pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGRhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YXNldCB2ZXJzaW9uIGJ5IGNsb3Nlc3QgZGF0ZSBvciBleGFjdCB0YWcuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyB0byByZXNvbHZlIHRoZSBuZWFyZXN0IHZlcnNpb24gdG8gYSBnaXZlbiB0aW1lc3RhbXAgb3IgZm9yIGEgZ2l2ZW4gdGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIGdldHRpbmcgdGhlIGRhdGFzZXQgdmVyc2lvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGFzZXRJZCBUaGUgSUQgb2YgdGhlIGRhdGFzZXRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhc2V0TmFtZSBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzT2YgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZGF0YXNldCB0byByZXRyaWV2ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRhZyBUaGUgdGFnIG9mIHRoZSBkYXRhc2V0IHRvIHJldHJpZXZlXG4gICAgICogQHJldHVybnMgVGhlIGRhdGFzZXQgdmVyc2lvblxuICAgICAqL1xuICAgIGFzeW5jIHJlYWREYXRhc2V0VmVyc2lvbih7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGFzT2YsIHRhZywgfSkge1xuICAgICAgICBsZXQgcmVzb2x2ZWREYXRhc2V0SWQ7XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgcmVzb2x2ZWREYXRhc2V0SWQgPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZWREYXRhc2V0SWQgPSBkYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChyZXNvbHZlZERhdGFzZXRJZCk7XG4gICAgICAgIGlmICgoYXNPZiAmJiB0YWcpIHx8ICghYXNPZiAmJiAhdGFnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhhY3RseSBvbmUgb2YgYXNPZiBhbmQgdGFnIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChhc09mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJhc19vZlwiLCB0eXBlb2YgYXNPZiA9PT0gXCJzdHJpbmdcIiA/IGFzT2YgOiBhc09mLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInRhZ1wiLCB0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtyZXNvbHZlZERhdGFzZXRJZH0vdmVyc2lvbj8ke3BhcmFtcy50b1N0cmluZygpfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInJlYWQgZGF0YXNldCB2ZXJzaW9uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3REYXRhc2V0U3BsaXRzKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgYXNPZiwgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXztcbiAgICAgICAgaWYgKGRhdGFzZXRJZCA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0IG5hbWUgb3IgSURcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkXyk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgY29uc3QgZGF0YXNldF92ZXJzaW9uID0gYXNPZlxuICAgICAgICAgICAgPyB0eXBlb2YgYXNPZiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gYXNPZlxuICAgICAgICAgICAgICAgIDogYXNPZj8udG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChkYXRhc2V0X3ZlcnNpb24pIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJhc19vZlwiLCBkYXRhc2V0X3ZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KGAvZGF0YXNldHMvJHtkYXRhc2V0SWRffS9zcGxpdHNgLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZURhdGFzZXRTcGxpdHMoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBzcGxpdE5hbWUsIGV4YW1wbGVJZHMsIHJlbW92ZSA9IGZhbHNlLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfO1xuICAgICAgICBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXQgbmFtZSBvciBJRFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHNwbGl0X25hbWU6IHNwbGl0TmFtZSxcbiAgICAgICAgICAgIGV4YW1wbGVzOiBleGFtcGxlSWRzLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRVdWlkKGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJlbW92ZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZF99L3NwbGl0c2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwZGF0ZSBkYXRhc2V0IHNwbGl0c1wiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVGZWVkYmFjayhydW5JZCwga2V5LCB7IHNjb3JlLCB2YWx1ZSwgY29ycmVjdGlvbiwgY29tbWVudCwgc291cmNlSW5mbywgZmVlZGJhY2tTb3VyY2VUeXBlID0gXCJhcGlcIiwgc291cmNlUnVuSWQsIGZlZWRiYWNrSWQsIGZlZWRiYWNrQ29uZmlnLCBwcm9qZWN0SWQsIGNvbXBhcmF0aXZlRXhwZXJpbWVudElkLCB9KSB7XG4gICAgICAgIGlmICghcnVuSWQgJiYgIXByb2plY3RJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25lIG9mIHJ1bklkIG9yIHByb2plY3RJZCBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5JZCAmJiBwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIG9mIHJ1bklkIG9yIHByb2plY3RJZCBjYW4gYmUgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2tfc291cmNlID0ge1xuICAgICAgICAgICAgdHlwZTogZmVlZGJhY2tTb3VyY2VUeXBlID8/IFwiYXBpXCIsXG4gICAgICAgICAgICBtZXRhZGF0YTogc291cmNlSW5mbyA/PyB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNvdXJjZVJ1bklkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGZlZWRiYWNrX3NvdXJjZT8ubWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIWZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdKSB7XG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXSA9IHsgcnVuX2lkOiBzb3VyY2VSdW5JZCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZWVkYmFja19zb3VyY2U/Lm1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdPy5ydW5faWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXS5ydW5faWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrID0ge1xuICAgICAgICAgICAgaWQ6IGZlZWRiYWNrSWQgPz8gdXVpZC52NCgpLFxuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHNjb3JlOiBfZm9ybWF0RmVlZGJhY2tTY29yZShzY29yZSksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNvcnJlY3Rpb24sXG4gICAgICAgICAgICBjb21tZW50LFxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlOiBmZWVkYmFja19zb3VyY2UsXG4gICAgICAgICAgICBjb21wYXJhdGl2ZV9leHBlcmltZW50X2lkOiBjb21wYXJhdGl2ZUV4cGVyaW1lbnRJZCxcbiAgICAgICAgICAgIGZlZWRiYWNrQ29uZmlnLFxuICAgICAgICAgICAgc2Vzc2lvbl9pZDogcHJvamVjdElkLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZmVlZGJhY2spO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2tgO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImNyZWF0ZSBmZWVkYmFja1wiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmVlZGJhY2s7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUZlZWRiYWNrKGZlZWRiYWNrSWQsIHsgc2NvcmUsIHZhbHVlLCBjb3JyZWN0aW9uLCBjb21tZW50LCB9KSB7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrVXBkYXRlID0ge307XG4gICAgICAgIGlmIChzY29yZSAhPT0gdW5kZWZpbmVkICYmIHNjb3JlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcInNjb3JlXCJdID0gX2Zvcm1hdEZlZWRiYWNrU2NvcmUoc2NvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcInZhbHVlXCJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcnJlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBjb3JyZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcImNvcnJlY3Rpb25cIl0gPSBjb3JyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQgJiYgY29tbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJjb21tZW50XCJdID0gY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZmVlZGJhY2tVcGRhdGUpO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1cGRhdGUgZmVlZGJhY2tcIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEZlZWRiYWNrKGZlZWRiYWNrSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja0lkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZmVlZGJhY2svJHtmZWVkYmFja0lkfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KHBhdGgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUZlZWRiYWNrKGZlZWRiYWNrSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja0lkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZmVlZGJhY2svJHtmZWVkYmFja0lkfWA7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2godGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBgZGVsZXRlICR7cGF0aH1gLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdEZlZWRiYWNrKHsgcnVuSWRzLCBmZWVkYmFja0tleXMsIGZlZWRiYWNrU291cmNlVHlwZXMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHJ1bklkcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW5JZCBvZiBydW5JZHMpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJydW5cIiwgcnVuSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmZWVkYmFja0tleXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGZlZWRiYWNrS2V5cykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcImtleVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmZWVkYmFja1NvdXJjZVR5cGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZmVlZGJhY2tTb3VyY2VUeXBlcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcInNvdXJjZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGZlZWRiYWNrcyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvZmVlZGJhY2tcIiwgcXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZmVlZGJhY2tzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwcmVzaWduZWQgZmVlZGJhY2sgdG9rZW4gYW5kIFVSTC5cbiAgICAgKlxuICAgICAqIFRoZSB0b2tlbiBjYW4gYmUgdXNlZCB0byBhdXRob3JpemUgZmVlZGJhY2sgbWV0cmljcyB3aXRob3V0XG4gICAgICogbmVlZGluZyBhbiBBUEkga2V5LiBUaGlzIGlzIHVzZWZ1bCBmb3IgZ2l2aW5nIGJyb3dzZXItYmFzZWRcbiAgICAgKiBhcHBsaWNhdGlvbnMgdGhlIGFiaWxpdHkgdG8gc3VibWl0IGZlZWRiYWNrIHdpdGhvdXQgbmVlZGluZ1xuICAgICAqIHRvIGV4cG9zZSBhbiBBUEkga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJ1bklkIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEBwYXJhbSBmZWVkYmFja0tleSBUaGUgZmVlZGJhY2sga2V5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmV4cGlyYXRpb24gVGhlIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIHRva2VuLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBGZWVkYmFja0luZ2VzdFRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVByZXNpZ25lZEZlZWRiYWNrVG9rZW4ocnVuSWQsIGZlZWRiYWNrS2V5LCB7IGV4cGlyYXRpb24sIGZlZWRiYWNrQ29uZmlnLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBmZWVkYmFja19rZXk6IGZlZWRiYWNrS2V5LFxuICAgICAgICAgICAgZmVlZGJhY2tfY29uZmlnOiBmZWVkYmFja0NvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV4cGlyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwaXJhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2F0XCJdID0gZXhwaXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4cGlyYXRpb24/LmhvdXJzIHx8IGV4cGlyYXRpb24/Lm1pbnV0ZXMgfHwgZXhwaXJhdGlvbj8uZGF5cykge1xuICAgICAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2luXCJdID0gZXhwaXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2luXCJdID0ge1xuICAgICAgICAgICAgICAgIGhvdXJzOiAzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpYWxpemVkQm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrL3Rva2Vuc2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHk6IHNlcmlhbGl6ZWRCb2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiY3JlYXRlIHByZXNpZ25lZCBmZWVkYmFjayB0b2tlblwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDb21wYXJhdGl2ZUV4cGVyaW1lbnQoeyBuYW1lLCBleHBlcmltZW50SWRzLCByZWZlcmVuY2VEYXRhc2V0SWQsIGNyZWF0ZWRBdCwgZGVzY3JpcHRpb24sIG1ldGFkYXRhLCBpZCwgfSkge1xuICAgICAgICBpZiAoZXhwZXJpbWVudElkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBleHBlcmltZW50IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVmZXJlbmNlRGF0YXNldElkKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VEYXRhc2V0SWQgPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7XG4gICAgICAgICAgICAgICAgcHJvamVjdElkOiBleHBlcmltZW50SWRzWzBdLFxuICAgICAgICAgICAgfSkpLnJlZmVyZW5jZV9kYXRhc2V0X2lkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVmZXJlbmNlRGF0YXNldElkID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgcmVmZXJlbmNlIGRhdGFzZXQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRfaWRzOiBleHBlcmltZW50SWRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2RhdGFzZXRfaWQ6IHJlZmVyZW5jZURhdGFzZXRJZCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogKGNyZWF0ZWRBdCA/PyBuZXcgRGF0ZSgpKT8udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGV4dHJhOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKVxuICAgICAgICAgICAgYm9keS5leHRyYVtcIm1ldGFkYXRhXCJdID0gbWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRCb2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvY29tcGFyYXRpdmVgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBzZXJpYWxpemVkQm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImNyZWF0ZSBjb21wYXJhdGl2ZSBleHBlcmltZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgcHJlc2lnbmVkIGZlZWRiYWNrIHRva2VucyBmb3IgYSBnaXZlbiBydW4gSUQuXG4gICAgICogQHBhcmFtIHJ1bklkIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEByZXR1cm5zIEFuIGFzeW5jIGl0ZXJhYmxlIG9mIEZlZWRiYWNrSW5nZXN0VG9rZW4gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBhc3luYyAqbGlzdFByZXNpZ25lZEZlZWRiYWNrVG9rZW5zKHJ1bklkKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgcnVuX2lkOiBydW5JZCB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB0b2tlbnMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2ZlZWRiYWNrL3Rva2Vuc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogdG9rZW5zO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zZWxlY3RFdmFsUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgIGxldCByZXN1bHRzXztcbiAgICAgICAgaWYgKFwicmVzdWx0c1wiIGluIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHJlc3VsdHNfID0gcmVzdWx0cy5yZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICAgIHJlc3VsdHNfID0gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHNfID0gW3Jlc3VsdHNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzXztcbiAgICB9XG4gICAgYXN5bmMgX2xvZ0V2YWx1YXRpb25GZWVkYmFjayhldmFsdWF0b3JSZXNwb25zZSwgcnVuLCBzb3VyY2VJbmZvKSB7XG4gICAgICAgIGNvbnN0IGV2YWxSZXN1bHRzID0gdGhpcy5fc2VsZWN0RXZhbFJlc3VsdHMoZXZhbHVhdG9yUmVzcG9uc2UpO1xuICAgICAgICBjb25zdCBmZWVkYmFja3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByZXMgb2YgZXZhbFJlc3VsdHMpIHtcbiAgICAgICAgICAgIGxldCBzb3VyY2VJbmZvXyA9IHNvdXJjZUluZm8gfHwge307XG4gICAgICAgICAgICBpZiAocmVzLmV2YWx1YXRvckluZm8pIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VJbmZvXyA9IHsgLi4ucmVzLmV2YWx1YXRvckluZm8sIC4uLnNvdXJjZUluZm9fIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcnVuSWRfID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXMudGFyZ2V0UnVuSWQpIHtcbiAgICAgICAgICAgICAgICBydW5JZF8gPSByZXMudGFyZ2V0UnVuSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChydW4pIHtcbiAgICAgICAgICAgICAgICBydW5JZF8gPSBydW4uaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmZWVkYmFja3MucHVzaChhd2FpdCB0aGlzLmNyZWF0ZUZlZWRiYWNrKHJ1bklkXywgcmVzLmtleSwge1xuICAgICAgICAgICAgICAgIHNjb3JlOiByZXMuc2NvcmUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlcy52YWx1ZSxcbiAgICAgICAgICAgICAgICBjb21tZW50OiByZXMuY29tbWVudCxcbiAgICAgICAgICAgICAgICBjb3JyZWN0aW9uOiByZXMuY29ycmVjdGlvbixcbiAgICAgICAgICAgICAgICBzb3VyY2VJbmZvOiBzb3VyY2VJbmZvXyxcbiAgICAgICAgICAgICAgICBzb3VyY2VSdW5JZDogcmVzLnNvdXJjZVJ1bklkLFxuICAgICAgICAgICAgICAgIGZlZWRiYWNrQ29uZmlnOiByZXMuZmVlZGJhY2tDb25maWcsXG4gICAgICAgICAgICAgICAgZmVlZGJhY2tTb3VyY2VUeXBlOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtldmFsUmVzdWx0cywgZmVlZGJhY2tzXTtcbiAgICB9XG4gICAgYXN5bmMgbG9nRXZhbHVhdGlvbkZlZWRiYWNrKGV2YWx1YXRvclJlc3BvbnNlLCBydW4sIHNvdXJjZUluZm8pIHtcbiAgICAgICAgY29uc3QgW3Jlc3VsdHNdID0gYXdhaXQgdGhpcy5fbG9nRXZhbHVhdGlvbkZlZWRiYWNrKGV2YWx1YXRvclJlc3BvbnNlLCBydW4sIHNvdXJjZUluZm8pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQVBJIGZvciBtYW5hZ2luZyBhbm5vdGF0aW9uIHF1ZXVlc1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIExpc3QgdGhlIGFubm90YXRpb24gcXVldWVzIG9uIHRoZSBMYW5nU21pdGggQVBJLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGxpc3RpbmcgYW5ub3RhdGlvbiBxdWV1ZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5xdWV1ZUlkcyAtIFRoZSBJRHMgb2YgdGhlIHF1ZXVlcyB0byBmaWx0ZXIgYnlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHF1ZXVlIHRvIGZpbHRlciBieVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWVDb250YWlucyAtIFRoZSBzdWJzdHJpbmcgdGhhdCB0aGUgcXVldWUgbmFtZSBzaG91bGQgY29udGFpblxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHF1ZXVlcyB0byByZXR1cm5cbiAgICAgKiBAcmV0dXJucyBBbiBpdGVyYXRvciBvZiBBbm5vdGF0aW9uUXVldWUgb2JqZWN0c1xuICAgICAqL1xuICAgIGFzeW5jICpsaXN0QW5ub3RhdGlvblF1ZXVlcyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBxdWV1ZUlkcywgbmFtZSwgbmFtZUNvbnRhaW5zLCBsaW1pdCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocXVldWVJZHMpIHtcbiAgICAgICAgICAgIHF1ZXVlSWRzLmZvckVhY2goKGlkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VXVpZChpZCwgYHF1ZXVlSWRzWyR7aX1dYCk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkc1wiLCBpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICBpZiAobmFtZUNvbnRhaW5zKVxuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVfY29udGFpbnNcIiwgbmFtZUNvbnRhaW5zKTtcbiAgICAgICAgcGFyYW1zLmFwcGVuZChcImxpbWl0XCIsIChsaW1pdCAhPT0gdW5kZWZpbmVkID8gTWF0aC5taW4obGltaXQsIDEwMCkgOiAxMDApLnRvU3RyaW5nKCkpO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHF1ZXVlcyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvYW5ub3RhdGlvbi1xdWV1ZXNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHF1ZXVlcztcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCAmJiBjb3VudCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gYW5ub3RhdGlvbiBxdWV1ZSBvbiB0aGUgTGFuZ1NtaXRoIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyBhbiBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVzY3JpcHRpb24gLSBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5xdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgQW5ub3RhdGlvblF1ZXVlIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUFubm90YXRpb25RdWV1ZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZGVzY3JpcHRpb24sIHF1ZXVlSWQsIHJ1YnJpY0luc3RydWN0aW9ucyB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGlkOiBxdWV1ZUlkIHx8IHV1aWQudjQoKSxcbiAgICAgICAgICAgIHJ1YnJpY19pbnN0cnVjdGlvbnM6IHJ1YnJpY0luc3RydWN0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEJvZHkgPSBKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYm9keSkuZmlsdGVyKChbXywgdl0pID0+IHYgIT09IHVuZGVmaW5lZCkpKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlc2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHk6IHNlcmlhbGl6ZWRCb2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiY3JlYXRlIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhbiBhbm5vdGF0aW9uIHF1ZXVlIHdpdGggdGhlIHNwZWNpZmllZCBxdWV1ZSBJRC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZSB0byByZWFkXG4gICAgICogQHJldHVybnMgVGhlIEFubm90YXRpb25RdWV1ZVdpdGhEZXRhaWxzIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRBbm5vdGF0aW9uUXVldWUocXVldWVJZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJyZWFkIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHVwZGF0aW5nIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuZXcgbmFtZSBmb3IgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZXNjcmlwdGlvbiAtIFRoZSBuZXcgZGVzY3JpcHRpb24gZm9yIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBkZXNjcmlwdGlvbiwgcnVicmljSW5zdHJ1Y3Rpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgcnVicmljX2luc3RydWN0aW9uczogcnVicmljSW5zdHJ1Y3Rpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwZGF0ZSBhbm5vdGF0aW9uIHF1ZXVlXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbiBhbm5vdGF0aW9uIHF1ZXVlIHdpdGggdGhlIHNwZWNpZmllZCBxdWV1ZSBJRC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZSB0byBkZWxldGVcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVBbm5vdGF0aW9uUXVldWUocXVldWVJZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImRlbGV0ZSBhbm5vdGF0aW9uIHF1ZXVlXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBydW5zIHRvIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIHJ1bklkcyAtIFRoZSBJRHMgb2YgdGhlIHJ1bnMgdG8gYmUgYWRkZWQgdG8gdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKi9cbiAgICBhc3luYyBhZGRSdW5zVG9Bbm5vdGF0aW9uUXVldWUocXVldWVJZCwgcnVuSWRzKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShydW5JZHMubWFwKChpZCwgaSkgPT4gYXNzZXJ0VXVpZChpZCwgYHJ1bklkc1ske2l9XWApLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX0vcnVuc2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJhZGQgcnVucyB0byBhbm5vdGF0aW9uIHF1ZXVlXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHJ1biBmcm9tIGFuIGFubm90YXRpb24gcXVldWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgcnVuIHRvIHJldHJpZXZlXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBSdW5XaXRoQW5ub3RhdGlvblF1ZXVlSW5mbyBvYmplY3RcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHJ1biBpcyBub3QgZm91bmQgYXQgdGhlIGdpdmVuIGluZGV4IG9yIGZvciBvdGhlciBBUEktcmVsYXRlZCBlcnJvcnNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRSdW5Gcm9tQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBgL2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9L3J1bmA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0ke2Jhc2VVcmx9LyR7aW5kZXh9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJnZXQgcnVuIGZyb20gYW5ub3RhdGlvbiBxdWV1ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBydW4gZnJvbSBhbiBhbiBhbm5vdGF0aW9uIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIGRlbGV0ZSB0aGUgcnVuIGZyb21cbiAgICAgKiBAcGFyYW0gcXVldWVSdW5JZCAtIFRoZSBJRCBvZiB0aGUgcnVuIHRvIGRlbGV0ZSBmcm9tIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlUnVuRnJvbUFubm90YXRpb25RdWV1ZShxdWV1ZUlkLCBxdWV1ZVJ1bklkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9L3J1bnMvJHthc3NlcnRVdWlkKHF1ZXVlUnVuSWQsIFwicXVldWVSdW5JZFwiKX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJkZWxldGUgcnVuIGZyb20gYW5ub3RhdGlvbiBxdWV1ZVwiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNpemUgb2YgYW4gYW5ub3RhdGlvbiBxdWV1ZS5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldFNpemVGcm9tQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfS9zaXplYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJnZXQgc2l6ZSBmcm9tIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgdGhpcy5fZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgcmV0dXJuIG93bmVyID09IFwiLVwiIHx8IHNldHRpbmdzLnRlbmFudF9oYW5kbGUgPT09IG93bmVyO1xuICAgIH1cbiAgICBhc3luYyBfb3duZXJDb25mbGljdEVycm9yKGFjdGlvbiwgb3duZXIpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLl9nZXRTZXR0aW5ncygpO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBDYW5ub3QgJHthY3Rpb259IGZvciBhbm90aGVyIHRlbmFudC5cXG5cbiAgICAgIEN1cnJlbnQgdGVuYW50OiAke3NldHRpbmdzLnRlbmFudF9oYW5kbGV9XFxuXG4gICAgICBSZXF1ZXN0ZWQgdGVuYW50OiAke293bmVyfWApO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0TGF0ZXN0Q29tbWl0SGFzaChwcm9tcHRPd25lckFuZE5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9jb21taXRzLyR7cHJvbXB0T3duZXJBbmROYW1lfS8/bGltaXQ9JHsxfSZvZmZzZXQ9JHswfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiZ2V0IGxhdGVzdCBjb21taXQgaGFzaFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoanNvbi5jb21taXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbi5jb21taXRzWzBdLmNvbW1pdF9oYXNoO1xuICAgIH1cbiAgICBhc3luYyBfbGlrZU9yVW5saWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIGxpa2UpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHsgbGlrZTogbGlrZSB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9saWtlcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBgJHtsaWtlID8gXCJsaWtlXCIgOiBcInVubGlrZVwifSBwcm9tcHRgKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0UHJvbXB0VXJsKHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBjb21taXRIYXNoXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgaWYgKGNvbW1pdEhhc2ggIT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L2h1Yi8ke293bmVyfS8ke3Byb21wdE5hbWV9LyR7Y29tbWl0SGFzaC5zdWJzdHJpbmcoMCwgOCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vaHViLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLl9nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgaWYgKGNvbW1pdEhhc2ggIT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3Byb21wdHMvJHtwcm9tcHROYW1lfS8ke2NvbW1pdEhhc2guc3Vic3RyaW5nKDAsIDgpfT9vcmdhbml6YXRpb25JZD0ke3NldHRpbmdzLmlkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3Byb21wdHMvJHtwcm9tcHROYW1lfT9vcmdhbml6YXRpb25JZD0ke3NldHRpbmdzLmlkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gYXdhaXQgdGhpcy5nZXRQcm9tcHQocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiAhIXByb21wdDtcbiAgICB9XG4gICAgYXN5bmMgbGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saWtlT3JVbmxpa2VQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saWtlT3JVbmxpa2VQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgZmFsc2UpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdENvbW1pdHMocHJvbXB0T3duZXJBbmROYW1lKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY29tbWl0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoYC9jb21taXRzLyR7cHJvbXB0T3duZXJBbmROYW1lfS9gLCBuZXcgVVJMU2VhcmNoUGFyYW1zKCksIChyZXMpID0+IHJlcy5jb21taXRzKSkge1xuICAgICAgICAgICAgeWllbGQqIGNvbW1pdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgKmxpc3RQcm9tcHRzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwic29ydF9maWVsZFwiLCBvcHRpb25zPy5zb3J0RmllbGQgPz8gXCJ1cGRhdGVkX2F0XCIpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwic29ydF9kaXJlY3Rpb25cIiwgXCJkZXNjXCIpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaXNfYXJjaGl2ZWRcIiwgKCEhb3B0aW9ucz8uaXNBcmNoaXZlZCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChvcHRpb25zPy5pc1B1YmxpYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaXNfcHVibGljXCIsIG9wdGlvbnMuaXNQdWJsaWMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnM/LnF1ZXJ5KSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicXVlcnlcIiwgb3B0aW9ucy5xdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9tcHRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9yZXBvc1wiLCBwYXJhbXMsIChyZXMpID0+IHJlcy5yZXBvcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBwcm9tcHRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vcmVwb3MvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzPy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImdldCBwcm9tcHRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2U/Lmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdD8ucmVwbykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXBvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLl9nZXRTZXR0aW5ncygpO1xuICAgICAgICBpZiAob3B0aW9ucz8uaXNQdWJsaWMgJiYgIXNldHRpbmdzLnRlbmFudF9oYW5kbGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNyZWF0ZSBhIHB1YmxpYyBwcm9tcHQgd2l0aG91dCBmaXJzdFxcblxuICAgICAgICBjcmVhdGluZyBhIExhbmdDaGFpbiBIdWIgaGFuZGxlLlxuICAgICAgICBZb3UgY2FuIGFkZCBhIGhhbmRsZSBieSBjcmVhdGluZyBhIHB1YmxpYyBwcm9tcHQgYXQ6XFxuXG4gICAgICAgIGh0dHBzOi8vc21pdGgubGFuZ2NoYWluLmNvbS9wcm9tcHRzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5fb3duZXJDb25mbGljdEVycm9yKFwiY3JlYXRlIGEgcHJvbXB0XCIsIG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcmVwb19oYW5kbGU6IHByb21wdE5hbWUsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucz8uZGVzY3JpcHRpb24gJiYgeyBkZXNjcmlwdGlvbjogb3B0aW9ucy5kZXNjcmlwdGlvbiB9KSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5yZWFkbWUgJiYgeyByZWFkbWU6IG9wdGlvbnMucmVhZG1lIH0pLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LnRhZ3MgJiYgeyB0YWdzOiBvcHRpb25zLnRhZ3MgfSksXG4gICAgICAgICAgICBpc19wdWJsaWM6ICEhb3B0aW9ucz8uaXNQdWJsaWMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9yZXBvcy9gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiY3JlYXRlIHByb21wdFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHJlcG8gfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlcG87XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNvbW1pdChwcm9tcHRJZGVudGlmaWVyLCBvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9tcHQgZG9lcyBub3QgZXhpc3QsIHlvdSBtdXN0IGNyZWF0ZSBpdCBmaXJzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXJlbnRDb21taXRIYXNoID0gb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaCA9PT0gXCJsYXRlc3RcIiB8fCAhb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaFxuICAgICAgICAgICAgPyBhd2FpdCB0aGlzLl9nZXRMYXRlc3RDb21taXRIYXNoKGAke293bmVyfS8ke3Byb21wdE5hbWV9YClcbiAgICAgICAgICAgIDogb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaDtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG1hbmlmZXN0OiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iamVjdCkpLFxuICAgICAgICAgICAgcGFyZW50X2NvbW1pdDogcmVzb2x2ZWRQYXJlbnRDb21taXRIYXNoLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vY29tbWl0cy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImNyZWF0ZSBjb21taXRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvbXB0VXJsKGAke293bmVyfS8ke3Byb21wdE5hbWV9JHtyZXN1bHQuY29tbWl0X2hhc2ggPyBgOiR7cmVzdWx0LmNvbW1pdF9oYXNofWAgOiBcIlwifWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZXhhbXBsZXMgd2l0aCBhdHRhY2htZW50cyB1c2luZyBtdWx0aXBhcnQgZm9ybSBkYXRhLlxuICAgICAqIEBwYXJhbSB1cGRhdGVzIExpc3Qgb2YgRXhhbXBsZVVwZGF0ZVdpdGhBdHRhY2htZW50cyBvYmplY3RzIHRvIHVwc2VydFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0aGUgdXBkYXRlIHJlc3BvbnNlXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGRhdGVzID0gW10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBkYXRlcyk7XG4gICAgfVxuICAgIGFzeW5jIF91cGRhdGVFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwZGF0ZXMgPSBbXSkge1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9nZXREYXRhc2V0RXhhbXBsZXNNdWx0aVBhcnRTdXBwb3J0KCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIExhbmdTbWl0aCBkZXBsb3ltZW50IGRvZXMgbm90IGFsbG93IHVzaW5nIHRoZSBtdWx0aXBhcnQgZXhhbXBsZXMgZW5kcG9pbnQsIHBsZWFzZSB1cGdyYWRlIHlvdXIgZGVwbG95bWVudCB0byB0aGUgbGF0ZXN0IHZlcnNpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZvciAoY29uc3QgZXhhbXBsZSBvZiB1cGRhdGVzKSB7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlSWQgPSBleGFtcGxlLmlkO1xuICAgICAgICAgICAgLy8gUHJlcGFyZSB0aGUgbWFpbiBleGFtcGxlIGJvZHlcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVCb2R5ID0ge1xuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLm1ldGFkYXRhICYmIHsgbWV0YWRhdGE6IGV4YW1wbGUubWV0YWRhdGEgfSksXG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUuc3BsaXQgJiYgeyBzcGxpdDogZXhhbXBsZS5zcGxpdCB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBBZGQgbWFpbiBleGFtcGxlIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkRXhhbXBsZSA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGVCb2R5LCBgU2VyaWFsaXppbmcgYm9keSBmb3IgZXhhbXBsZSB3aXRoIGlkOiAke2V4YW1wbGVJZH1gKTtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVCbG9iID0gbmV3IEJsb2IoW3N0cmluZ2lmaWVkRXhhbXBsZV0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGV4YW1wbGVJZCwgZXhhbXBsZUJsb2IpO1xuICAgICAgICAgICAgLy8gQWRkIGlucHV0cyBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoZXhhbXBsZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZElucHV0cyA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGUuaW5wdXRzLCBgU2VyaWFsaXppbmcgaW5wdXRzIGZvciBleGFtcGxlIHdpdGggaWQ6ICR7ZXhhbXBsZUlkfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0c0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRJbnB1dHNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmlucHV0c2AsIGlucHV0c0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIG91dHB1dHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkT3V0cHV0cyA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGUub3V0cHV0cywgYFNlcmlhbGl6aW5nIG91dHB1dHMgd2hsZSB1cGRhdGluZyBleGFtcGxlIHdpdGggaWQ6ICR7ZXhhbXBsZUlkfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHNCbG9iID0gbmV3IEJsb2IoW3N0cmluZ2lmaWVkT3V0cHV0c10sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0ub3V0cHV0c2AsIG91dHB1dHNCbG9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBhdHRhY2htZW50cyBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoZXhhbXBsZS5hdHRhY2htZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGF0dGFjaG1lbnRdIG9mIE9iamVjdC5lbnRyaWVzKGV4YW1wbGUuYXR0YWNobWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW1lVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dGFjaG1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbbWltZVR5cGUsIGRhdGFdID0gYXR0YWNobWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlID0gYXR0YWNobWVudC5taW1lVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhdHRhY2htZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0YWNobWVudEJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGAke21pbWVUeXBlfTsgbGVuZ3RoPSR7ZGF0YS5ieXRlTGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7ZXhhbXBsZUlkfS5hdHRhY2htZW50LiR7bmFtZX1gLCBhdHRhY2htZW50QmxvYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4YW1wbGUuYXR0YWNobWVudHNfb3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkQXR0YWNobWVudHNPcGVyYXRpb25zID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZS5hdHRhY2htZW50c19vcGVyYXRpb25zLCBgU2VyaWFsaXppbmcgYXR0YWNobWVudHMgd2hpbGUgdXBkYXRpbmcgZXhhbXBsZSB3aXRoIGlkOiAke2V4YW1wbGVJZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2htZW50c09wZXJhdGlvbnNCbG9iID0gbmV3IEJsb2IoW3N0cmluZ2lmaWVkQXR0YWNobWVudHNPcGVyYXRpb25zXSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7ZXhhbXBsZUlkfS5hdHRhY2htZW50c19vcGVyYXRpb25zYCwgYXR0YWNobWVudHNPcGVyYXRpb25zQmxvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YXNldElkVG9Vc2UgPSBkYXRhc2V0SWQgPz8gdXBkYXRlc1swXT8uZGF0YXNldF9pZDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfSR7dGhpcy5fZ2V0UGxhdGZvcm1FbmRwb2ludFBhdGgoYGRhdGFzZXRzLyR7ZGF0YXNldElkVG9Vc2V9L2V4YW1wbGVzYCl9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwZGF0ZSBleGFtcGxlc1wiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgZXhhbXBsZXMgd2l0aCBhdHRhY2htZW50cyB1c2luZyBtdWx0aXBhcnQgZm9ybSBkYXRhLlxuICAgICAqIEBwYXJhbSB1cGxvYWRzIExpc3Qgb2YgRXhhbXBsZVVwbG9hZFdpdGhBdHRhY2htZW50cyBvYmplY3RzIHRvIHVwbG9hZFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0aGUgdXBsb2FkIHJlc3BvbnNlXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSBMYW5nU21pdGggdmVyc2lvbnMsIHBsZWFzZSB1c2UgYGNyZWF0ZUV4YW1wbGVzYCBpbnN0ZWFkXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGxvYWRzID0gW10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBsb2Fkcyk7XG4gICAgfVxuICAgIGFzeW5jIF91cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwbG9hZHMgPSBbXSkge1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9nZXREYXRhc2V0RXhhbXBsZXNNdWx0aVBhcnRTdXBwb3J0KCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIExhbmdTbWl0aCBkZXBsb3ltZW50IGRvZXMgbm90IGFsbG93IHVzaW5nIHRoZSBtdWx0aXBhcnQgZXhhbXBsZXMgZW5kcG9pbnQsIHBsZWFzZSB1cGdyYWRlIHlvdXIgZGVwbG95bWVudCB0byB0aGUgbGF0ZXN0IHZlcnNpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZvciAoY29uc3QgZXhhbXBsZSBvZiB1cGxvYWRzKSB7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlSWQgPSAoZXhhbXBsZS5pZCA/PyB1dWlkLnY0KCkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSBtYWluIGV4YW1wbGUgYm9keVxuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUJvZHkgPSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogZXhhbXBsZS5jcmVhdGVkX2F0LFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLm1ldGFkYXRhICYmIHsgbWV0YWRhdGE6IGV4YW1wbGUubWV0YWRhdGEgfSksXG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUuc3BsaXQgJiYgeyBzcGxpdDogZXhhbXBsZS5zcGxpdCB9KSxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS5zb3VyY2VfcnVuX2lkICYmIHsgc291cmNlX3J1bl9pZDogZXhhbXBsZS5zb3VyY2VfcnVuX2lkIH0pLFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLnVzZV9zb3VyY2VfcnVuX2lvICYmIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5faW86IGV4YW1wbGUudXNlX3NvdXJjZV9ydW5faW8sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUudXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHMgJiYge1xuICAgICAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9hdHRhY2htZW50czogZXhhbXBsZS51c2Vfc291cmNlX3J1bl9hdHRhY2htZW50cyxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBBZGQgbWFpbiBleGFtcGxlIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkRXhhbXBsZSA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGVCb2R5LCBgU2VyaWFsaXppbmcgYm9keSBmb3IgdXBsb2FkZWQgZXhhbXBsZSB3aXRoIGlkOiAke2V4YW1wbGVJZH1gKTtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVCbG9iID0gbmV3IEJsb2IoW3N0cmluZ2lmaWVkRXhhbXBsZV0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGV4YW1wbGVJZCwgZXhhbXBsZUJsb2IpO1xuICAgICAgICAgICAgLy8gQWRkIGlucHV0cyBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoZXhhbXBsZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZElucHV0cyA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGUuaW5wdXRzLCBgU2VyaWFsaXppbmcgaW5wdXRzIGZvciB1cGxvYWRlZCBleGFtcGxlIHdpdGggaWQ6ICR7ZXhhbXBsZUlkfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0c0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRJbnB1dHNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmlucHV0c2AsIGlucHV0c0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIG91dHB1dHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkT3V0cHV0cyA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGUub3V0cHV0cywgYFNlcmlhbGl6aW5nIG91dHB1dHMgZm9yIHVwbG9hZGVkIGV4YW1wbGUgd2l0aCBpZDogJHtleGFtcGxlSWR9YCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0c0Jsb2IgPSBuZXcgQmxvYihbc3RyaW5naWZpZWRPdXRwdXRzXSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7ZXhhbXBsZUlkfS5vdXRwdXRzYCwgb3V0cHV0c0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGF0dGFjaG1lbnRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgYXR0YWNobWVudF0gb2YgT2JqZWN0LmVudHJpZXMoZXhhbXBsZS5hdHRhY2htZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0YWNobWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFttaW1lVHlwZSwgZGF0YV0gPSBhdHRhY2htZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUgPSBhdHRhY2htZW50Lm1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF0dGFjaG1lbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2htZW50QmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYCR7bWltZVR5cGV9OyBsZW5ndGg9JHtkYXRhLmJ5dGVMZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9LmF0dGFjaG1lbnQuJHtuYW1lfWAsIGF0dGFjaG1lbnRCbG9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfSR7dGhpcy5fZ2V0UGxhdGZvcm1FbmRwb2ludFBhdGgoYGRhdGFzZXRzLyR7ZGF0YXNldElkfS9leGFtcGxlc2ApfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwbG9hZCBleGFtcGxlc1wiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLnByb21wdEV4aXN0cyhwcm9tcHRJZGVudGlmaWVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb21wdCBkb2VzIG5vdCBleGlzdCwgeW91IG11c3QgY3JlYXRlIGl0IGZpcnN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWVdID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9jdXJyZW50VGVuYW50SXNPd25lcihvd25lcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBhd2FpdCB0aGlzLl9vd25lckNvbmZsaWN0RXJyb3IoXCJ1cGRhdGUgYSBwcm9tcHRcIiwgb3duZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwYXlsb2FkLmRlc2NyaXB0aW9uID0gb3B0aW9ucy5kZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKG9wdGlvbnM/LnJlYWRtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5yZWFkbWUgPSBvcHRpb25zLnJlYWRtZTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LnRhZ3MgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQudGFncyA9IG9wdGlvbnMudGFncztcbiAgICAgICAgaWYgKG9wdGlvbnM/LmlzUHVibGljICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwYXlsb2FkLmlzX3B1YmxpYyA9IG9wdGlvbnMuaXNQdWJsaWM7XG4gICAgICAgIGlmIChvcHRpb25zPy5pc0FyY2hpdmVkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwYXlsb2FkLmlzX2FyY2hpdmVkID0gb3B0aW9ucy5pc0FyY2hpdmVkO1xuICAgICAgICAvLyBDaGVjayBpZiBwYXlsb2FkIGlzIGVtcHR5XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhwYXlsb2FkKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbGlkIHVwZGF0ZSBvcHRpb25zIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9yZXBvcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1cGRhdGUgcHJvbXB0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbXB0IGRvZXMgbm90IGV4aXN0LCB5b3UgbXVzdCBjcmVhdGUgaXQgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuX293bmVyQ29uZmxpY3RFcnJvcihcImRlbGV0ZSBhIHByb21wdFwiLCBvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9yZXBvcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJkZWxldGUgcHJvbXB0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgY2FjaGUga2V5IGZvciBhIHByb21wdC5cbiAgICAgKiBGb3JtYXQ6IFwie2lkZW50aWZpZXJ9XCIgb3IgXCJ7aWRlbnRpZmllcn06d2l0aF9tb2RlbFwiXG4gICAgICovXG4gICAgX2dldFByb21wdENhY2hlS2V5KHByb21wdElkZW50aWZpZXIsIGluY2x1ZGVNb2RlbCkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSBpbmNsdWRlTW9kZWwgPyBcIjp3aXRoX21vZGVsXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYCR7cHJvbXB0SWRlbnRpZmllcn0ke3N1ZmZpeH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIHByb21wdCBjb21taXQgZGlyZWN0bHkgZnJvbSB0aGUgQVBJIChieXBhc3NpbmcgY2FjaGUpLlxuICAgICAqL1xuICAgIGFzeW5jIF9mZXRjaFByb21wdEZyb21BcGkocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIGNvbW1pdEhhc2hdID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2NvbW1pdHMvJHtvd25lcn0vJHtwcm9tcHROYW1lfS8ke2NvbW1pdEhhc2h9JHtvcHRpb25zPy5pbmNsdWRlTW9kZWwgPyBcIj9pbmNsdWRlX21vZGVsPXRydWVcIiA6IFwiXCJ9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJwdWxsIHByb21wdCBjb21taXRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICByZXBvOiBwcm9tcHROYW1lLFxuICAgICAgICAgICAgY29tbWl0X2hhc2g6IHJlc3VsdC5jb21taXRfaGFzaCxcbiAgICAgICAgICAgIG1hbmlmZXN0OiByZXN1bHQubWFuaWZlc3QsXG4gICAgICAgICAgICBleGFtcGxlczogcmVzdWx0LmV4YW1wbGVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBwdWxsUHJvbXB0Q29tbWl0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3QgaWYgbm90IHNraXBwZWRcbiAgICAgICAgaWYgKCFvcHRpb25zPy5za2lwQ2FjaGUgJiYgdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5fZ2V0UHJvbXB0Q2FjaGVLZXkocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucz8uaW5jbHVkZU1vZGVsKTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhY2hlIG1pc3MgLSBmZXRjaCBmcm9tIEFQSSBhbmQgY2FjaGUgaXRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2ZldGNoUHJvbXB0RnJvbUFwaShwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLnNldChjYWNoZUtleSwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gY2FjaGUgb3Igc2tpcCBjYWNoZSAtIGZldGNoIGRpcmVjdGx5XG4gICAgICAgIHJldHVybiB0aGlzLl9mZXRjaFByb21wdEZyb21BcGkocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgdXNlIGBpbXBvcnQgeyBwdWxsIH0gZnJvbSBcImxhbmdjaGFpbi9odWJcImAgaW5zdGVhZC5cbiAgICAgKiBVc2luZyB0aGlzIG1ldGhvZCBkaXJlY3RseSByZXR1cm5zIHRoZSBKU09OIHN0cmluZyBvZiB0aGUgcHJvbXB0IHJhdGhlciB0aGFuIGEgTGFuZ0NoYWluIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF9wdWxsUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0T2JqZWN0ID0gYXdhaXQgdGhpcy5wdWxsUHJvbXB0Q29tbWl0KHByb21wdElkZW50aWZpZXIsIHtcbiAgICAgICAgICAgIGluY2x1ZGVNb2RlbDogb3B0aW9ucz8uaW5jbHVkZU1vZGVsLFxuICAgICAgICAgICAgc2tpcENhY2hlOiBvcHRpb25zPy5za2lwQ2FjaGUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm9tcHQgPSBKU09OLnN0cmluZ2lmeShwcm9tcHRPYmplY3QubWFuaWZlc3QpO1xuICAgICAgICByZXR1cm4gcHJvbXB0O1xuICAgIH1cbiAgICBhc3luYyBwdXNoUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG9yIHVwZGF0ZSBwcm9tcHQgbWV0YWRhdGFcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBPYmplY3Qua2V5cyhvcHRpb25zKS5zb21lKChrZXkpID0+IGtleSAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zPy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmVhZG1lOiBvcHRpb25zPy5yZWFkbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IG9wdGlvbnM/LnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIGlzUHVibGljOiBvcHRpb25zPy5pc1B1YmxpYyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogb3B0aW9ucz8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgcmVhZG1lOiBvcHRpb25zPy5yZWFkbWUsXG4gICAgICAgICAgICAgICAgdGFnczogb3B0aW9ucz8udGFncyxcbiAgICAgICAgICAgICAgICBpc1B1YmxpYzogb3B0aW9ucz8uaXNQdWJsaWMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnM/Lm9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFByb21wdFVybChwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBjb21taXQgd2l0aCB0aGUgbmV3IG1hbmlmZXN0XG4gICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuY3JlYXRlQ29tbWl0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnM/Lm9iamVjdCwge1xuICAgICAgICAgICAgcGFyZW50Q29tbWl0SGFzaDogb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lIGEgcHVibGljIGRhdGFzZXQgdG8geW91ciBvd24gbGFuZ3NtaXRoIHRlbmFudC5cbiAgICAgKiBUaGlzIG9wZXJhdGlvbiBpcyBpZGVtcG90ZW50LiBJZiB5b3UgYWxyZWFkeSBoYXZlIGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gd2lsbCBkbyBub3RoaW5nLlxuICBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5PclVybCBUaGUgdG9rZW4gb2YgdGhlIHB1YmxpYyBkYXRhc2V0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIGZvciBjbG9uaW5nIHRoZSBkYXRhc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VBcGlVcmxdIFRoZSBVUkwgb2YgdGhlIGxhbmdzbWl0aCBzZXJ2ZXIgd2hlcmUgdGhlIGRhdGEgaXMgaG9zdGVkLiBEZWZhdWx0cyB0byB0aGUgQVBJIFVSTCBvZiB5b3VyIGN1cnJlbnQgY2xpZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kYXRhc2V0TmFtZV0gVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gY3JlYXRlIGluIHlvdXIgdGVuYW50LiBEZWZhdWx0cyB0byB0aGUgbmFtZSBvZiB0aGUgcHVibGljIGRhdGFzZXQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgY2xvbmVQdWJsaWNEYXRhc2V0KHRva2VuT3JVcmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHNvdXJjZUFwaVVybCA9IHRoaXMuYXBpVXJsLCBkYXRhc2V0TmFtZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgW3BhcnNlZEFwaVVybCwgdG9rZW5VdWlkXSA9IHRoaXMucGFyc2VUb2tlbk9yVXJsKHRva2VuT3JVcmwsIHNvdXJjZUFwaVVybCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUNsaWVudCA9IG5ldyBDbGllbnQoe1xuICAgICAgICAgICAgYXBpVXJsOiBwYXJzZWRBcGlVcmwsXG4gICAgICAgICAgICAvLyBQbGFjZWhvbGRlciBBUEkga2V5IG5vdCBuZWVkZWQgYW55bW9yZSBpbiBtb3N0IGNhc2VzLCBidXRcbiAgICAgICAgICAgIC8vIHNvbWUgcHJpdmF0ZSBkZXBsb3ltZW50cyBtYXkgaGF2ZSBBUEkga2V5LWJhc2VkIHJhdGUgbGltaXRpbmdcbiAgICAgICAgICAgIC8vIHRoYXQgd291bGQgY2F1c2UgdGhpcyB0byBmYWlsIGlmIHdlIHByb3ZpZGUgbm8gdmFsdWUuXG4gICAgICAgICAgICBhcGlLZXk6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRzID0gYXdhaXQgc291cmNlQ2xpZW50LnJlYWRTaGFyZWREYXRhc2V0KHRva2VuVXVpZCk7XG4gICAgICAgIGNvbnN0IGZpbmFsRGF0YXNldE5hbWUgPSBkYXRhc2V0TmFtZSB8fCBkcy5uYW1lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGF3YWl0IHRoaXMuaGFzRGF0YXNldCh7IGRhdGFzZXRJZDogZmluYWxEYXRhc2V0TmFtZSB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBEYXRhc2V0ICR7ZmluYWxEYXRhc2V0TmFtZX0gYWxyZWFkeSBleGlzdHMgaW4geW91ciB0ZW5hbnQuIFNraXBwaW5nLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gYC5oYXNEYXRhc2V0YCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBkYXRhc2V0IGRvZXMgbm90IGV4aXN0LlxuICAgICAgICAgICAgLy8gbm8tb3AgaW4gdGhhdCBjYXNlXG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggZXhhbXBsZXMgZmlyc3QsIHRoZW4gY3JlYXRlIHRoZSBkYXRhc2V0XG4gICAgICAgIGNvbnN0IGV4YW1wbGVzID0gYXdhaXQgc291cmNlQ2xpZW50Lmxpc3RTaGFyZWRFeGFtcGxlcyh0b2tlblV1aWQpO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5jcmVhdGVEYXRhc2V0KGZpbmFsRGF0YXNldE5hbWUsIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGRhdGFUeXBlOiBkcy5kYXRhX3R5cGUgfHwgXCJrdlwiLFxuICAgICAgICAgICAgaW5wdXRzU2NoZW1hOiBkcy5pbnB1dHNfc2NoZW1hX2RlZmluaXRpb24gPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3V0cHV0c1NjaGVtYTogZHMub3V0cHV0c19zY2hlbWFfZGVmaW5pdGlvbiA/PyB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVFeGFtcGxlcyh7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiBleGFtcGxlcy5tYXAoKGUpID0+IGUuaW5wdXRzKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBleGFtcGxlcy5mbGF0TWFwKChlKSA9PiAoZS5vdXRwdXRzID8gW2Uub3V0cHV0c10gOiBbXSkpLFxuICAgICAgICAgICAgICAgIGRhdGFzZXRJZDogZGF0YXNldC5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBjcmVhdGluZyBkYXRhc2V0ICR7ZmluYWxEYXRhc2V0TmFtZX0uIGAgK1xuICAgICAgICAgICAgICAgIFwiWW91IHNob3VsZCBkZWxldGUgaXQgbWFudWFsbHkuXCIpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZVRva2VuT3JVcmwodXJsT3JUb2tlbiwgYXBpVXJsLCBudW1QYXJ0cyA9IDIsIGtpbmQgPSBcImRhdGFzZXRcIikge1xuICAgICAgICAvLyBUcnkgcGFyc2luZyBhcyBVVUlEXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKHVybE9yVG9rZW4pOyAvLyBXaWxsIHRocm93IGlmIGl0J3Mgbm90IGEgVVVJRC5cbiAgICAgICAgICAgIHJldHVybiBbYXBpVXJsLCB1cmxPclRva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gbm8tb3AgaWYgaXQncyBub3QgYSB1dWlkXG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgYXMgVVJMXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybE9yVG9rZW4pO1xuICAgICAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gcGFyc2VkVXJsLnBhdGhuYW1lXG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiL1wiKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHBhcnQpID0+IHBhcnQgIT09IFwiXCIpO1xuICAgICAgICAgICAgaWYgKHBhdGhQYXJ0cy5sZW5ndGggPj0gbnVtUGFydHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblV1aWQgPSBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIG51bVBhcnRzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2FwaVVybCwgdG9rZW5VdWlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMgJHtraW5kfSBVUkw6ICR7dXJsT3JUb2tlbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMgJHtraW5kfSBVUkwgb3IgdG9rZW46ICR7dXJsT3JUb2tlbn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNhY2hlIGluc3RhbmNlLCBpZiBjYWNoaW5nIGlzIGVuYWJsZWQuXG4gICAgICogVXNlZnVsIGZvciBhY2Nlc3NpbmcgY2FjaGUgbWV0cmljcyBvciBtYW51YWxseSBtYW5hZ2luZyB0aGUgY2FjaGUuXG4gICAgICovXG4gICAgZ2V0IGNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFudXAgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIGNsaWVudC5cbiAgICAgKiBTdG9wcyB0aGUgY2FjaGUncyBiYWNrZ3JvdW5kIHJlZnJlc2ggdGltZXIuXG4gICAgICovXG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXdhaXRzIGFsbCBwZW5kaW5nIHRyYWNlIGJhdGNoZXMuIFVzZWZ1bCBmb3IgZW52aXJvbm1lbnRzIHdoZXJlXG4gICAgICogeW91IG5lZWQgdG8gYmUgc3VyZSB0aGF0IGFsbCB0cmFjaW5nIHJlcXVlc3RzIGZpbmlzaCBiZWZvcmUgZXhlY3V0aW9uIGVuZHMsXG4gICAgICogc3VjaCBhcyBzZXJ2ZXJsZXNzIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcImxhbmdzbWl0aFwiO1xuICAgICAqXG4gICAgICogY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgICAqXG4gICAgICogdHJ5IHtcbiAgICAgKiAgIC8vIFRyYWNpbmcgaGFwcGVucyBoZXJlXG4gICAgICogICAuLi5cbiAgICAgKiB9IGZpbmFsbHkge1xuICAgICAqICAgYXdhaXQgY2xpZW50LmF3YWl0UGVuZGluZ1RyYWNlQmF0Y2hlcygpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYWxsIGN1cnJlbnRseSBwZW5kaW5nIHRyYWNlcyBoYXZlIHNlbnQuXG4gICAgICovXG4gICAgYXN5bmMgYXdhaXRQZW5kaW5nVHJhY2VCYXRjaGVzKCkge1xuICAgICAgICBpZiAodGhpcy5tYW51YWxGbHVzaE1vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOSU5HXTogV2hlbiB0cmFjaW5nIGluIG1hbnVhbCBmbHVzaCBtb2RlLCB5b3UgbXVzdCBjYWxsIGBhd2FpdCBjbGllbnQuZmx1c2goKWAgbWFudWFsbHkgdG8gc3VibWl0IHRyYWNlIGJhdGNoZXMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cmFjZWFibGVzIHVzZSBhIGJhY2tncm91bmRlZCBwcm9taXNlIGJlZm9yZSB1cGRhdGluZyBydW5zIHRvIGF2b2lkIGJsb2NraW5nXG4gICAgICAgICAqIGFuZCB0byBhbGxvdyB3YWl0aW5nIGZvciBjaGlsZCBydW5zIHRvIGVuZC4gV2FpdGluZyBhIHNtYWxsIGFtb3VudCBvZiB0aW1lXG4gICAgICAgICAqIGhlcmUgZW5zdXJlcyB0aGF0IHRoZXkgYXJlIGFibGUgdG8gZW5xdWV1ZSB0aGVpciBydW4gb3BlcmF0aW9uIGJlZm9yZSB3ZSBhd2FpdFxuICAgICAgICAgKiBxdWV1ZWQgcnVuIG9wZXJhdGlvbnMgYmVsb3c6XG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJ1biA9IGF3YWl0IHRyYWNlYWJsZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAqICAgcmV0dXJuIFwiSGVsbG8sIHdvcmxkIVwiO1xuICAgICAgICAgKiB9LCB7IGNsaWVudCB9KSgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBhd2FpdCBjbGllbnQuYXdhaXRQZW5kaW5nVHJhY2VCYXRjaGVzKCk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMSkpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAuLi50aGlzLmF1dG9CYXRjaFF1ZXVlLml0ZW1zLm1hcCgoeyBpdGVtUHJvbWlzZSB9KSA9PiBpdGVtUHJvbWlzZSksXG4gICAgICAgICAgICB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyLnF1ZXVlLm9uSWRsZSgpLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHRoaXMubGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCBnZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMoKT8uREVGQVVMVF9MQU5HU01JVEhfU1BBTl9QUk9DRVNTT1I/LmZvcmNlRmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRXhhbXBsZUNyZWF0ZShpbnB1dCkge1xuICAgIHJldHVybiBcImRhdGFzZXRfaWRcIiBpbiBpbnB1dCB8fCBcImRhdGFzZXRfbmFtZVwiIGluIGlucHV0O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/env.js":
/*!********************************************!*\
  !*** ./node_modules/langsmith/dist/env.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTracingEnabled: () => (/* binding */ isTracingEnabled)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(ssr)/./node_modules/langsmith/dist/utils/env.js\");\n\nconst isTracingEnabled = (tracingEnabled) => {\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\"TRACING_V2\", \"TRACING\"];\n    return !!envVars.find((envVar) => (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(envVar) === \"true\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlFO0FBQzFEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOEVBQStCO0FBQ3JFIiwic291cmNlcyI6WyIvVXNlcnMvYXZlcnkvdGVzdDIvYWdlbnQtY2hhdC11aS9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZW52LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbmV4cG9ydCBjb25zdCBpc1RyYWNpbmdFbmFibGVkID0gKHRyYWNpbmdFbmFibGVkKSA9PiB7XG4gICAgaWYgKHRyYWNpbmdFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNpbmdFbmFibGVkO1xuICAgIH1cbiAgICBjb25zdCBlbnZWYXJzID0gW1wiVFJBQ0lOR19WMlwiLCBcIlRSQUNJTkdcIl07XG4gICAgcmV0dXJuICEhZW52VmFycy5maW5kKChlbnZWYXIpID0+IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoZW52VmFyKSA9PT0gXCJ0cnVlXCIpO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/env.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/experimental/otel/constants.js":
/*!********************************************************************!*\
  !*** ./node_modules/langsmith/dist/experimental/otel/constants.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AI_SDK_LLM_OPERATIONS: () => (/* binding */ AI_SDK_LLM_OPERATIONS),\n/* harmony export */   AI_SDK_TOOL_OPERATIONS: () => (/* binding */ AI_SDK_TOOL_OPERATIONS),\n/* harmony export */   GENAI_COMPLETION: () => (/* binding */ GENAI_COMPLETION),\n/* harmony export */   GENAI_PROMPT: () => (/* binding */ GENAI_PROMPT),\n/* harmony export */   GEN_AI_ASSISTANT_MESSAGE: () => (/* binding */ GEN_AI_ASSISTANT_MESSAGE),\n/* harmony export */   GEN_AI_CHOICE: () => (/* binding */ GEN_AI_CHOICE),\n/* harmony export */   GEN_AI_OPERATION_NAME: () => (/* binding */ GEN_AI_OPERATION_NAME),\n/* harmony export */   GEN_AI_REQUEST_EXTRA_BODY: () => (/* binding */ GEN_AI_REQUEST_EXTRA_BODY),\n/* harmony export */   GEN_AI_REQUEST_EXTRA_QUERY: () => (/* binding */ GEN_AI_REQUEST_EXTRA_QUERY),\n/* harmony export */   GEN_AI_REQUEST_FREQUENCY_PENALTY: () => (/* binding */ GEN_AI_REQUEST_FREQUENCY_PENALTY),\n/* harmony export */   GEN_AI_REQUEST_MAX_TOKENS: () => (/* binding */ GEN_AI_REQUEST_MAX_TOKENS),\n/* harmony export */   GEN_AI_REQUEST_MODEL: () => (/* binding */ GEN_AI_REQUEST_MODEL),\n/* harmony export */   GEN_AI_REQUEST_PRESENCE_PENALTY: () => (/* binding */ GEN_AI_REQUEST_PRESENCE_PENALTY),\n/* harmony export */   GEN_AI_REQUEST_TEMPERATURE: () => (/* binding */ GEN_AI_REQUEST_TEMPERATURE),\n/* harmony export */   GEN_AI_REQUEST_TOP_P: () => (/* binding */ GEN_AI_REQUEST_TOP_P),\n/* harmony export */   GEN_AI_RESPONSE_FINISH_REASONS: () => (/* binding */ GEN_AI_RESPONSE_FINISH_REASONS),\n/* harmony export */   GEN_AI_RESPONSE_ID: () => (/* binding */ GEN_AI_RESPONSE_ID),\n/* harmony export */   GEN_AI_RESPONSE_MODEL: () => (/* binding */ GEN_AI_RESPONSE_MODEL),\n/* harmony export */   GEN_AI_RESPONSE_SERVICE_TIER: () => (/* binding */ GEN_AI_RESPONSE_SERVICE_TIER),\n/* harmony export */   GEN_AI_RESPONSE_SYSTEM_FINGERPRINT: () => (/* binding */ GEN_AI_RESPONSE_SYSTEM_FINGERPRINT),\n/* harmony export */   GEN_AI_SERIALIZED_DOC: () => (/* binding */ GEN_AI_SERIALIZED_DOC),\n/* harmony export */   GEN_AI_SERIALIZED_NAME: () => (/* binding */ GEN_AI_SERIALIZED_NAME),\n/* harmony export */   GEN_AI_SERIALIZED_SIGNATURE: () => (/* binding */ GEN_AI_SERIALIZED_SIGNATURE),\n/* harmony export */   GEN_AI_SYSTEM: () => (/* binding */ GEN_AI_SYSTEM),\n/* harmony export */   GEN_AI_SYSTEM_MESSAGE: () => (/* binding */ GEN_AI_SYSTEM_MESSAGE),\n/* harmony export */   GEN_AI_USAGE_INPUT_TOKENS: () => (/* binding */ GEN_AI_USAGE_INPUT_TOKENS),\n/* harmony export */   GEN_AI_USAGE_INPUT_TOKEN_DETAILS: () => (/* binding */ GEN_AI_USAGE_INPUT_TOKEN_DETAILS),\n/* harmony export */   GEN_AI_USAGE_OUTPUT_TOKENS: () => (/* binding */ GEN_AI_USAGE_OUTPUT_TOKENS),\n/* harmony export */   GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS: () => (/* binding */ GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS),\n/* harmony export */   GEN_AI_USAGE_TOTAL_TOKENS: () => (/* binding */ GEN_AI_USAGE_TOTAL_TOKENS),\n/* harmony export */   GEN_AI_USER_MESSAGE: () => (/* binding */ GEN_AI_USER_MESSAGE),\n/* harmony export */   LANGSMITH_DOTTED_ORDER: () => (/* binding */ LANGSMITH_DOTTED_ORDER),\n/* harmony export */   LANGSMITH_IS_ROOT: () => (/* binding */ LANGSMITH_IS_ROOT),\n/* harmony export */   LANGSMITH_METADATA: () => (/* binding */ LANGSMITH_METADATA),\n/* harmony export */   LANGSMITH_NAME: () => (/* binding */ LANGSMITH_NAME),\n/* harmony export */   LANGSMITH_PARENT_RUN_ID: () => (/* binding */ LANGSMITH_PARENT_RUN_ID),\n/* harmony export */   LANGSMITH_REFERENCE_EXAMPLE_ID: () => (/* binding */ LANGSMITH_REFERENCE_EXAMPLE_ID),\n/* harmony export */   LANGSMITH_REQUEST_HEADERS: () => (/* binding */ LANGSMITH_REQUEST_HEADERS),\n/* harmony export */   LANGSMITH_REQUEST_STREAMING: () => (/* binding */ LANGSMITH_REQUEST_STREAMING),\n/* harmony export */   LANGSMITH_RUNTIME: () => (/* binding */ LANGSMITH_RUNTIME),\n/* harmony export */   LANGSMITH_RUN_ID: () => (/* binding */ LANGSMITH_RUN_ID),\n/* harmony export */   LANGSMITH_RUN_TYPE: () => (/* binding */ LANGSMITH_RUN_TYPE),\n/* harmony export */   LANGSMITH_SESSION_ID: () => (/* binding */ LANGSMITH_SESSION_ID),\n/* harmony export */   LANGSMITH_SESSION_NAME: () => (/* binding */ LANGSMITH_SESSION_NAME),\n/* harmony export */   LANGSMITH_TAGS: () => (/* binding */ LANGSMITH_TAGS),\n/* harmony export */   LANGSMITH_TRACEABLE: () => (/* binding */ LANGSMITH_TRACEABLE),\n/* harmony export */   LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID: () => (/* binding */ LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID),\n/* harmony export */   LANGSMITH_TRACE_ID: () => (/* binding */ LANGSMITH_TRACE_ID),\n/* harmony export */   LANGSMITH_USAGE_METADATA: () => (/* binding */ LANGSMITH_USAGE_METADATA)\n/* harmony export */ });\n// OpenTelemetry GenAI semantic convention attribute names\nconst GEN_AI_OPERATION_NAME = \"gen_ai.operation.name\";\nconst GEN_AI_SYSTEM = \"gen_ai.system\";\nconst GEN_AI_REQUEST_MODEL = \"gen_ai.request.model\";\nconst GEN_AI_RESPONSE_MODEL = \"gen_ai.response.model\";\nconst GEN_AI_USAGE_INPUT_TOKENS = \"gen_ai.usage.input_tokens\";\nconst GEN_AI_USAGE_OUTPUT_TOKENS = \"gen_ai.usage.output_tokens\";\nconst GEN_AI_USAGE_TOTAL_TOKENS = \"gen_ai.usage.total_tokens\";\nconst GEN_AI_REQUEST_MAX_TOKENS = \"gen_ai.request.max_tokens\";\nconst GEN_AI_REQUEST_TEMPERATURE = \"gen_ai.request.temperature\";\nconst GEN_AI_REQUEST_TOP_P = \"gen_ai.request.top_p\";\nconst GEN_AI_REQUEST_FREQUENCY_PENALTY = \"gen_ai.request.frequency_penalty\";\nconst GEN_AI_REQUEST_PRESENCE_PENALTY = \"gen_ai.request.presence_penalty\";\nconst GEN_AI_RESPONSE_FINISH_REASONS = \"gen_ai.response.finish_reasons\";\nconst GENAI_PROMPT = \"gen_ai.prompt\";\nconst GENAI_COMPLETION = \"gen_ai.completion\";\nconst GEN_AI_REQUEST_EXTRA_QUERY = \"gen_ai.request.extra_query\";\nconst GEN_AI_REQUEST_EXTRA_BODY = \"gen_ai.request.extra_body\";\nconst GEN_AI_SERIALIZED_NAME = \"gen_ai.serialized.name\";\nconst GEN_AI_SERIALIZED_SIGNATURE = \"gen_ai.serialized.signature\";\nconst GEN_AI_SERIALIZED_DOC = \"gen_ai.serialized.doc\";\nconst GEN_AI_RESPONSE_ID = \"gen_ai.response.id\";\nconst GEN_AI_RESPONSE_SERVICE_TIER = \"gen_ai.response.service_tier\";\nconst GEN_AI_RESPONSE_SYSTEM_FINGERPRINT = \"gen_ai.response.system_fingerprint\";\nconst GEN_AI_USAGE_INPUT_TOKEN_DETAILS = \"gen_ai.usage.input_token_details\";\nconst GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS = \"gen_ai.usage.output_token_details\";\n// LangSmith custom attributes\nconst LANGSMITH_SESSION_ID = \"langsmith.trace.session_id\";\nconst LANGSMITH_SESSION_NAME = \"langsmith.trace.session_name\";\nconst LANGSMITH_RUN_TYPE = \"langsmith.span.kind\";\nconst LANGSMITH_NAME = \"langsmith.trace.name\";\nconst LANGSMITH_METADATA = \"langsmith.metadata\";\nconst LANGSMITH_TAGS = \"langsmith.span.tags\";\nconst LANGSMITH_RUNTIME = \"langsmith.span.runtime\";\nconst LANGSMITH_REQUEST_STREAMING = \"langsmith.request.streaming\";\nconst LANGSMITH_REQUEST_HEADERS = \"langsmith.request.headers\";\nconst LANGSMITH_RUN_ID = \"langsmith.span.id\";\nconst LANGSMITH_TRACE_ID = \"langsmith.trace.id\";\nconst LANGSMITH_DOTTED_ORDER = \"langsmith.span.dotted_order\";\nconst LANGSMITH_PARENT_RUN_ID = \"langsmith.span.parent_id\";\nconst LANGSMITH_USAGE_METADATA = \"langsmith.usage_metadata\";\nconst LANGSMITH_REFERENCE_EXAMPLE_ID = \"langsmith.reference_example_id\";\nconst LANGSMITH_TRACEABLE = \"langsmith.traceable\";\nconst LANGSMITH_IS_ROOT = \"langsmith.is_root\";\nconst LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID = \"langsmith.traceable_parent_otel_span_id\";\n// GenAI event names\nconst GEN_AI_SYSTEM_MESSAGE = \"gen_ai.system.message\";\nconst GEN_AI_USER_MESSAGE = \"gen_ai.user.message\";\nconst GEN_AI_ASSISTANT_MESSAGE = \"gen_ai.assistant.message\";\nconst GEN_AI_CHOICE = \"gen_ai.choice\";\nconst AI_SDK_LLM_OPERATIONS = [\n    \"ai.generateText.doGenerate\",\n    \"ai.streamText.doStream\",\n    \"ai.generateObject.doGenerate\",\n    \"ai.streamObject.doStream\",\n];\nconst AI_SDK_TOOL_OPERATIONS = [\"ai.toolCall\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZXhwZXJpbWVudGFsL290ZWwvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08iLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9leHBlcmltZW50YWwvb3RlbC9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT3BlblRlbGVtZXRyeSBHZW5BSSBzZW1hbnRpYyBjb252ZW50aW9uIGF0dHJpYnV0ZSBuYW1lc1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9PUEVSQVRJT05fTkFNRSA9IFwiZ2VuX2FpLm9wZXJhdGlvbi5uYW1lXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1NZU1RFTSA9IFwiZ2VuX2FpLnN5c3RlbVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVFVRVNUX01PREVMID0gXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVNQT05TRV9NT0RFTCA9IFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1VTQUdFX0lOUFVUX1RPS0VOUyA9IFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9VU0FHRV9PVVRQVVRfVE9LRU5TID0gXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9VU0FHRV9UT1RBTF9UT0tFTlMgPSBcImdlbl9haS51c2FnZS50b3RhbF90b2tlbnNcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9NQVhfVE9LRU5TID0gXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFUVVFU1RfVEVNUEVSQVRVUkUgPSBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFUVVFU1RfVE9QX1AgPSBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFUVVFU1RfRlJFUVVFTkNZX1BFTkFMVFkgPSBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFUVVFU1RfUFJFU0VOQ0VfUEVOQUxUWSA9IFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVNQT05TRV9GSU5JU0hfUkVBU09OUyA9IFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI7XG5leHBvcnQgY29uc3QgR0VOQUlfUFJPTVBUID0gXCJnZW5fYWkucHJvbXB0XCI7XG5leHBvcnQgY29uc3QgR0VOQUlfQ09NUExFVElPTiA9IFwiZ2VuX2FpLmNvbXBsZXRpb25cIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9FWFRSQV9RVUVSWSA9IFwiZ2VuX2FpLnJlcXVlc3QuZXh0cmFfcXVlcnlcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9FWFRSQV9CT0RZID0gXCJnZW5fYWkucmVxdWVzdC5leHRyYV9ib2R5XCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1NFUklBTElaRURfTkFNRSA9IFwiZ2VuX2FpLnNlcmlhbGl6ZWQubmFtZVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9TRVJJQUxJWkVEX1NJR05BVFVSRSA9IFwiZ2VuX2FpLnNlcmlhbGl6ZWQuc2lnbmF0dXJlXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1NFUklBTElaRURfRE9DID0gXCJnZW5fYWkuc2VyaWFsaXplZC5kb2NcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVTUE9OU0VfSUQgPSBcImdlbl9haS5yZXNwb25zZS5pZFwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVNQT05TRV9TRVJWSUNFX1RJRVIgPSBcImdlbl9haS5yZXNwb25zZS5zZXJ2aWNlX3RpZXJcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVTUE9OU0VfU1lTVEVNX0ZJTkdFUlBSSU5UID0gXCJnZW5fYWkucmVzcG9uc2Uuc3lzdGVtX2ZpbmdlcnByaW50XCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1VTQUdFX0lOUFVUX1RPS0VOX0RFVEFJTFMgPSBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbl9kZXRhaWxzXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTl9ERVRBSUxTID0gXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2VuX2RldGFpbHNcIjtcbi8vIExhbmdTbWl0aCBjdXN0b20gYXR0cmlidXRlc1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9TRVNTSU9OX0lEID0gXCJsYW5nc21pdGgudHJhY2Uuc2Vzc2lvbl9pZFwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9TRVNTSU9OX05BTUUgPSBcImxhbmdzbWl0aC50cmFjZS5zZXNzaW9uX25hbWVcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUlVOX1RZUEUgPSBcImxhbmdzbWl0aC5zcGFuLmtpbmRcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfTkFNRSA9IFwibGFuZ3NtaXRoLnRyYWNlLm5hbWVcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfTUVUQURBVEEgPSBcImxhbmdzbWl0aC5tZXRhZGF0YVwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9UQUdTID0gXCJsYW5nc21pdGguc3Bhbi50YWdzXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1JVTlRJTUUgPSBcImxhbmdzbWl0aC5zcGFuLnJ1bnRpbWVcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUkVRVUVTVF9TVFJFQU1JTkcgPSBcImxhbmdzbWl0aC5yZXF1ZXN0LnN0cmVhbWluZ1wiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9SRVFVRVNUX0hFQURFUlMgPSBcImxhbmdzbWl0aC5yZXF1ZXN0LmhlYWRlcnNcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUlVOX0lEID0gXCJsYW5nc21pdGguc3Bhbi5pZFwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9UUkFDRV9JRCA9IFwibGFuZ3NtaXRoLnRyYWNlLmlkXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX0RPVFRFRF9PUkRFUiA9IFwibGFuZ3NtaXRoLnNwYW4uZG90dGVkX29yZGVyXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1BBUkVOVF9SVU5fSUQgPSBcImxhbmdzbWl0aC5zcGFuLnBhcmVudF9pZFwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9VU0FHRV9NRVRBREFUQSA9IFwibGFuZ3NtaXRoLnVzYWdlX21ldGFkYXRhXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1JFRkVSRU5DRV9FWEFNUExFX0lEID0gXCJsYW5nc21pdGgucmVmZXJlbmNlX2V4YW1wbGVfaWRcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfVFJBQ0VBQkxFID0gXCJsYW5nc21pdGgudHJhY2VhYmxlXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX0lTX1JPT1QgPSBcImxhbmdzbWl0aC5pc19yb290XCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1RSQUNFQUJMRV9QQVJFTlRfT1RFTF9TUEFOX0lEID0gXCJsYW5nc21pdGgudHJhY2VhYmxlX3BhcmVudF9vdGVsX3NwYW5faWRcIjtcbi8vIEdlbkFJIGV2ZW50IG5hbWVzXG5leHBvcnQgY29uc3QgR0VOX0FJX1NZU1RFTV9NRVNTQUdFID0gXCJnZW5fYWkuc3lzdGVtLm1lc3NhZ2VcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfVVNFUl9NRVNTQUdFID0gXCJnZW5fYWkudXNlci5tZXNzYWdlXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX0FTU0lTVEFOVF9NRVNTQUdFID0gXCJnZW5fYWkuYXNzaXN0YW50Lm1lc3NhZ2VcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfQ0hPSUNFID0gXCJnZW5fYWkuY2hvaWNlXCI7XG5leHBvcnQgY29uc3QgQUlfU0RLX0xMTV9PUEVSQVRJT05TID0gW1xuICAgIFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICBcImFpLnN0cmVhbVRleHQuZG9TdHJlYW1cIixcbiAgICBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuXTtcbmV4cG9ydCBjb25zdCBBSV9TREtfVE9PTF9PUEVSQVRJT05TID0gW1wiYWkudG9vbENhbGxcIl07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/experimental/otel/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/experimental/otel/translator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/dist/experimental/otel/translator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangSmithToOTELTranslator: () => (/* binding */ LangSmithToOTELTranslator)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/langsmith/dist/experimental/otel/constants.js\");\n/* harmony import */ var _singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../singletons/otel.js */ \"(ssr)/./node_modules/langsmith/dist/singletons/otel.js\");\n\n\nconst WELL_KNOWN_OPERATION_NAMES = {\n    llm: \"chat\",\n    tool: \"execute_tool\",\n    retriever: \"embeddings\",\n    embedding: \"embeddings\",\n    prompt: \"chat\",\n};\nfunction getOperationName(runType) {\n    return WELL_KNOWN_OPERATION_NAMES[runType] || runType;\n}\nclass LangSmithToOTELTranslator {\n    constructor() {\n        Object.defineProperty(this, \"spans\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    exportBatch(operations, otelContextMap) {\n        for (const op of operations) {\n            try {\n                if (!op.run) {\n                    continue;\n                }\n                if (op.operation === \"post\") {\n                    const span = this.createSpanForRun(op, op.run, otelContextMap.get(op.id));\n                    if (span && !op.run.end_time) {\n                        this.spans.set(op.id, span);\n                    }\n                }\n                else {\n                    this.updateSpanForRun(op, op.run);\n                }\n            }\n            catch (e) {\n                console.error(`Error processing operation ${op.id}:`, e);\n            }\n        }\n    }\n    createSpanForRun(op, runInfo, otelContext) {\n        const activeSpan = otelContext && (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELTrace)().getSpan(otelContext);\n        if (!activeSpan) {\n            return;\n        }\n        try {\n            return this.finishSpanSetup(activeSpan, runInfo, op);\n        }\n        catch (e) {\n            console.error(`Failed to create span for run ${op.id}:`, e);\n            return undefined;\n        }\n    }\n    finishSpanSetup(span, runInfo, op) {\n        // Set all attributes\n        this.setSpanAttributes(span, runInfo, op);\n        // Set status based on error\n        if (runInfo.error) {\n            span.setStatus({ code: 2 }); // ERROR status\n            span.recordException(new Error(runInfo.error));\n        }\n        else {\n            span.setStatus({ code: 1 }); // OK status\n        }\n        // End the span if end_time is present\n        if (runInfo.end_time) {\n            span.end(new Date(runInfo.end_time));\n        }\n        return span;\n    }\n    updateSpanForRun(op, runInfo) {\n        try {\n            const span = this.spans.get(op.id);\n            if (!span) {\n                console.debug(`No span found for run ${op.id} during update`);\n                return;\n            }\n            // Update attributes\n            this.setSpanAttributes(span, runInfo, op);\n            // Update status based on error\n            if (runInfo.error) {\n                span.setStatus({ code: 2 }); // ERROR status\n                span.recordException(new Error(runInfo.error));\n            }\n            else {\n                span.setStatus({ code: 1 }); // OK status\n            }\n            // End the span if end_time is present\n            const endTime = runInfo.end_time;\n            if (endTime) {\n                span.end(new Date(endTime));\n                this.spans.delete(op.id);\n            }\n        }\n        catch (e) {\n            console.error(`Failed to update span for run ${op.id}:`, e);\n        }\n    }\n    extractModelName(runInfo) {\n        // Try to get model name from metadata\n        if (runInfo.extra?.metadata) {\n            const metadata = runInfo.extra.metadata;\n            // First check for ls_model_name in metadata\n            if (metadata.ls_model_name) {\n                return metadata.ls_model_name;\n            }\n            // Then check invocation_params for model info\n            if (metadata.invocation_params) {\n                const invocationParams = metadata.invocation_params;\n                if (invocationParams.model) {\n                    return invocationParams.model;\n                }\n                else if (invocationParams.model_name) {\n                    return invocationParams.model_name;\n                }\n            }\n        }\n        return;\n    }\n    setSpanAttributes(span, runInfo, op) {\n        if (\"run_type\" in runInfo && runInfo.run_type) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_RUN_TYPE, runInfo.run_type);\n            // Set GenAI attributes according to OTEL semantic conventions\n            const operationName = getOperationName(runInfo.run_type || \"chain\");\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_OPERATION_NAME, operationName);\n        }\n        if (\"name\" in runInfo && runInfo.name) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_NAME, runInfo.name);\n        }\n        if (\"session_id\" in runInfo && runInfo.session_id) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_SESSION_ID, runInfo.session_id);\n        }\n        if (\"session_name\" in runInfo && runInfo.session_name) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_SESSION_NAME, runInfo.session_name);\n        }\n        // Set gen_ai.system\n        this.setGenAiSystem(span, runInfo);\n        // Set model name if available\n        const modelName = this.extractModelName(runInfo);\n        if (modelName) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MODEL, modelName);\n        }\n        // Set token usage information\n        if (\"prompt_tokens\" in runInfo &&\n            typeof runInfo.prompt_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKENS, runInfo.prompt_tokens);\n        }\n        if (\"completion_tokens\" in runInfo &&\n            typeof runInfo.completion_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKENS, runInfo.completion_tokens);\n        }\n        if (\"total_tokens\" in runInfo && typeof runInfo.total_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_TOTAL_TOKENS, runInfo.total_tokens);\n        }\n        // Set other parameters from invocation_params\n        this.setInvocationParameters(span, runInfo);\n        // Set metadata and tags if available\n        const metadata = runInfo.extra?.metadata || {};\n        for (const [key, value] of Object.entries(metadata)) {\n            if (value !== null && value !== undefined) {\n                span.setAttribute(`${_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_METADATA}.${key}`, String(value));\n            }\n        }\n        const tags = runInfo.tags;\n        if (tags && Array.isArray(tags)) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_TAGS, tags.join(\", \"));\n        }\n        else if (tags) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_TAGS, String(tags));\n        }\n        // Support additional serialized attributes, if present\n        if (\"serialized\" in runInfo && typeof runInfo.serialized === \"object\") {\n            const serialized = runInfo.serialized;\n            if (serialized.name) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_NAME, String(serialized.name));\n            }\n            if (serialized.signature) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_SIGNATURE, String(serialized.signature));\n            }\n            if (serialized.doc) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_DOC, String(serialized.doc));\n            }\n        }\n        // Set inputs/outputs if available\n        this.setIOAttributes(span, op);\n    }\n    setGenAiSystem(span, runInfo) {\n        // Default to \"langchain\" if we can't determine the system\n        let system = \"langchain\";\n        // Extract model name to determine the system\n        const modelName = this.extractModelName(runInfo);\n        if (modelName) {\n            const modelLower = modelName.toLowerCase();\n            if (modelLower.includes(\"anthropic\") || modelLower.startsWith(\"claude\")) {\n                system = \"anthropic\";\n            }\n            else if (modelLower.includes(\"bedrock\")) {\n                system = \"aws.bedrock\";\n            }\n            else if (modelLower.includes(\"azure\") &&\n                modelLower.includes(\"openai\")) {\n                system = \"az.ai.openai\";\n            }\n            else if (modelLower.includes(\"azure\") &&\n                modelLower.includes(\"inference\")) {\n                system = \"az.ai.inference\";\n            }\n            else if (modelLower.includes(\"cohere\")) {\n                system = \"cohere\";\n            }\n            else if (modelLower.includes(\"deepseek\")) {\n                system = \"deepseek\";\n            }\n            else if (modelLower.includes(\"gemini\")) {\n                system = \"gemini\";\n            }\n            else if (modelLower.includes(\"groq\")) {\n                system = \"groq\";\n            }\n            else if (modelLower.includes(\"watson\") || modelLower.includes(\"ibm\")) {\n                system = \"ibm.watsonx.ai\";\n            }\n            else if (modelLower.includes(\"mistral\")) {\n                system = \"mistral_ai\";\n            }\n            else if (modelLower.includes(\"gpt\") || modelLower.includes(\"openai\")) {\n                system = \"openai\";\n            }\n            else if (modelLower.includes(\"perplexity\") ||\n                modelLower.includes(\"sonar\")) {\n                system = \"perplexity\";\n            }\n            else if (modelLower.includes(\"vertex\")) {\n                system = \"vertex_ai\";\n            }\n            else if (modelLower.includes(\"xai\") || modelLower.includes(\"grok\")) {\n                system = \"xai\";\n            }\n        }\n        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SYSTEM, system);\n    }\n    setInvocationParameters(span, runInfo) {\n        if (!runInfo.extra?.metadata?.invocation_params) {\n            return;\n        }\n        const invocationParams = runInfo.extra.metadata.invocation_params;\n        // Set relevant invocation parameters\n        if (invocationParams.max_tokens !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MAX_TOKENS, invocationParams.max_tokens);\n        }\n        if (invocationParams.temperature !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_TEMPERATURE, invocationParams.temperature);\n        }\n        if (invocationParams.top_p !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_TOP_P, invocationParams.top_p);\n        }\n        if (invocationParams.frequency_penalty !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_FREQUENCY_PENALTY, invocationParams.frequency_penalty);\n        }\n        if (invocationParams.presence_penalty !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_PRESENCE_PENALTY, invocationParams.presence_penalty);\n        }\n    }\n    setIOAttributes(span, op) {\n        if (op.run.inputs) {\n            try {\n                const inputs = op.run.inputs;\n                if (typeof inputs === \"object\" && inputs !== null) {\n                    if (inputs.model && Array.isArray(inputs.messages)) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MODEL, inputs.model);\n                    }\n                    // Set additional request attributes if available\n                    if (inputs.stream !== undefined) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_REQUEST_STREAMING, inputs.stream);\n                    }\n                    if (inputs.extra_headers) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_REQUEST_HEADERS, JSON.stringify(inputs.extra_headers));\n                    }\n                    if (inputs.extra_query) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_EXTRA_QUERY, JSON.stringify(inputs.extra_query));\n                    }\n                    if (inputs.extra_body) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_EXTRA_BODY, JSON.stringify(inputs.extra_body));\n                    }\n                }\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GENAI_PROMPT, JSON.stringify(inputs));\n            }\n            catch (e) {\n                console.debug(`Failed to process inputs for run ${op.id}`, e);\n            }\n        }\n        if (op.run.outputs) {\n            try {\n                const outputs = op.run.outputs;\n                // Extract token usage from outputs (for LLM runs)\n                const tokenUsage = this.getUnifiedRunTokens(outputs);\n                if (tokenUsage) {\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKENS, tokenUsage[0]);\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKENS, tokenUsage[1]);\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_TOTAL_TOKENS, tokenUsage[0] + tokenUsage[1]);\n                }\n                if (outputs && typeof outputs === \"object\") {\n                    if (outputs.model) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_MODEL, String(outputs.model));\n                    }\n                    // Extract additional response attributes\n                    if (outputs.id) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_ID, outputs.id);\n                    }\n                    if (outputs.choices && Array.isArray(outputs.choices)) {\n                        const finishReasons = outputs.choices\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            .map((choice) => choice.finish_reason)\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            .filter((reason) => reason)\n                            .map(String);\n                        if (finishReasons.length > 0) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_FINISH_REASONS, finishReasons.join(\", \"));\n                        }\n                    }\n                    if (outputs.service_tier) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_SERVICE_TIER, outputs.service_tier);\n                    }\n                    if (outputs.system_fingerprint) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_SYSTEM_FINGERPRINT, outputs.system_fingerprint);\n                    }\n                    if (outputs.usage_metadata &&\n                        typeof outputs.usage_metadata === \"object\") {\n                        const usageMetadata = outputs.usage_metadata;\n                        if (usageMetadata.input_token_details) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.input_token_details));\n                        }\n                        if (usageMetadata.output_token_details) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.output_token_details));\n                        }\n                    }\n                }\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GENAI_COMPLETION, JSON.stringify(outputs));\n            }\n            catch (e) {\n                console.debug(`Failed to process outputs for run ${op.id}`, e);\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getUnifiedRunTokens(outputs) {\n        if (!outputs) {\n            return null;\n        }\n        // Search in non-generations lists\n        let tokenUsage = this.extractUnifiedRunTokens(outputs.usage_metadata);\n        if (tokenUsage) {\n            return tokenUsage;\n        }\n        // Find if direct kwarg in outputs\n        const keys = Object.keys(outputs);\n        for (const key of keys) {\n            const haystack = outputs[key];\n            if (!haystack || typeof haystack !== \"object\") {\n                continue;\n            }\n            tokenUsage = this.extractUnifiedRunTokens(haystack.usage_metadata);\n            if (tokenUsage) {\n                return tokenUsage;\n            }\n            if (haystack.lc === 1 &&\n                haystack.kwargs &&\n                typeof haystack.kwargs === \"object\") {\n                tokenUsage = this.extractUnifiedRunTokens(haystack.kwargs.usage_metadata);\n                if (tokenUsage) {\n                    return tokenUsage;\n                }\n            }\n        }\n        // Find in generations\n        const generations = outputs.generations || [];\n        if (!Array.isArray(generations)) {\n            return null;\n        }\n        const flatGenerations = Array.isArray(generations[0])\n            ? generations.flat()\n            : generations;\n        for (const generation of flatGenerations) {\n            if (typeof generation === \"object\" &&\n                generation.message &&\n                typeof generation.message === \"object\" &&\n                generation.message.kwargs &&\n                typeof generation.message.kwargs === \"object\") {\n                tokenUsage = this.extractUnifiedRunTokens(generation.message.kwargs.usage_metadata);\n                if (tokenUsage) {\n                    return tokenUsage;\n                }\n            }\n        }\n        return null;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extractUnifiedRunTokens(outputs) {\n        if (!outputs || typeof outputs !== \"object\") {\n            return null;\n        }\n        if (typeof outputs.input_tokens !== \"number\" ||\n            typeof outputs.output_tokens !== \"number\") {\n            return null;\n        }\n        return [outputs.input_tokens, outputs.output_tokens];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZXhwZXJpbWVudGFsL290ZWwvdHJhbnNsYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEM7QUFDWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlFQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU07QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVMsR0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVMsR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUyxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZEQUE0QjtBQUMxRDtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXZlcnkvdGVzdDIvYWdlbnQtY2hhdC11aS9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZXhwZXJpbWVudGFsL290ZWwvdHJhbnNsYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBnZXRPVEVMVHJhY2UgfSBmcm9tIFwiLi4vLi4vc2luZ2xldG9ucy9vdGVsLmpzXCI7XG5jb25zdCBXRUxMX0tOT1dOX09QRVJBVElPTl9OQU1FUyA9IHtcbiAgICBsbG06IFwiY2hhdFwiLFxuICAgIHRvb2w6IFwiZXhlY3V0ZV90b29sXCIsXG4gICAgcmV0cmlldmVyOiBcImVtYmVkZGluZ3NcIixcbiAgICBlbWJlZGRpbmc6IFwiZW1iZWRkaW5nc1wiLFxuICAgIHByb21wdDogXCJjaGF0XCIsXG59O1xuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uTmFtZShydW5UeXBlKSB7XG4gICAgcmV0dXJuIFdFTExfS05PV05fT1BFUkFUSU9OX05BTUVTW3J1blR5cGVdIHx8IHJ1blR5cGU7XG59XG5leHBvcnQgY2xhc3MgTGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNwYW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4cG9ydEJhdGNoKG9wZXJhdGlvbnMsIG90ZWxDb250ZXh0TWFwKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BlcmF0aW9ucykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wLnJ1bikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wLm9wZXJhdGlvbiA9PT0gXCJwb3N0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuY3JlYXRlU3BhbkZvclJ1bihvcCwgb3AucnVuLCBvdGVsQ29udGV4dE1hcC5nZXQob3AuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW4gJiYgIW9wLnJ1bi5lbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGFucy5zZXQob3AuaWQsIHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNwYW5Gb3JSdW4ob3AsIG9wLnJ1bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIG9wZXJhdGlvbiAke29wLmlkfTpgLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVTcGFuRm9yUnVuKG9wLCBydW5JbmZvLCBvdGVsQ29udGV4dCkge1xuICAgICAgICBjb25zdCBhY3RpdmVTcGFuID0gb3RlbENvbnRleHQgJiYgZ2V0T1RFTFRyYWNlKCkuZ2V0U3BhbihvdGVsQ29udGV4dCk7XG4gICAgICAgIGlmICghYWN0aXZlU3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hTcGFuU2V0dXAoYWN0aXZlU3BhbiwgcnVuSW5mbywgb3ApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHNwYW4gZm9yIHJ1biAke29wLmlkfTpgLCBlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluaXNoU3BhblNldHVwKHNwYW4sIHJ1bkluZm8sIG9wKSB7XG4gICAgICAgIC8vIFNldCBhbGwgYXR0cmlidXRlc1xuICAgICAgICB0aGlzLnNldFNwYW5BdHRyaWJ1dGVzKHNwYW4sIHJ1bkluZm8sIG9wKTtcbiAgICAgICAgLy8gU2V0IHN0YXR1cyBiYXNlZCBvbiBlcnJvclxuICAgICAgICBpZiAocnVuSW5mby5lcnJvcikge1xuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiAyIH0pOyAvLyBFUlJPUiBzdGF0dXNcbiAgICAgICAgICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKG5ldyBFcnJvcihydW5JbmZvLmVycm9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IDEgfSk7IC8vIE9LIHN0YXR1c1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuZCB0aGUgc3BhbiBpZiBlbmRfdGltZSBpcyBwcmVzZW50XG4gICAgICAgIGlmIChydW5JbmZvLmVuZF90aW1lKSB7XG4gICAgICAgICAgICBzcGFuLmVuZChuZXcgRGF0ZShydW5JbmZvLmVuZF90aW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIHVwZGF0ZVNwYW5Gb3JSdW4ob3AsIHJ1bkluZm8pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLnNwYW5zLmdldChvcC5pZCk7XG4gICAgICAgICAgICBpZiAoIXNwYW4pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBObyBzcGFuIGZvdW5kIGZvciBydW4gJHtvcC5pZH0gZHVyaW5nIHVwZGF0ZWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICB0aGlzLnNldFNwYW5BdHRyaWJ1dGVzKHNwYW4sIHJ1bkluZm8sIG9wKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgYmFzZWQgb24gZXJyb3JcbiAgICAgICAgICAgIGlmIChydW5JbmZvLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiAyIH0pOyAvLyBFUlJPUiBzdGF0dXNcbiAgICAgICAgICAgICAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbihuZXcgRXJyb3IocnVuSW5mby5lcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiAxIH0pOyAvLyBPSyBzdGF0dXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVuZCB0aGUgc3BhbiBpZiBlbmRfdGltZSBpcyBwcmVzZW50XG4gICAgICAgICAgICBjb25zdCBlbmRUaW1lID0gcnVuSW5mby5lbmRfdGltZTtcbiAgICAgICAgICAgIGlmIChlbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5lbmQobmV3IERhdGUoZW5kVGltZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BhbnMuZGVsZXRlKG9wLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBzcGFuIGZvciBydW4gJHtvcC5pZH06YCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmFjdE1vZGVsTmFtZShydW5JbmZvKSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgbW9kZWwgbmFtZSBmcm9tIG1ldGFkYXRhXG4gICAgICAgIGlmIChydW5JbmZvLmV4dHJhPy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBydW5JbmZvLmV4dHJhLm1ldGFkYXRhO1xuICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgZm9yIGxzX21vZGVsX25hbWUgaW4gbWV0YWRhdGFcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5sc19tb2RlbF9uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmxzX21vZGVsX25hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVuIGNoZWNrIGludm9jYXRpb25fcGFyYW1zIGZvciBtb2RlbCBpbmZvXG4gICAgICAgICAgICBpZiAobWV0YWRhdGEuaW52b2NhdGlvbl9wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZvY2F0aW9uUGFyYW1zID0gbWV0YWRhdGEuaW52b2NhdGlvbl9wYXJhbXM7XG4gICAgICAgICAgICAgICAgaWYgKGludm9jYXRpb25QYXJhbXMubW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludm9jYXRpb25QYXJhbXMubW9kZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGludm9jYXRpb25QYXJhbXMubW9kZWxfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW52b2NhdGlvblBhcmFtcy5tb2RlbF9uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFNwYW5BdHRyaWJ1dGVzKHNwYW4sIHJ1bkluZm8sIG9wKSB7XG4gICAgICAgIGlmIChcInJ1bl90eXBlXCIgaW4gcnVuSW5mbyAmJiBydW5JbmZvLnJ1bl90eXBlKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuTEFOR1NNSVRIX1JVTl9UWVBFLCBydW5JbmZvLnJ1bl90eXBlKTtcbiAgICAgICAgICAgIC8vIFNldCBHZW5BSSBhdHRyaWJ1dGVzIGFjY29yZGluZyB0byBPVEVMIHNlbWFudGljIGNvbnZlbnRpb25zXG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb25OYW1lID0gZ2V0T3BlcmF0aW9uTmFtZShydW5JbmZvLnJ1bl90eXBlIHx8IFwiY2hhaW5cIik7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX09QRVJBVElPTl9OQU1FLCBvcGVyYXRpb25OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJuYW1lXCIgaW4gcnVuSW5mbyAmJiBydW5JbmZvLm5hbWUpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5MQU5HU01JVEhfTkFNRSwgcnVuSW5mby5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJzZXNzaW9uX2lkXCIgaW4gcnVuSW5mbyAmJiBydW5JbmZvLnNlc3Npb25faWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5MQU5HU01JVEhfU0VTU0lPTl9JRCwgcnVuSW5mby5zZXNzaW9uX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJzZXNzaW9uX25hbWVcIiBpbiBydW5JbmZvICYmIHJ1bkluZm8uc2Vzc2lvbl9uYW1lKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuTEFOR1NNSVRIX1NFU1NJT05fTkFNRSwgcnVuSW5mby5zZXNzaW9uX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBnZW5fYWkuc3lzdGVtXG4gICAgICAgIHRoaXMuc2V0R2VuQWlTeXN0ZW0oc3BhbiwgcnVuSW5mbyk7XG4gICAgICAgIC8vIFNldCBtb2RlbCBuYW1lIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSB0aGlzLmV4dHJhY3RNb2RlbE5hbWUocnVuSW5mbyk7XG4gICAgICAgIGlmIChtb2RlbE5hbWUpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9NT0RFTCwgbW9kZWxOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdG9rZW4gdXNhZ2UgaW5mb3JtYXRpb25cbiAgICAgICAgaWYgKFwicHJvbXB0X3Rva2Vuc1wiIGluIHJ1bkluZm8gJiZcbiAgICAgICAgICAgIHR5cGVvZiBydW5JbmZvLnByb21wdF90b2tlbnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5TLCBydW5JbmZvLnByb21wdF90b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImNvbXBsZXRpb25fdG9rZW5zXCIgaW4gcnVuSW5mbyAmJlxuICAgICAgICAgICAgdHlwZW9mIHJ1bkluZm8uY29tcGxldGlvbl90b2tlbnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfT1VUUFVUX1RPS0VOUywgcnVuSW5mby5jb21wbGV0aW9uX3Rva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwidG90YWxfdG9rZW5zXCIgaW4gcnVuSW5mbyAmJiB0eXBlb2YgcnVuSW5mby50b3RhbF90b2tlbnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfVE9UQUxfVE9LRU5TLCBydW5JbmZvLnRvdGFsX3Rva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG90aGVyIHBhcmFtZXRlcnMgZnJvbSBpbnZvY2F0aW9uX3BhcmFtc1xuICAgICAgICB0aGlzLnNldEludm9jYXRpb25QYXJhbWV0ZXJzKHNwYW4sIHJ1bkluZm8pO1xuICAgICAgICAvLyBTZXQgbWV0YWRhdGEgYW5kIHRhZ3MgaWYgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gcnVuSW5mby5leHRyYT8ubWV0YWRhdGEgfHwge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1ldGFkYXRhKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShgJHtjb25zdGFudHMuTEFOR1NNSVRIX01FVEFEQVRBfS4ke2tleX1gLCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWdzID0gcnVuSW5mby50YWdzO1xuICAgICAgICBpZiAodGFncyAmJiBBcnJheS5pc0FycmF5KHRhZ3MpKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuTEFOR1NNSVRIX1RBR1MsIHRhZ3Muam9pbihcIiwgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YWdzKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuTEFOR1NNSVRIX1RBR1MsIFN0cmluZyh0YWdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3VwcG9ydCBhZGRpdGlvbmFsIHNlcmlhbGl6ZWQgYXR0cmlidXRlcywgaWYgcHJlc2VudFxuICAgICAgICBpZiAoXCJzZXJpYWxpemVkXCIgaW4gcnVuSW5mbyAmJiB0eXBlb2YgcnVuSW5mby5zZXJpYWxpemVkID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gcnVuSW5mby5zZXJpYWxpemVkO1xuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWQubmFtZSkge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfU0VSSUFMSVpFRF9OQU1FLCBTdHJpbmcoc2VyaWFsaXplZC5uYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZC5zaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1NFUklBTElaRURfU0lHTkFUVVJFLCBTdHJpbmcoc2VyaWFsaXplZC5zaWduYXR1cmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVkLmRvYykge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfU0VSSUFMSVpFRF9ET0MsIFN0cmluZyhzZXJpYWxpemVkLmRvYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBpbnB1dHMvb3V0cHV0cyBpZiBhdmFpbGFibGVcbiAgICAgICAgdGhpcy5zZXRJT0F0dHJpYnV0ZXMoc3Bhbiwgb3ApO1xuICAgIH1cbiAgICBzZXRHZW5BaVN5c3RlbShzcGFuLCBydW5JbmZvKSB7XG4gICAgICAgIC8vIERlZmF1bHQgdG8gXCJsYW5nY2hhaW5cIiBpZiB3ZSBjYW4ndCBkZXRlcm1pbmUgdGhlIHN5c3RlbVxuICAgICAgICBsZXQgc3lzdGVtID0gXCJsYW5nY2hhaW5cIjtcbiAgICAgICAgLy8gRXh0cmFjdCBtb2RlbCBuYW1lIHRvIGRldGVybWluZSB0aGUgc3lzdGVtXG4gICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHRoaXMuZXh0cmFjdE1vZGVsTmFtZShydW5JbmZvKTtcbiAgICAgICAgaWYgKG1vZGVsTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxMb3dlciA9IG1vZGVsTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJhbnRocm9waWNcIikgfHwgbW9kZWxMb3dlci5zdGFydHNXaXRoKFwiY2xhdWRlXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJhbnRocm9waWNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJiZWRyb2NrXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJhd3MuYmVkcm9ja1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcImF6dXJlXCIpICYmXG4gICAgICAgICAgICAgICAgbW9kZWxMb3dlci5pbmNsdWRlcyhcIm9wZW5haVwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiYXouYWkub3BlbmFpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiYXp1cmVcIikgJiZcbiAgICAgICAgICAgICAgICBtb2RlbExvd2VyLmluY2x1ZGVzKFwiaW5mZXJlbmNlXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJhei5haS5pbmZlcmVuY2VcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJjb2hlcmVcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImNvaGVyZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcImRlZXBzZWVrXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJkZWVwc2Vla1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcImdlbWluaVwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiZ2VtaW5pXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiZ3JvcVwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiZ3JvcVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcIndhdHNvblwiKSB8fCBtb2RlbExvd2VyLmluY2x1ZGVzKFwiaWJtXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJpYm0ud2F0c29ueC5haVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcIm1pc3RyYWxcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcIm1pc3RyYWxfYWlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJncHRcIikgfHwgbW9kZWxMb3dlci5pbmNsdWRlcyhcIm9wZW5haVwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwib3BlbmFpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwicGVycGxleGl0eVwiKSB8fFxuICAgICAgICAgICAgICAgIG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJzb25hclwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwicGVycGxleGl0eVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcInZlcnRleFwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwidmVydGV4X2FpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwieGFpXCIpIHx8IG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJncm9rXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJ4YWlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1NZU1RFTSwgc3lzdGVtKTtcbiAgICB9XG4gICAgc2V0SW52b2NhdGlvblBhcmFtZXRlcnMoc3BhbiwgcnVuSW5mbykge1xuICAgICAgICBpZiAoIXJ1bkluZm8uZXh0cmE/Lm1ldGFkYXRhPy5pbnZvY2F0aW9uX3BhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludm9jYXRpb25QYXJhbXMgPSBydW5JbmZvLmV4dHJhLm1ldGFkYXRhLmludm9jYXRpb25fcGFyYW1zO1xuICAgICAgICAvLyBTZXQgcmVsZXZhbnQgaW52b2NhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgIGlmIChpbnZvY2F0aW9uUGFyYW1zLm1heF90b2tlbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVFVRVNUX01BWF9UT0tFTlMsIGludm9jYXRpb25QYXJhbXMubWF4X3Rva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludm9jYXRpb25QYXJhbXMudGVtcGVyYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVFVRVNUX1RFTVBFUkFUVVJFLCBpbnZvY2F0aW9uUGFyYW1zLnRlbXBlcmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52b2NhdGlvblBhcmFtcy50b3BfcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfVE9QX1AsIGludm9jYXRpb25QYXJhbXMudG9wX3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnZvY2F0aW9uUGFyYW1zLmZyZXF1ZW5jeV9wZW5hbHR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9GUkVRVUVOQ1lfUEVOQUxUWSwgaW52b2NhdGlvblBhcmFtcy5mcmVxdWVuY3lfcGVuYWx0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludm9jYXRpb25QYXJhbXMucHJlc2VuY2VfcGVuYWx0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfUFJFU0VOQ0VfUEVOQUxUWSwgaW52b2NhdGlvblBhcmFtcy5wcmVzZW5jZV9wZW5hbHR5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRJT0F0dHJpYnV0ZXMoc3Bhbiwgb3ApIHtcbiAgICAgICAgaWYgKG9wLnJ1bi5pbnB1dHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gb3AucnVuLmlucHV0cztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0cyA9PT0gXCJvYmplY3RcIiAmJiBpbnB1dHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cy5tb2RlbCAmJiBBcnJheS5pc0FycmF5KGlucHV0cy5tZXNzYWdlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9NT0RFTCwgaW5wdXRzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYWRkaXRpb25hbCByZXF1ZXN0IGF0dHJpYnV0ZXMgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMuc3RyZWFtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5MQU5HU01JVEhfUkVRVUVTVF9TVFJFQU1JTkcsIGlucHV0cy5zdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMuZXh0cmFfaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9SRVFVRVNUX0hFQURFUlMsIEpTT04uc3RyaW5naWZ5KGlucHV0cy5leHRyYV9oZWFkZXJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cy5leHRyYV9xdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVFVRVNUX0VYVFJBX1FVRVJZLCBKU09OLnN0cmluZ2lmeShpbnB1dHMuZXh0cmFfcXVlcnkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmV4dHJhX2JvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9FWFRSQV9CT0RZLCBKU09OLnN0cmluZ2lmeShpbnB1dHMuZXh0cmFfYm9keSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5BSV9QUk9NUFQsIEpTT04uc3RyaW5naWZ5KGlucHV0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBGYWlsZWQgdG8gcHJvY2VzcyBpbnB1dHMgZm9yIHJ1biAke29wLmlkfWAsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5ydW4ub3V0cHV0cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gb3AucnVuLm91dHB1dHM7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0b2tlbiB1c2FnZSBmcm9tIG91dHB1dHMgKGZvciBMTE0gcnVucylcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblVzYWdlID0gdGhpcy5nZXRVbmlmaWVkUnVuVG9rZW5zKG91dHB1dHMpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblVzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5TLCB0b2tlblVzYWdlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9VU0FHRV9PVVRQVVRfVE9LRU5TLCB0b2tlblVzYWdlWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9VU0FHRV9UT1RBTF9UT0tFTlMsIHRva2VuVXNhZ2VbMF0gKyB0b2tlblVzYWdlWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dHMgJiYgdHlwZW9mIG91dHB1dHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dHMubW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVTUE9OU0VfTU9ERUwsIFN0cmluZyhvdXRwdXRzLm1vZGVsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBhZGRpdGlvbmFsIHJlc3BvbnNlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dHMuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVTUE9OU0VfSUQsIG91dHB1dHMuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzLmNob2ljZXMgJiYgQXJyYXkuaXNBcnJheShvdXRwdXRzLmNob2ljZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5pc2hSZWFzb25zID0gb3V0cHV0cy5jaG9pY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChjaG9pY2UpID0+IGNob2ljZS5maW5pc2hfcmVhc29uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigocmVhc29uKSA9PiByZWFzb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaFJlYXNvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVTUE9OU0VfRklOSVNIX1JFQVNPTlMsIGZpbmlzaFJlYXNvbnMuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0cy5zZXJ2aWNlX3RpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVTUE9OU0VfU0VSVklDRV9USUVSLCBvdXRwdXRzLnNlcnZpY2VfdGllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dHMuc3lzdGVtX2ZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFU1BPTlNFX1NZU1RFTV9GSU5HRVJQUklOVCwgb3V0cHV0cy5zeXN0ZW1fZmluZ2VycHJpbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzLnVzYWdlX21ldGFkYXRhICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3V0cHV0cy51c2FnZV9tZXRhZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNhZ2VNZXRhZGF0YSA9IG91dHB1dHMudXNhZ2VfbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNhZ2VNZXRhZGF0YS5pbnB1dF90b2tlbl9kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9VU0FHRV9JTlBVVF9UT0tFTl9ERVRBSUxTLCBKU09OLnN0cmluZ2lmeSh1c2FnZU1ldGFkYXRhLmlucHV0X3Rva2VuX2RldGFpbHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2FnZU1ldGFkYXRhLm91dHB1dF90b2tlbl9kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9VU0FHRV9PVVRQVVRfVE9LRU5fREVUQUlMUywgSlNPTi5zdHJpbmdpZnkodXNhZ2VNZXRhZGF0YS5vdXRwdXRfdG9rZW5fZGV0YWlscykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5BSV9DT01QTEVUSU9OLCBKU09OLnN0cmluZ2lmeShvdXRwdXRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYEZhaWxlZCB0byBwcm9jZXNzIG91dHB1dHMgZm9yIHJ1biAke29wLmlkfWAsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZ2V0VW5pZmllZFJ1blRva2VucyhvdXRwdXRzKSB7XG4gICAgICAgIGlmICghb3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VhcmNoIGluIG5vbi1nZW5lcmF0aW9ucyBsaXN0c1xuICAgICAgICBsZXQgdG9rZW5Vc2FnZSA9IHRoaXMuZXh0cmFjdFVuaWZpZWRSdW5Ub2tlbnMob3V0cHV0cy51c2FnZV9tZXRhZGF0YSk7XG4gICAgICAgIGlmICh0b2tlblVzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5Vc2FnZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIGlmIGRpcmVjdCBrd2FyZyBpbiBvdXRwdXRzXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvdXRwdXRzKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgY29uc3QgaGF5c3RhY2sgPSBvdXRwdXRzW2tleV07XG4gICAgICAgICAgICBpZiAoIWhheXN0YWNrIHx8IHR5cGVvZiBoYXlzdGFjayAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW5Vc2FnZSA9IHRoaXMuZXh0cmFjdFVuaWZpZWRSdW5Ub2tlbnMoaGF5c3RhY2sudXNhZ2VfbWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHRva2VuVXNhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5Vc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXlzdGFjay5sYyA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIGhheXN0YWNrLmt3YXJncyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBoYXlzdGFjay5rd2FyZ3MgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0b2tlblVzYWdlID0gdGhpcy5leHRyYWN0VW5pZmllZFJ1blRva2VucyhoYXlzdGFjay5rd2FyZ3MudXNhZ2VfbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblVzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlblVzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIGluIGdlbmVyYXRpb25zXG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gb3V0cHV0cy5nZW5lcmF0aW9ucyB8fCBbXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGdlbmVyYXRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhdEdlbmVyYXRpb25zID0gQXJyYXkuaXNBcnJheShnZW5lcmF0aW9uc1swXSlcbiAgICAgICAgICAgID8gZ2VuZXJhdGlvbnMuZmxhdCgpXG4gICAgICAgICAgICA6IGdlbmVyYXRpb25zO1xuICAgICAgICBmb3IgKGNvbnN0IGdlbmVyYXRpb24gb2YgZmxhdEdlbmVyYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGdlbmVyYXRpb24gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uLm1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZ2VuZXJhdGlvbi5tZXNzYWdlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbi5tZXNzYWdlLmt3YXJncyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBnZW5lcmF0aW9uLm1lc3NhZ2Uua3dhcmdzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5Vc2FnZSA9IHRoaXMuZXh0cmFjdFVuaWZpZWRSdW5Ub2tlbnMoZ2VuZXJhdGlvbi5tZXNzYWdlLmt3YXJncy51c2FnZV9tZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuVXNhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuVXNhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGV4dHJhY3RVbmlmaWVkUnVuVG9rZW5zKG91dHB1dHMpIHtcbiAgICAgICAgaWYgKCFvdXRwdXRzIHx8IHR5cGVvZiBvdXRwdXRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG91dHB1dHMuaW5wdXRfdG9rZW5zICE9PSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICB0eXBlb2Ygb3V0cHV0cy5vdXRwdXRfdG9rZW5zICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW291dHB1dHMuaW5wdXRfdG9rZW5zLCBvdXRwdXRzLm91dHB1dF90b2tlbnNdO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/experimental/otel/translator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/langsmith/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cache: () => (/* reexport safe */ _utils_prompts_cache_js__WEBPACK_IMPORTED_MODULE_5__.Cache),\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),\n/* harmony export */   __version__: () => (/* binding */ __version__),\n/* harmony export */   getDefaultProjectName: () => (/* reexport safe */ _utils_project_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultProjectName),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__.overrideFetchImplementation),\n/* harmony export */   uuid7: () => (/* reexport safe */ _uuid_js__WEBPACK_IMPORTED_MODULE_4__.uuid7),\n/* harmony export */   uuid7FromTime: () => (/* reexport safe */ _uuid_js__WEBPACK_IMPORTED_MODULE_4__.uuid7FromTime)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(ssr)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ \"(ssr)/./node_modules/langsmith/dist/run_trees.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(ssr)/./node_modules/langsmith/dist/singletons/fetch.js\");\n/* harmony import */ var _utils_project_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/project.js */ \"(ssr)/./node_modules/langsmith/dist/utils/project.js\");\n/* harmony import */ var _uuid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./uuid.js */ \"(ssr)/./node_modules/langsmith/dist/uuid.js\");\n/* harmony import */ var _utils_prompts_cache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/prompts_cache.js */ \"(ssr)/./node_modules/langsmith/dist/utils/prompts_cache.js\");\n\n\n\n\n\n\n// Update using yarn bump-version\nconst __version__ = \"0.4.5\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0M7QUFDRztBQUMyQjtBQUNUO0FBQ1Y7QUFDQztBQUNsRDtBQUNPIiwic291cmNlcyI6WyIvVXNlcnMvYXZlcnkvdGVzdDIvYWdlbnQtY2hhdC11aS9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQ2xpZW50LCB9IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuZXhwb3J0IHsgUnVuVHJlZSB9IGZyb20gXCIuL3J1bl90cmVlcy5qc1wiO1xuZXhwb3J0IHsgb3ZlcnJpZGVGZXRjaEltcGxlbWVudGF0aW9uIH0gZnJvbSBcIi4vc2luZ2xldG9ucy9mZXRjaC5qc1wiO1xuZXhwb3J0IHsgZ2V0RGVmYXVsdFByb2plY3ROYW1lIH0gZnJvbSBcIi4vdXRpbHMvcHJvamVjdC5qc1wiO1xuZXhwb3J0IHsgdXVpZDcsIHV1aWQ3RnJvbVRpbWUgfSBmcm9tIFwiLi91dWlkLmpzXCI7XG5leHBvcnQgeyBDYWNoZSwgfSBmcm9tIFwiLi91dGlscy9wcm9tcHRzX2NhY2hlLmpzXCI7XG4vLyBVcGRhdGUgdXNpbmcgeWFybiBidW1wLXZlcnNpb25cbmV4cG9ydCBjb25zdCBfX3ZlcnNpb25fXyA9IFwiMC40LjVcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/run_trees.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* binding */ RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* binding */ isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* binding */ isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(ssr)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ \"(ssr)/./node_modules/langsmith/dist/env.js\");\n/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/error.js */ \"(ssr)/./node_modules/langsmith/dist/utils/error.js\");\n/* harmony import */ var _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./singletons/constants.js */ \"(ssr)/./node_modules/langsmith/dist/singletons/constants.js\");\n/* harmony import */ var _utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/context_vars.js */ \"(ssr)/./node_modules/langsmith/dist/utils/context_vars.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/env.js */ \"(ssr)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _utils_project_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/project.js */ \"(ssr)/./node_modules/langsmith/dist/utils/project.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/warn.js */ \"(ssr)/./node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(ssr)/./node_modules/langsmith/dist/utils/_uuid.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v5.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst TIMESTAMP_LENGTH = 36;\n// DNS namespace for UUID v5 (same as Python's uuid.NAMESPACE_DNS)\nconst UUID_NAMESPACE_DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\nfunction getReplicaKey(replica) {\n    // Generate a unique key by hashing the replica's identifying properties\n    // This ensures each unique replica (combination of projectName, apiUrl, workspaceId, apiKey) gets a unique key\n    // Sort keys to ensure consistent hashing\n    const sortedKeys = Object.keys(replica).sort();\n    const keyData = sortedKeys\n        .map((key) => `${key}:${replica[key] ?? \"\"}`)\n        .join(\"|\");\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(keyData, UUID_NAMESPACE_DNS);\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction getMicrosecondPrecisionDatestring(epoch, executionOrder = 1) {\n    // Date only has millisecond precision, so we use the microseconds to break\n    // possible ties, avoiding incorrect run order\n    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n    return `${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`;\n}\nfunction convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {\n    const microsecondPrecisionDatestring = getMicrosecondPrecisionDatestring(epoch, executionOrder);\n    return {\n        dottedOrder: stripNonAlphanumeric(microsecondPrecisionDatestring) + runId,\n        microsecondPrecisionDatestring,\n    };\n}\n/**\n * Baggage header information\n */\nclass Baggage {\n    constructor(metadata, tags, project_name, replicas) {\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.metadata = metadata;\n        this.tags = tags;\n        this.project_name = project_name;\n        this.replicas = replicas;\n    }\n    static fromHeader(value) {\n        const items = value.split(\",\");\n        let metadata = {};\n        let tags = [];\n        let project_name;\n        let replicas;\n        for (const item of items) {\n            const [key, uriValue] = item.split(\"=\");\n            const value = decodeURIComponent(uriValue);\n            if (key === \"langsmith-metadata\") {\n                metadata = JSON.parse(value);\n            }\n            else if (key === \"langsmith-tags\") {\n                tags = value.split(\",\");\n            }\n            else if (key === \"langsmith-project\") {\n                project_name = value;\n            }\n            else if (key === \"langsmith-replicas\") {\n                replicas = JSON.parse(value);\n            }\n        }\n        return new Baggage(metadata, tags, project_name, replicas);\n    }\n    toHeader() {\n        const items = [];\n        if (this.metadata && Object.keys(this.metadata).length > 0) {\n            items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);\n        }\n        if (this.tags && this.tags.length > 0) {\n            items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(\",\"))}`);\n        }\n        if (this.project_name) {\n            items.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);\n        }\n        return items.join(\",\");\n    }\n}\nclass RunTree {\n    constructor(originalConfig) {\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingEnabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Attachments associated with the run.\n         * Each entry is a tuple of [mime_type, bytes]\n         */\n        Object.defineProperty(this, \"attachments\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Projects to replicate this run to with optional updates.\n         */\n        Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"distributedParentId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * @interface\n         */\n        Object.defineProperty(this, \"_serialized_start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * @internal\n         */\n        Object.defineProperty(this, \"_awaitInputsOnPost\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If you pass in a run tree directly, return a shallow clone\n        if (isRunTree(originalConfig)) {\n            Object.assign(this, { ...originalConfig });\n            return;\n        }\n        const defaultConfig = RunTree.getDefaultConfig();\n        const { metadata, ...config } = originalConfig;\n        const client = config.client ?? RunTree.getSharedClient();\n        const dedupedMetadata = {\n            ...metadata,\n            ...config?.extra?.metadata,\n        };\n        config.extra = { ...config.extra, metadata: dedupedMetadata };\n        if (\"id\" in config && config.id == null) {\n            delete config.id;\n        }\n        Object.assign(this, { ...defaultConfig, ...config, client });\n        this.execution_order ??= 1;\n        this.child_execution_order ??= 1;\n        // Generate serialized start time for ID generation\n        if (!this.dotted_order) {\n            this._serialized_start_time = getMicrosecondPrecisionDatestring(this.start_time, this.execution_order);\n        }\n        // Generate id from serialized start_time if not provided\n        if (!this.id) {\n            this.id = (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_8__.uuid7FromTime)(this._serialized_start_time ?? this.start_time);\n        }\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id ?? this.id;\n            }\n            else {\n                this.trace_id = this.id;\n            }\n        }\n        this.replicas = _ensureWriteReplicas(this.replicas);\n        // Now set the dotted order with the actual ID\n        if (!this.dotted_order) {\n            const { dottedOrder } = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);\n            if (this.parent_run) {\n                this.dotted_order = this.parent_run.dotted_order + \".\" + dottedOrder;\n            }\n            else {\n                this.dotted_order = dottedOrder;\n            }\n        }\n    }\n    set metadata(metadata) {\n        this.extra = {\n            ...this.extra,\n            metadata: {\n                ...this.extra?.metadata,\n                ...metadata,\n            },\n        };\n    }\n    get metadata() {\n        return this.extra?.metadata;\n    }\n    static getDefaultConfig() {\n        const start_time = Date.now();\n        return {\n            run_type: \"chain\",\n            project_name: (0,_utils_project_js__WEBPACK_IMPORTED_MODULE_6__.getDefaultProjectName)(),\n            child_runs: [],\n            api_url: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time,\n            serialized: {},\n            inputs: {},\n            extra: {},\n        };\n    }\n    static getSharedClient() {\n        if (!RunTree.sharedClient) {\n            RunTree.sharedClient = new _client_js__WEBPACK_IMPORTED_MODULE_0__.Client();\n        }\n        return RunTree.sharedClient;\n    }\n    createChild(config) {\n        const child_execution_order = this.child_execution_order + 1;\n        // Handle replicas: if child has its own replicas, use those; otherwise inherit parent's (with reroot stripped)\n        // Reroot should only apply to the run where it's explicitly configured, not propagate down\n        const inheritedReplicas = this.replicas?.map((replica) => {\n            const { reroot, ...rest } = replica;\n            return rest;\n        });\n        const childReplicas = config.replicas ?? inheritedReplicas;\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            replicas: childReplicas,\n            client: this.client,\n            tracingEnabled: this.tracingEnabled,\n            execution_order: child_execution_order,\n            child_execution_order: child_execution_order,\n        });\n        // Copy context vars over into the new run tree.\n        if (_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY in this) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            child[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY] =\n                this[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY];\n        }\n        const LC_CHILD = Symbol.for(\"lc:child_config\");\n        const presentConfig = config.extra?.[LC_CHILD] ??\n            this.extra[LC_CHILD];\n        // tracing for LangChain is defined by the _parentRunId and runMap of the tracer\n        if (isRunnableConfigLike(presentConfig)) {\n            const newConfig = { ...presentConfig };\n            const callbacks = isCallbackManagerLike(newConfig.callbacks)\n                ? newConfig.callbacks.copy?.()\n                : undefined;\n            if (callbacks) {\n                // update the parent run id\n                Object.assign(callbacks, { _parentRunId: child.id });\n                // only populate if we're in a newer LC.JS version\n                callbacks.handlers\n                    ?.find(isLangChainTracerLike)\n                    ?.updateFromRunTree?.(child);\n                newConfig.callbacks = callbacks;\n            }\n            child.extra[LC_CHILD] = newConfig;\n        }\n        // propagate child_execution_order upwards\n        const visited = new Set();\n        let current = this;\n        while (current != null && !visited.has(current.id)) {\n            visited.add(current.id);\n            current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);\n            current = current.parent_run;\n        }\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now(), metadata) {\n        this.outputs = this.outputs ?? outputs;\n        this.error = this.error ?? error;\n        this.end_time = this.end_time ?? endTime;\n        if (metadata && Object.keys(metadata).length > 0) {\n            this.extra = this.extra\n                ? { ...this.extra, metadata: { ...this.extra.metadata, ...metadata } }\n                : { metadata };\n        }\n    }\n    _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        // Avoid overwriting the runtime environment if it's already set\n        if (runExtra?.runtime?.library === undefined) {\n            if (!runExtra.runtime) {\n                runExtra.runtime = {};\n            }\n            if (runtimeEnv) {\n                for (const [k, v] of Object.entries(runtimeEnv)) {\n                    if (!runExtra.runtime[k]) {\n                        runExtra.runtime[k] = v;\n                    }\n                }\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));\n            parent_run_id = undefined;\n        }\n        else {\n            parent_run_id = run.parent_run?.id ?? run.parent_run_id;\n            child_runs = [];\n        }\n        return {\n            id: run.id,\n            name: run.name,\n            start_time: run._serialized_start_time ?? run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            tags: run.tags,\n            attachments: run.attachments,\n            events: run.events,\n        };\n    }\n    _sliceParentId(parentId, run) {\n        /**\n         * Slice the parent id from dotted order.\n         * Additionally check if the current run is a child of the parent. If so, update\n         * the parent_run_id to undefined, and set the trace id to the new root id after\n         * parent_id.\n         */\n        if (run.dotted_order) {\n            const segs = run.dotted_order.split(\".\");\n            let startIdx = null;\n            // Find the index of the parent ID in the dotted order\n            for (let idx = 0; idx < segs.length; idx++) {\n                const segId = segs[idx].slice(-TIMESTAMP_LENGTH);\n                if (segId === parentId) {\n                    startIdx = idx;\n                    break;\n                }\n            }\n            if (startIdx !== null) {\n                // Trim segments to start after parent_id (exclusive)\n                const trimmedSegs = segs.slice(startIdx + 1);\n                // Rebuild dotted_order\n                run.dotted_order = trimmedSegs.join(\".\");\n                if (trimmedSegs.length > 0) {\n                    run.trace_id = trimmedSegs[0].slice(-TIMESTAMP_LENGTH);\n                }\n                else {\n                    run.trace_id = run.id;\n                }\n            }\n        }\n        if (run.parent_run_id === parentId) {\n            // We've found the new root node.\n            run.parent_run_id = undefined;\n        }\n    }\n    _setReplicaTraceRoot(replicaKey, traceRootId) {\n        // Set the replica trace root in context vars on this run and all descendants\n        const replicaTraceRoots = (0,_utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__.getContextVar)(this, _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._REPLICA_TRACE_ROOTS_KEY) ?? {};\n        replicaTraceRoots[replicaKey] = traceRootId;\n        (0,_utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__.setContextVar)(this, _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._REPLICA_TRACE_ROOTS_KEY, replicaTraceRoots);\n        // Recursively update all descendants to avoid race conditions\n        // around run tree creation vs processing time\n        for (const child of this.child_runs) {\n            child._setReplicaTraceRoot(replicaKey, traceRootId);\n        }\n    }\n    _remapForProject(params) {\n        const { projectName, runtimeEnv, excludeChildRuns = true, reroot = false, distributedParentId, apiUrl, apiKey, workspaceId, } = params;\n        const baseRun = this._convertToCreate(this, runtimeEnv, excludeChildRuns);\n        // Skip remapping if project name is the same\n        if (projectName === this.project_name) {\n            return {\n                ...baseRun,\n                session_name: projectName,\n            };\n        }\n        // Apply reroot logic before ID remapping\n        if (reroot) {\n            if (distributedParentId) {\n                // If we have a distributed parent ID, slice at that point\n                this._sliceParentId(distributedParentId, baseRun);\n            }\n            else {\n                // If no distributed parent ID, simply make this run a root run\n                // by removing parent_run_id and resetting trace info\n                baseRun.parent_run_id = undefined;\n                // Keep the current run as the trace root\n                if (baseRun.dotted_order) {\n                    // Reset dotted order to just this run\n                    const segs = baseRun.dotted_order.split(\".\");\n                    if (segs.length > 0) {\n                        baseRun.dotted_order = segs[segs.length - 1];\n                        baseRun.trace_id = baseRun.id;\n                    }\n                }\n            }\n            // Store this run's original ID in context vars so descendants know the new trace root\n            // We store the original ID (before remapping) so it can be found in dotted_order\n            const replicaKey = getReplicaKey({\n                projectName,\n                apiUrl,\n                apiKey,\n                workspaceId,\n            });\n            this._setReplicaTraceRoot(replicaKey, baseRun.id);\n        }\n        // If an ancestor was rerooted for this replica, update trace_id and dotted_order\n        // to reflect the new trace hierarchy. This is tracked via context variables.\n        let ancestorRerootedTraceId;\n        if (!reroot) {\n            const replicaTraceRoots = (0,_utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__.getContextVar)(this, _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._REPLICA_TRACE_ROOTS_KEY) ?? {};\n            const replicaKey = getReplicaKey({\n                projectName,\n                apiUrl,\n                apiKey,\n                workspaceId,\n            });\n            ancestorRerootedTraceId = replicaTraceRoots[replicaKey];\n            if (ancestorRerootedTraceId) {\n                // An ancestor was rerooted for this replica, so set our trace_id\n                // to the ancestor's original (unmapped) ID. It will be remapped along with other IDs.\n                baseRun.trace_id = ancestorRerootedTraceId;\n                // Also slice the dotted_order to start from the new trace root\n                // This ensures descendants of a rerooted ancestor have correct hierarchy\n                if (baseRun.dotted_order) {\n                    const segs = baseRun.dotted_order.split(\".\");\n                    let rootIdx = null;\n                    // Find the new trace root's segment in dotted_order\n                    for (let idx = 0; idx < segs.length; idx++) {\n                        const segId = segs[idx].slice(-TIMESTAMP_LENGTH);\n                        if (segId === ancestorRerootedTraceId) {\n                            rootIdx = idx;\n                            break;\n                        }\n                    }\n                    if (rootIdx !== null) {\n                        // Keep segments from new trace root onwards\n                        const trimmedSegs = segs.slice(rootIdx);\n                        baseRun.dotted_order = trimmedSegs.join(\".\");\n                    }\n                }\n            }\n        }\n        // Remap IDs for the replica using uuid5 (deterministic)\n        // This ensures consistency across runs in the same replica\n        const oldId = baseRun.id;\n        const newId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${oldId}:${projectName}`, UUID_NAMESPACE_DNS);\n        // Remap trace_id\n        let newTraceId;\n        if (baseRun.trace_id) {\n            newTraceId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${baseRun.trace_id}:${projectName}`, UUID_NAMESPACE_DNS);\n        }\n        else {\n            newTraceId = newId;\n        }\n        // Remap parent_run_id\n        let newParentId;\n        if (baseRun.parent_run_id) {\n            newParentId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${baseRun.parent_run_id}:${projectName}`, UUID_NAMESPACE_DNS);\n        }\n        // Remap dotted_order segments\n        let newDottedOrder;\n        if (baseRun.dotted_order) {\n            const segs = baseRun.dotted_order.split(\".\");\n            const remappedSegs = segs.map((seg) => {\n                // Extract the UUID from the segment (last TIMESTAMP_LENGTH characters)\n                const segId = seg.slice(-TIMESTAMP_LENGTH);\n                const remappedId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${segId}:${projectName}`, UUID_NAMESPACE_DNS);\n                // Replace the UUID part while keeping the timestamp prefix\n                return seg.slice(0, -TIMESTAMP_LENGTH) + remappedId;\n            });\n            newDottedOrder = remappedSegs.join(\".\");\n        }\n        return {\n            ...baseRun,\n            id: newId,\n            trace_id: newTraceId,\n            parent_run_id: newParentId,\n            dotted_order: newDottedOrder,\n            session_name: projectName,\n        };\n    }\n    async postRun(excludeChildRuns = true) {\n        // Applies when `processInputs` is an async function\n        if (this._awaitInputsOnPost) {\n            this.inputs = await this.inputs;\n        }\n        try {\n            const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getRuntimeEnvironment)();\n            if (this.replicas && this.replicas.length > 0) {\n                for (const { projectName, apiKey, apiUrl, workspaceId, reroot } of this\n                    .replicas) {\n                    const runCreate = this._remapForProject({\n                        projectName: projectName ?? this.project_name,\n                        runtimeEnv,\n                        excludeChildRuns: true,\n                        reroot,\n                        distributedParentId: this.distributedParentId,\n                        apiUrl,\n                        apiKey,\n                        workspaceId,\n                    });\n                    await this.client.createRun(runCreate, {\n                        apiKey,\n                        apiUrl,\n                        workspaceId,\n                    });\n                }\n            }\n            else {\n                const runCreate = this._convertToCreate(this, runtimeEnv, excludeChildRuns);\n                await this.client.createRun(runCreate);\n            }\n            if (!excludeChildRuns) {\n                (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_7__.warnOnce)(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n                for (const childRun of this.child_runs) {\n                    await childRun.postRun(false);\n                }\n            }\n            this.child_runs = [];\n        }\n        catch (error) {\n            console.error(`Error in postRun for run ${this.id}:`, error);\n        }\n    }\n    async patchRun(options) {\n        if (this.replicas && this.replicas.length > 0) {\n            for (const { projectName, apiKey, apiUrl, workspaceId, updates, reroot, } of this.replicas) {\n                const runData = this._remapForProject({\n                    projectName: projectName ?? this.project_name,\n                    runtimeEnv: undefined,\n                    excludeChildRuns: true,\n                    reroot,\n                    distributedParentId: this.distributedParentId,\n                    apiUrl,\n                    apiKey,\n                    workspaceId,\n                });\n                const updatePayload = {\n                    id: runData.id,\n                    name: runData.name,\n                    run_type: runData.run_type,\n                    start_time: runData.start_time,\n                    outputs: runData.outputs,\n                    error: runData.error,\n                    parent_run_id: runData.parent_run_id,\n                    session_name: runData.session_name,\n                    reference_example_id: runData.reference_example_id,\n                    end_time: runData.end_time,\n                    dotted_order: runData.dotted_order,\n                    trace_id: runData.trace_id,\n                    events: runData.events,\n                    tags: runData.tags,\n                    extra: runData.extra,\n                    attachments: this.attachments,\n                    ...updates,\n                };\n                // Important that inputs is not a key in the run update\n                // if excluded because it will overwrite the run create if the\n                // two operations are merged during batching\n                if (!options?.excludeInputs) {\n                    updatePayload.inputs = runData.inputs;\n                }\n                await this.client.updateRun(runData.id, updatePayload, {\n                    apiKey,\n                    apiUrl,\n                    workspaceId,\n                });\n            }\n        }\n        else {\n            try {\n                const runUpdate = {\n                    name: this.name,\n                    run_type: this.run_type,\n                    start_time: this._serialized_start_time ?? this.start_time,\n                    end_time: this.end_time,\n                    error: this.error,\n                    outputs: this.outputs,\n                    parent_run_id: this.parent_run?.id ?? this.parent_run_id,\n                    reference_example_id: this.reference_example_id,\n                    extra: this.extra,\n                    events: this.events,\n                    dotted_order: this.dotted_order,\n                    trace_id: this.trace_id,\n                    tags: this.tags,\n                    attachments: this.attachments,\n                    session_name: this.project_name,\n                };\n                // Important that inputs is not a key in the run update\n                // if excluded because it will overwrite the run create if the\n                // two operations are merged during batching\n                if (!options?.excludeInputs) {\n                    runUpdate.inputs = this.inputs;\n                }\n                await this.client.updateRun(this.id, runUpdate);\n            }\n            catch (error) {\n                console.error(`Error in patchRun for run ${this.id}`, error);\n            }\n        }\n        this.child_runs = [];\n    }\n    toJSON() {\n        return this._convertToCreate(this, undefined, false);\n    }\n    /**\n     * Add an event to the run tree.\n     * @param event - A single event or string to add\n     */\n    addEvent(event) {\n        if (!this.events) {\n            this.events = [];\n        }\n        if (typeof event === \"string\") {\n            this.events.push({\n                name: \"event\",\n                time: new Date().toISOString(),\n                message: event,\n            });\n        }\n        else {\n            this.events.push({\n                ...event,\n                time: event.time ?? new Date().toISOString(),\n            });\n        }\n    }\n    static fromRunnableConfig(parentConfig, props) {\n        // We only handle the callback manager case for now\n        const callbackManager = parentConfig?.callbacks;\n        let parentRun;\n        let projectName;\n        let client;\n        let tracingEnabled = (0,_env_js__WEBPACK_IMPORTED_MODULE_1__.isTracingEnabled)();\n        if (callbackManager) {\n            const parentRunId = callbackManager?.getParentRunId?.() ?? \"\";\n            const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name == \"langchain_tracer\");\n            parentRun = langChainTracer?.getRun?.(parentRunId);\n            projectName = langChainTracer?.projectName;\n            client = langChainTracer?.client;\n            tracingEnabled = tracingEnabled || !!langChainTracer;\n        }\n        if (!parentRun) {\n            return new RunTree({\n                ...props,\n                client,\n                tracingEnabled,\n                project_name: projectName,\n            });\n        }\n        const parentRunTree = new RunTree({\n            name: parentRun.name,\n            id: parentRun.id,\n            trace_id: parentRun.trace_id,\n            dotted_order: parentRun.dotted_order,\n            client,\n            tracingEnabled,\n            project_name: projectName,\n            tags: [\n                ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? [])),\n            ],\n            extra: {\n                metadata: {\n                    ...parentRun?.extra?.metadata,\n                    ...parentConfig?.metadata,\n                },\n            },\n        });\n        return parentRunTree.createChild(props);\n    }\n    static fromDottedOrder(dottedOrder) {\n        return this.fromHeaders({ \"langsmith-trace\": dottedOrder });\n    }\n    static fromHeaders(headers, inheritArgs) {\n        const rawHeaders = \"get\" in headers && typeof headers.get === \"function\"\n            ? {\n                \"langsmith-trace\": headers.get(\"langsmith-trace\"),\n                baggage: headers.get(\"baggage\"),\n            }\n            : headers;\n        const headerTrace = rawHeaders[\"langsmith-trace\"];\n        if (!headerTrace || typeof headerTrace !== \"string\")\n            return undefined;\n        const parentDottedOrder = headerTrace.trim();\n        const parsedDottedOrder = parentDottedOrder.split(\".\").map((part) => {\n            const [strTime, uuid] = part.split(\"Z\");\n            return { strTime, time: Date.parse(strTime + \"Z\"), uuid };\n        });\n        const traceId = parsedDottedOrder[0].uuid;\n        const config = {\n            ...inheritArgs,\n            name: inheritArgs?.[\"name\"] ?? \"parent\",\n            run_type: inheritArgs?.[\"run_type\"] ?? \"chain\",\n            start_time: inheritArgs?.[\"start_time\"] ?? Date.now(),\n            id: parsedDottedOrder.at(-1)?.uuid,\n            trace_id: traceId,\n            dotted_order: parentDottedOrder,\n        };\n        if (rawHeaders[\"baggage\"] && typeof rawHeaders[\"baggage\"] === \"string\") {\n            const baggage = Baggage.fromHeader(rawHeaders[\"baggage\"]);\n            config.metadata = baggage.metadata;\n            config.tags = baggage.tags;\n            config.project_name = baggage.project_name;\n            config.replicas = baggage.replicas;\n        }\n        const runTree = new RunTree(config);\n        // Set the distributed parent ID to this run's ID for rerooting\n        runTree.distributedParentId = runTree.id;\n        return runTree;\n    }\n    toHeaders(headers) {\n        const result = {\n            \"langsmith-trace\": this.dotted_order,\n            baggage: new Baggage(this.extra?.metadata, this.tags, this.project_name, this.replicas).toHeader(),\n        };\n        if (headers) {\n            for (const [key, value] of Object.entries(result)) {\n                headers.set(key, value);\n            }\n        }\n        return result;\n    }\n}\nObject.defineProperty(RunTree, \"sharedClient\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: null\n});\nfunction isRunTree(x) {\n    return (x != null &&\n        typeof x.createChild === \"function\" &&\n        typeof x.postRun === \"function\");\n}\nfunction isLangChainTracerLike(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        typeof x.name === \"string\" &&\n        x.name === \"langchain_tracer\");\n}\nfunction containsLangChainTracerLike(x) {\n    return (Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback)));\n}\nfunction isCallbackManagerLike(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        Array.isArray(x.handlers));\n}\nfunction isRunnableConfigLike(x) {\n    // Check that it's an object with a callbacks arg\n    // that has either a CallbackManagerLike object with a langchain tracer within it\n    // or an array with a LangChainTracerLike object within it\n    const callbacks = x?.callbacks;\n    return (x != null &&\n        typeof callbacks === \"object\" &&\n        // Callback manager with a langchain tracer\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (containsLangChainTracerLike(callbacks?.handlers) ||\n            // Or it's an array with a LangChainTracerLike object within it\n            containsLangChainTracerLike(callbacks)));\n}\nfunction _getWriteReplicasFromEnv() {\n    const envVar = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getEnvironmentVariable)(\"LANGSMITH_RUNS_ENDPOINTS\");\n    if (!envVar)\n        return [];\n    try {\n        const parsed = JSON.parse(envVar);\n        if (Array.isArray(parsed)) {\n            const replicas = [];\n            for (const item of parsed) {\n                if (typeof item !== \"object\" || item === null) {\n                    console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: ` +\n                        `expected object, got ${typeof item}`);\n                    continue;\n                }\n                if (typeof item.api_url !== \"string\") {\n                    console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: ` +\n                        `expected string, got ${typeof item.api_url}`);\n                    continue;\n                }\n                if (typeof item.api_key !== \"string\") {\n                    console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: ` +\n                        `expected string, got ${typeof item.api_key}`);\n                    continue;\n                }\n                replicas.push({\n                    apiUrl: item.api_url.replace(/\\/$/, \"\"),\n                    apiKey: item.api_key,\n                });\n            }\n            return replicas;\n        }\n        else if (typeof parsed === \"object\" && parsed !== null) {\n            _checkEndpointEnvUnset(parsed);\n            const replicas = [];\n            for (const [url, key] of Object.entries(parsed)) {\n                const cleanUrl = url.replace(/\\/$/, \"\");\n                if (typeof key === \"string\") {\n                    replicas.push({\n                        apiUrl: cleanUrl,\n                        apiKey: key,\n                    });\n                }\n                else {\n                    console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${url}: ` +\n                        `expected string, got ${typeof key}`);\n                    continue;\n                }\n            }\n            return replicas;\n        }\n        else {\n            console.warn(\"Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of \" +\n                `objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof parsed}`);\n            return [];\n        }\n    }\n    catch (e) {\n        if ((0,_utils_error_js__WEBPACK_IMPORTED_MODULE_2__.isConflictingEndpointsError)(e)) {\n            throw e;\n        }\n        console.warn(\"Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of \" +\n            \"objects with api_url and api_key properties, or object mapping url->apiKey\");\n        return [];\n    }\n}\nfunction _ensureWriteReplicas(replicas) {\n    // If null -> fetch from env\n    if (replicas) {\n        return replicas.map((replica) => {\n            if (Array.isArray(replica)) {\n                return {\n                    projectName: replica[0],\n                    updates: replica[1],\n                };\n            }\n            return replica;\n        });\n    }\n    return _getWriteReplicasFromEnv();\n}\nfunction _checkEndpointEnvUnset(parsed) {\n    if (Object.keys(parsed).length > 0 &&\n        (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getLangSmithEnvironmentVariable)(\"ENDPOINT\")) {\n        throw new _utils_error_js__WEBPACK_IMPORTED_MODULE_2__.ConflictingEndpointsError();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ087QUFDK0M7QUFDTTtBQUMxQjtBQUNTO0FBQ3JCO0FBQ007QUFDdEI7QUFDTTtBQUNiO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJLEdBQUcsbUJBQW1CO0FBQ25EO0FBQ0EsV0FBVyxnREFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkMsRUFBRSxZQUFZO0FBQ3ZFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtEQUFrRDtBQUMvRjtBQUNBO0FBQ0EseUNBQXlDLHdDQUF3QztBQUNqRjtBQUNBO0FBQ0EsNENBQTRDLHNDQUFzQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNU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QUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhFQUErQjtBQUN2QyxrQkFBa0Isc0VBQXlCO0FBQzNDO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9ydW5fdHJlZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4vY2xpZW50LmpzXCI7XG5pbXBvcnQgeyBpc1RyYWNpbmdFbmFibGVkIH0gZnJvbSBcIi4vZW52LmpzXCI7XG5pbXBvcnQgeyBpc0NvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IsIENvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IsIH0gZnJvbSBcIi4vdXRpbHMvZXJyb3IuanNcIjtcbmltcG9ydCB7IF9MQ19DT05URVhUX1ZBUklBQkxFU19LRVksIF9SRVBMSUNBX1RSQUNFX1JPT1RTX0tFWSwgfSBmcm9tIFwiLi9zaW5nbGV0b25zL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q29udGV4dFZhciwgc2V0Q29udGV4dFZhciB9IGZyb20gXCIuL3V0aWxzL2NvbnRleHRfdmFycy5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0UnVudGltZUVudmlyb25tZW50LCB9IGZyb20gXCIuL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFByb2plY3ROYW1lIH0gZnJvbSBcIi4vdXRpbHMvcHJvamVjdC5qc1wiO1xuaW1wb3J0IHsgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tIFwiLi91dGlscy93YXJuLmpzXCI7XG5pbXBvcnQgeyB1dWlkN0Zyb21UaW1lIH0gZnJvbSBcIi4vdXRpbHMvX3V1aWQuanNcIjtcbmltcG9ydCB7IHY1IGFzIHV1aWR2NSB9IGZyb20gXCJ1dWlkXCI7XG5jb25zdCBUSU1FU1RBTVBfTEVOR1RIID0gMzY7XG4vLyBETlMgbmFtZXNwYWNlIGZvciBVVUlEIHY1IChzYW1lIGFzIFB5dGhvbidzIHV1aWQuTkFNRVNQQUNFX0ROUylcbmNvbnN0IFVVSURfTkFNRVNQQUNFX0ROUyA9IFwiNmJhN2I4MTAtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4XCI7XG5mdW5jdGlvbiBnZXRSZXBsaWNhS2V5KHJlcGxpY2EpIHtcbiAgICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBrZXkgYnkgaGFzaGluZyB0aGUgcmVwbGljYSdzIGlkZW50aWZ5aW5nIHByb3BlcnRpZXNcbiAgICAvLyBUaGlzIGVuc3VyZXMgZWFjaCB1bmlxdWUgcmVwbGljYSAoY29tYmluYXRpb24gb2YgcHJvamVjdE5hbWUsIGFwaVVybCwgd29ya3NwYWNlSWQsIGFwaUtleSkgZ2V0cyBhIHVuaXF1ZSBrZXlcbiAgICAvLyBTb3J0IGtleXMgdG8gZW5zdXJlIGNvbnNpc3RlbnQgaGFzaGluZ1xuICAgIGNvbnN0IHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyhyZXBsaWNhKS5zb3J0KCk7XG4gICAgY29uc3Qga2V5RGF0YSA9IHNvcnRlZEtleXNcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBgJHtrZXl9OiR7cmVwbGljYVtrZXldID8/IFwiXCJ9YClcbiAgICAgICAgLmpvaW4oXCJ8XCIpO1xuICAgIHJldHVybiB1dWlkdjUoa2V5RGF0YSwgVVVJRF9OQU1FU1BBQ0VfRE5TKTtcbn1cbmZ1bmN0aW9uIHN0cmlwTm9uQWxwaGFudW1lcmljKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1stOi5dL2csIFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0TWljcm9zZWNvbmRQcmVjaXNpb25EYXRlc3RyaW5nKGVwb2NoLCBleGVjdXRpb25PcmRlciA9IDEpIHtcbiAgICAvLyBEYXRlIG9ubHkgaGFzIG1pbGxpc2Vjb25kIHByZWNpc2lvbiwgc28gd2UgdXNlIHRoZSBtaWNyb3NlY29uZHMgdG8gYnJlYWtcbiAgICAvLyBwb3NzaWJsZSB0aWVzLCBhdm9pZGluZyBpbmNvcnJlY3QgcnVuIG9yZGVyXG4gICAgY29uc3QgcGFkZGVkT3JkZXIgPSBleGVjdXRpb25PcmRlci50b0ZpeGVkKDApLnNsaWNlKDAsIDMpLnBhZFN0YXJ0KDMsIFwiMFwiKTtcbiAgICByZXR1cm4gYCR7bmV3IERhdGUoZXBvY2gpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgLTEpfSR7cGFkZGVkT3JkZXJ9WmA7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQoZXBvY2gsIHJ1bklkLCBleGVjdXRpb25PcmRlciA9IDEpIHtcbiAgICBjb25zdCBtaWNyb3NlY29uZFByZWNpc2lvbkRhdGVzdHJpbmcgPSBnZXRNaWNyb3NlY29uZFByZWNpc2lvbkRhdGVzdHJpbmcoZXBvY2gsIGV4ZWN1dGlvbk9yZGVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkb3R0ZWRPcmRlcjogc3RyaXBOb25BbHBoYW51bWVyaWMobWljcm9zZWNvbmRQcmVjaXNpb25EYXRlc3RyaW5nKSArIHJ1bklkLFxuICAgICAgICBtaWNyb3NlY29uZFByZWNpc2lvbkRhdGVzdHJpbmcsXG4gICAgfTtcbn1cbi8qKlxuICogQmFnZ2FnZSBoZWFkZXIgaW5mb3JtYXRpb25cbiAqL1xuY2xhc3MgQmFnZ2FnZSB7XG4gICAgY29uc3RydWN0b3IobWV0YWRhdGEsIHRhZ3MsIHByb2plY3RfbmFtZSwgcmVwbGljYXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0X25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVwbGljYXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICB0aGlzLnByb2plY3RfbmFtZSA9IHByb2plY3RfbmFtZTtcbiAgICAgICAgdGhpcy5yZXBsaWNhcyA9IHJlcGxpY2FzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhlYWRlcih2YWx1ZSkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhID0ge307XG4gICAgICAgIGxldCB0YWdzID0gW107XG4gICAgICAgIGxldCBwcm9qZWN0X25hbWU7XG4gICAgICAgIGxldCByZXBsaWNhcztcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB1cmlWYWx1ZV0gPSBpdGVtLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHVyaVZhbHVlKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwibGFuZ3NtaXRoLW1ldGFkYXRhXCIpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImxhbmdzbWl0aC10YWdzXCIpIHtcbiAgICAgICAgICAgICAgICB0YWdzID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImxhbmdzbWl0aC1wcm9qZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0X25hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJsYW5nc21pdGgtcmVwbGljYXNcIikge1xuICAgICAgICAgICAgICAgIHJlcGxpY2FzID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCYWdnYWdlKG1ldGFkYXRhLCB0YWdzLCBwcm9qZWN0X25hbWUsIHJlcGxpY2FzKTtcbiAgICB9XG4gICAgdG9IZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhICYmIE9iamVjdC5rZXlzKHRoaXMubWV0YWRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYGxhbmdzbWl0aC1tZXRhZGF0YT0ke2VuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh0aGlzLm1ldGFkYXRhKSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGFncyAmJiB0aGlzLnRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChgbGFuZ3NtaXRoLXRhZ3M9JHtlbmNvZGVVUklDb21wb25lbnQodGhpcy50YWdzLmpvaW4oXCIsXCIpKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9qZWN0X25hbWUpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYGxhbmdzbWl0aC1wcm9qZWN0PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMucHJvamVjdF9uYW1lKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXMuam9pbihcIixcIik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJ1blRyZWUge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuX3R5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvamVjdF9uYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcmVudF9ydW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyZW50X3J1bl9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGlsZF9ydW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXJ0X3RpbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5kX3RpbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXh0cmFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcnJvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXJpYWxpemVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlucHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRwdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZmVyZW5jZV9leGFtcGxlX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsaWVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhY2VfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG90dGVkX29yZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNpbmdFbmFibGVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4ZWN1dGlvbl9vcmRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGlsZF9leGVjdXRpb25fb3JkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGFjaG1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcnVuLlxuICAgICAgICAgKiBFYWNoIGVudHJ5IGlzIGEgdHVwbGUgb2YgW21pbWVfdHlwZSwgYnl0ZXNdXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdHRhY2htZW50c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvamVjdHMgdG8gcmVwbGljYXRlIHRoaXMgcnVuIHRvIHdpdGggb3B0aW9uYWwgdXBkYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcGxpY2FzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRpc3RyaWJ1dGVkUGFyZW50SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcmZhY2VcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zZXJpYWxpemVkX3N0YXJ0X3RpbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2F3YWl0SW5wdXRzT25Qb3N0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHlvdSBwYXNzIGluIGEgcnVuIHRyZWUgZGlyZWN0bHksIHJldHVybiBhIHNoYWxsb3cgY2xvbmVcbiAgICAgICAgaWYgKGlzUnVuVHJlZShvcmlnaW5hbENvbmZpZykpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyAuLi5vcmlnaW5hbENvbmZpZyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gUnVuVHJlZS5nZXREZWZhdWx0Q29uZmlnKCk7XG4gICAgICAgIGNvbnN0IHsgbWV0YWRhdGEsIC4uLmNvbmZpZyB9ID0gb3JpZ2luYWxDb25maWc7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGNvbmZpZy5jbGllbnQgPz8gUnVuVHJlZS5nZXRTaGFyZWRDbGllbnQoKTtcbiAgICAgICAgY29uc3QgZGVkdXBlZE1ldGFkYXRhID0ge1xuICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5jb25maWc/LmV4dHJhPy5tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uZmlnLmV4dHJhID0geyAuLi5jb25maWcuZXh0cmEsIG1ldGFkYXRhOiBkZWR1cGVkTWV0YWRhdGEgfTtcbiAgICAgICAgaWYgKFwiaWRcIiBpbiBjb25maWcgJiYgY29uZmlnLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IC4uLmRlZmF1bHRDb25maWcsIC4uLmNvbmZpZywgY2xpZW50IH0pO1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbl9vcmRlciA/Pz0gMTtcbiAgICAgICAgdGhpcy5jaGlsZF9leGVjdXRpb25fb3JkZXIgPz89IDE7XG4gICAgICAgIC8vIEdlbmVyYXRlIHNlcmlhbGl6ZWQgc3RhcnQgdGltZSBmb3IgSUQgZ2VuZXJhdGlvblxuICAgICAgICBpZiAoIXRoaXMuZG90dGVkX29yZGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJpYWxpemVkX3N0YXJ0X3RpbWUgPSBnZXRNaWNyb3NlY29uZFByZWNpc2lvbkRhdGVzdHJpbmcodGhpcy5zdGFydF90aW1lLCB0aGlzLmV4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2VuZXJhdGUgaWQgZnJvbSBzZXJpYWxpemVkIHN0YXJ0X3RpbWUgaWYgbm90IHByb3ZpZGVkXG4gICAgICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHV1aWQ3RnJvbVRpbWUodGhpcy5fc2VyaWFsaXplZF9zdGFydF90aW1lID8/IHRoaXMuc3RhcnRfdGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRyYWNlX2lkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRfcnVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZV9pZCA9IHRoaXMucGFyZW50X3J1bi50cmFjZV9pZCA/PyB0aGlzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZV9pZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBsaWNhcyA9IF9lbnN1cmVXcml0ZVJlcGxpY2FzKHRoaXMucmVwbGljYXMpO1xuICAgICAgICAvLyBOb3cgc2V0IHRoZSBkb3R0ZWQgb3JkZXIgd2l0aCB0aGUgYWN0dWFsIElEXG4gICAgICAgIGlmICghdGhpcy5kb3R0ZWRfb3JkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG90dGVkT3JkZXIgfSA9IGNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0KHRoaXMuc3RhcnRfdGltZSwgdGhpcy5pZCwgdGhpcy5leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMuZG90dGVkX29yZGVyID0gdGhpcy5wYXJlbnRfcnVuLmRvdHRlZF9vcmRlciArIFwiLlwiICsgZG90dGVkT3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdHRlZF9vcmRlciA9IGRvdHRlZE9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBtZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmV4dHJhID0ge1xuICAgICAgICAgICAgLi4udGhpcy5leHRyYSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5leHRyYT8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhPy5tZXRhZGF0YTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnVuX3R5cGU6IFwiY2hhaW5cIixcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogZ2V0RGVmYXVsdFByb2plY3ROYW1lKCksXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGFwaV91cmw6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIikgPz8gXCJodHRwOi8vbG9jYWxob3N0OjE5ODRcIixcbiAgICAgICAgICAgIGFwaV9rZXk6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fQVBJX0tFWVwiKSxcbiAgICAgICAgICAgIGNhbGxlcl9vcHRpb25zOiB7fSxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB7fSxcbiAgICAgICAgICAgIGlucHV0czoge30sXG4gICAgICAgICAgICBleHRyYToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaGFyZWRDbGllbnQoKSB7XG4gICAgICAgIGlmICghUnVuVHJlZS5zaGFyZWRDbGllbnQpIHtcbiAgICAgICAgICAgIFJ1blRyZWUuc2hhcmVkQ2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSdW5UcmVlLnNoYXJlZENsaWVudDtcbiAgICB9XG4gICAgY3JlYXRlQ2hpbGQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IHRoaXMuY2hpbGRfZXhlY3V0aW9uX29yZGVyICsgMTtcbiAgICAgICAgLy8gSGFuZGxlIHJlcGxpY2FzOiBpZiBjaGlsZCBoYXMgaXRzIG93biByZXBsaWNhcywgdXNlIHRob3NlOyBvdGhlcndpc2UgaW5oZXJpdCBwYXJlbnQncyAod2l0aCByZXJvb3Qgc3RyaXBwZWQpXG4gICAgICAgIC8vIFJlcm9vdCBzaG91bGQgb25seSBhcHBseSB0byB0aGUgcnVuIHdoZXJlIGl0J3MgZXhwbGljaXRseSBjb25maWd1cmVkLCBub3QgcHJvcGFnYXRlIGRvd25cbiAgICAgICAgY29uc3QgaW5oZXJpdGVkUmVwbGljYXMgPSB0aGlzLnJlcGxpY2FzPy5tYXAoKHJlcGxpY2EpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVyb290LCAuLi5yZXN0IH0gPSByZXBsaWNhO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjaGlsZFJlcGxpY2FzID0gY29uZmlnLnJlcGxpY2FzID8/IGluaGVyaXRlZFJlcGxpY2FzO1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5ldyBSdW5UcmVlKHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIHBhcmVudF9ydW46IHRoaXMsXG4gICAgICAgICAgICBwcm9qZWN0X25hbWU6IHRoaXMucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgcmVwbGljYXM6IGNoaWxkUmVwbGljYXMsXG4gICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQ6IHRoaXMudHJhY2luZ0VuYWJsZWQsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXI6IGNoaWxkX2V4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogY2hpbGRfZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ29weSBjb250ZXh0IHZhcnMgb3ZlciBpbnRvIHRoZSBuZXcgcnVuIHRyZWUuXG4gICAgICAgIGlmIChfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIGluIHRoaXMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjaGlsZFtfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXSA9XG4gICAgICAgICAgICAgICAgdGhpc1tfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBMQ19DSElMRCA9IFN5bWJvbC5mb3IoXCJsYzpjaGlsZF9jb25maWdcIik7XG4gICAgICAgIGNvbnN0IHByZXNlbnRDb25maWcgPSBjb25maWcuZXh0cmE/LltMQ19DSElMRF0gPz9cbiAgICAgICAgICAgIHRoaXMuZXh0cmFbTENfQ0hJTERdO1xuICAgICAgICAvLyB0cmFjaW5nIGZvciBMYW5nQ2hhaW4gaXMgZGVmaW5lZCBieSB0aGUgX3BhcmVudFJ1bklkIGFuZCBydW5NYXAgb2YgdGhlIHRyYWNlclxuICAgICAgICBpZiAoaXNSdW5uYWJsZUNvbmZpZ0xpa2UocHJlc2VudENvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IHsgLi4ucHJlc2VudENvbmZpZyB9O1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gaXNDYWxsYmFja01hbmFnZXJMaWtlKG5ld0NvbmZpZy5jYWxsYmFja3MpXG4gICAgICAgICAgICAgICAgPyBuZXdDb25maWcuY2FsbGJhY2tzLmNvcHk/LigpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBwYXJlbnQgcnVuIGlkXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjYWxsYmFja3MsIHsgX3BhcmVudFJ1bklkOiBjaGlsZC5pZCB9KTtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHBvcHVsYXRlIGlmIHdlJ3JlIGluIGEgbmV3ZXIgTEMuSlMgdmVyc2lvblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5oYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICA/LmZpbmQoaXNMYW5nQ2hhaW5UcmFjZXJMaWtlKVxuICAgICAgICAgICAgICAgICAgICA/LnVwZGF0ZUZyb21SdW5UcmVlPy4oY2hpbGQpO1xuICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC5leHRyYVtMQ19DSElMRF0gPSBuZXdDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvcGFnYXRlIGNoaWxkX2V4ZWN1dGlvbl9vcmRlciB1cHdhcmRzXG4gICAgICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCAmJiAhdmlzaXRlZC5oYXMoY3VycmVudC5pZCkpIHtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnQuaWQpO1xuICAgICAgICAgICAgY3VycmVudC5jaGlsZF9leGVjdXRpb25fb3JkZXIgPSBNYXRoLm1heChjdXJyZW50LmNoaWxkX2V4ZWN1dGlvbl9vcmRlciwgY2hpbGRfZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudF9ydW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZF9ydW5zLnB1c2goY2hpbGQpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGFzeW5jIGVuZChvdXRwdXRzLCBlcnJvciwgZW5kVGltZSA9IERhdGUubm93KCksIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IHRoaXMub3V0cHV0cyA/PyBvdXRwdXRzO1xuICAgICAgICB0aGlzLmVycm9yID0gdGhpcy5lcnJvciA/PyBlcnJvcjtcbiAgICAgICAgdGhpcy5lbmRfdGltZSA9IHRoaXMuZW5kX3RpbWUgPz8gZW5kVGltZTtcbiAgICAgICAgaWYgKG1ldGFkYXRhICYmIE9iamVjdC5rZXlzKG1ldGFkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhID0gdGhpcy5leHRyYVxuICAgICAgICAgICAgICAgID8geyAuLi50aGlzLmV4dHJhLCBtZXRhZGF0YTogeyAuLi50aGlzLmV4dHJhLm1ldGFkYXRhLCAuLi5tZXRhZGF0YSB9IH1cbiAgICAgICAgICAgICAgICA6IHsgbWV0YWRhdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29udmVydFRvQ3JlYXRlKHJ1biwgcnVudGltZUVudiwgZXhjbHVkZUNoaWxkUnVucyA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgcnVuRXh0cmEgPSBydW4uZXh0cmEgPz8ge307XG4gICAgICAgIC8vIEF2b2lkIG92ZXJ3cml0aW5nIHRoZSBydW50aW1lIGVudmlyb25tZW50IGlmIGl0J3MgYWxyZWFkeSBzZXRcbiAgICAgICAgaWYgKHJ1bkV4dHJhPy5ydW50aW1lPy5saWJyYXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghcnVuRXh0cmEucnVudGltZSkge1xuICAgICAgICAgICAgICAgIHJ1bkV4dHJhLnJ1bnRpbWUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW50aW1lRW52KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMocnVudGltZUVudikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydW5FeHRyYS5ydW50aW1lW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5FeHRyYS5ydW50aW1lW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRfcnVucztcbiAgICAgICAgbGV0IHBhcmVudF9ydW5faWQ7XG4gICAgICAgIGlmICghZXhjbHVkZUNoaWxkUnVucykge1xuICAgICAgICAgICAgY2hpbGRfcnVucyA9IHJ1bi5jaGlsZF9ydW5zLm1hcCgoY2hpbGRfcnVuKSA9PiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUoY2hpbGRfcnVuLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zKSk7XG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50X3J1bl9pZCA9IHJ1bi5wYXJlbnRfcnVuPy5pZCA/PyBydW4ucGFyZW50X3J1bl9pZDtcbiAgICAgICAgICAgIGNoaWxkX3J1bnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuLl9zZXJpYWxpemVkX3N0YXJ0X3RpbWUgPz8gcnVuLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBlbmRfdGltZTogcnVuLmVuZF90aW1lLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlX2lkOiBydW4ucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICBleHRyYTogcnVuRXh0cmEsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBydW4uc2VyaWFsaXplZCxcbiAgICAgICAgICAgIGVycm9yOiBydW4uZXJyb3IsXG4gICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRzOiBydW4ub3V0cHV0cyxcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZTogcnVuLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IGNoaWxkX3J1bnMsXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRfcnVuX2lkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IHJ1bi50cmFjZV9pZCxcbiAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogcnVuLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzLFxuICAgICAgICAgICAgYXR0YWNobWVudHM6IHJ1bi5hdHRhY2htZW50cyxcbiAgICAgICAgICAgIGV2ZW50czogcnVuLmV2ZW50cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3NsaWNlUGFyZW50SWQocGFyZW50SWQsIHJ1bikge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2xpY2UgdGhlIHBhcmVudCBpZCBmcm9tIGRvdHRlZCBvcmRlci5cbiAgICAgICAgICogQWRkaXRpb25hbGx5IGNoZWNrIGlmIHRoZSBjdXJyZW50IHJ1biBpcyBhIGNoaWxkIG9mIHRoZSBwYXJlbnQuIElmIHNvLCB1cGRhdGVcbiAgICAgICAgICogdGhlIHBhcmVudF9ydW5faWQgdG8gdW5kZWZpbmVkLCBhbmQgc2V0IHRoZSB0cmFjZSBpZCB0byB0aGUgbmV3IHJvb3QgaWQgYWZ0ZXJcbiAgICAgICAgICogcGFyZW50X2lkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJ1bi5kb3R0ZWRfb3JkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ3MgPSBydW4uZG90dGVkX29yZGVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIGxldCBzdGFydElkeCA9IG51bGw7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgcGFyZW50IElEIGluIHRoZSBkb3R0ZWQgb3JkZXJcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlZ3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ0lkID0gc2Vnc1tpZHhdLnNsaWNlKC1USU1FU1RBTVBfTEVOR1RIKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VnSWQgPT09IHBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SWR4ID0gaWR4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRJZHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmltIHNlZ21lbnRzIHRvIHN0YXJ0IGFmdGVyIHBhcmVudF9pZCAoZXhjbHVzaXZlKVxuICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRTZWdzID0gc2Vncy5zbGljZShzdGFydElkeCArIDEpO1xuICAgICAgICAgICAgICAgIC8vIFJlYnVpbGQgZG90dGVkX29yZGVyXG4gICAgICAgICAgICAgICAgcnVuLmRvdHRlZF9vcmRlciA9IHRyaW1tZWRTZWdzLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkU2Vncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bi50cmFjZV9pZCA9IHRyaW1tZWRTZWdzWzBdLnNsaWNlKC1USU1FU1RBTVBfTEVOR1RIKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bi50cmFjZV9pZCA9IHJ1bi5pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bi5wYXJlbnRfcnVuX2lkID09PSBwYXJlbnRJZCkge1xuICAgICAgICAgICAgLy8gV2UndmUgZm91bmQgdGhlIG5ldyByb290IG5vZGUuXG4gICAgICAgICAgICBydW4ucGFyZW50X3J1bl9pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2V0UmVwbGljYVRyYWNlUm9vdChyZXBsaWNhS2V5LCB0cmFjZVJvb3RJZCkge1xuICAgICAgICAvLyBTZXQgdGhlIHJlcGxpY2EgdHJhY2Ugcm9vdCBpbiBjb250ZXh0IHZhcnMgb24gdGhpcyBydW4gYW5kIGFsbCBkZXNjZW5kYW50c1xuICAgICAgICBjb25zdCByZXBsaWNhVHJhY2VSb290cyA9IGdldENvbnRleHRWYXIodGhpcywgX1JFUExJQ0FfVFJBQ0VfUk9PVFNfS0VZKSA/PyB7fTtcbiAgICAgICAgcmVwbGljYVRyYWNlUm9vdHNbcmVwbGljYUtleV0gPSB0cmFjZVJvb3RJZDtcbiAgICAgICAgc2V0Q29udGV4dFZhcih0aGlzLCBfUkVQTElDQV9UUkFDRV9ST09UU19LRVksIHJlcGxpY2FUcmFjZVJvb3RzKTtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgdXBkYXRlIGFsbCBkZXNjZW5kYW50cyB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgLy8gYXJvdW5kIHJ1biB0cmVlIGNyZWF0aW9uIHZzIHByb2Nlc3NpbmcgdGltZVxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRfcnVucykge1xuICAgICAgICAgICAgY2hpbGQuX3NldFJlcGxpY2FUcmFjZVJvb3QocmVwbGljYUtleSwgdHJhY2VSb290SWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZW1hcEZvclByb2plY3QocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdE5hbWUsIHJ1bnRpbWVFbnYsIGV4Y2x1ZGVDaGlsZFJ1bnMgPSB0cnVlLCByZXJvb3QgPSBmYWxzZSwgZGlzdHJpYnV0ZWRQYXJlbnRJZCwgYXBpVXJsLCBhcGlLZXksIHdvcmtzcGFjZUlkLCB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBiYXNlUnVuID0gdGhpcy5fY29udmVydFRvQ3JlYXRlKHRoaXMsIHJ1bnRpbWVFbnYsIGV4Y2x1ZGVDaGlsZFJ1bnMpO1xuICAgICAgICAvLyBTa2lwIHJlbWFwcGluZyBpZiBwcm9qZWN0IG5hbWUgaXMgdGhlIHNhbWVcbiAgICAgICAgaWYgKHByb2plY3ROYW1lID09PSB0aGlzLnByb2plY3RfbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlUnVuLFxuICAgICAgICAgICAgICAgIHNlc3Npb25fbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGx5IHJlcm9vdCBsb2dpYyBiZWZvcmUgSUQgcmVtYXBwaW5nXG4gICAgICAgIGlmIChyZXJvb3QpIHtcbiAgICAgICAgICAgIGlmIChkaXN0cmlidXRlZFBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGRpc3RyaWJ1dGVkIHBhcmVudCBJRCwgc2xpY2UgYXQgdGhhdCBwb2ludFxuICAgICAgICAgICAgICAgIHRoaXMuX3NsaWNlUGFyZW50SWQoZGlzdHJpYnV0ZWRQYXJlbnRJZCwgYmFzZVJ1bik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBkaXN0cmlidXRlZCBwYXJlbnQgSUQsIHNpbXBseSBtYWtlIHRoaXMgcnVuIGEgcm9vdCBydW5cbiAgICAgICAgICAgICAgICAvLyBieSByZW1vdmluZyBwYXJlbnRfcnVuX2lkIGFuZCByZXNldHRpbmcgdHJhY2UgaW5mb1xuICAgICAgICAgICAgICAgIGJhc2VSdW4ucGFyZW50X3J1bl9pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRoZSBjdXJyZW50IHJ1biBhcyB0aGUgdHJhY2Ugcm9vdFxuICAgICAgICAgICAgICAgIGlmIChiYXNlUnVuLmRvdHRlZF9vcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBkb3R0ZWQgb3JkZXIgdG8ganVzdCB0aGlzIHJ1blxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWdzID0gYmFzZVJ1bi5kb3R0ZWRfb3JkZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlUnVuLmRvdHRlZF9vcmRlciA9IHNlZ3Nbc2Vncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VSdW4udHJhY2VfaWQgPSBiYXNlUnVuLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcmUgdGhpcyBydW4ncyBvcmlnaW5hbCBJRCBpbiBjb250ZXh0IHZhcnMgc28gZGVzY2VuZGFudHMga25vdyB0aGUgbmV3IHRyYWNlIHJvb3RcbiAgICAgICAgICAgIC8vIFdlIHN0b3JlIHRoZSBvcmlnaW5hbCBJRCAoYmVmb3JlIHJlbWFwcGluZykgc28gaXQgY2FuIGJlIGZvdW5kIGluIGRvdHRlZF9vcmRlclxuICAgICAgICAgICAgY29uc3QgcmVwbGljYUtleSA9IGdldFJlcGxpY2FLZXkoe1xuICAgICAgICAgICAgICAgIHByb2plY3ROYW1lLFxuICAgICAgICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3NldFJlcGxpY2FUcmFjZVJvb3QocmVwbGljYUtleSwgYmFzZVJ1bi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYW4gYW5jZXN0b3Igd2FzIHJlcm9vdGVkIGZvciB0aGlzIHJlcGxpY2EsIHVwZGF0ZSB0cmFjZV9pZCBhbmQgZG90dGVkX29yZGVyXG4gICAgICAgIC8vIHRvIHJlZmxlY3QgdGhlIG5ldyB0cmFjZSBoaWVyYXJjaHkuIFRoaXMgaXMgdHJhY2tlZCB2aWEgY29udGV4dCB2YXJpYWJsZXMuXG4gICAgICAgIGxldCBhbmNlc3RvclJlcm9vdGVkVHJhY2VJZDtcbiAgICAgICAgaWYgKCFyZXJvb3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxpY2FUcmFjZVJvb3RzID0gZ2V0Q29udGV4dFZhcih0aGlzLCBfUkVQTElDQV9UUkFDRV9ST09UU19LRVkpID8/IHt9O1xuICAgICAgICAgICAgY29uc3QgcmVwbGljYUtleSA9IGdldFJlcGxpY2FLZXkoe1xuICAgICAgICAgICAgICAgIHByb2plY3ROYW1lLFxuICAgICAgICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFuY2VzdG9yUmVyb290ZWRUcmFjZUlkID0gcmVwbGljYVRyYWNlUm9vdHNbcmVwbGljYUtleV07XG4gICAgICAgICAgICBpZiAoYW5jZXN0b3JSZXJvb3RlZFRyYWNlSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBbiBhbmNlc3RvciB3YXMgcmVyb290ZWQgZm9yIHRoaXMgcmVwbGljYSwgc28gc2V0IG91ciB0cmFjZV9pZFxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBhbmNlc3RvcidzIG9yaWdpbmFsICh1bm1hcHBlZCkgSUQuIEl0IHdpbGwgYmUgcmVtYXBwZWQgYWxvbmcgd2l0aCBvdGhlciBJRHMuXG4gICAgICAgICAgICAgICAgYmFzZVJ1bi50cmFjZV9pZCA9IGFuY2VzdG9yUmVyb290ZWRUcmFjZUlkO1xuICAgICAgICAgICAgICAgIC8vIEFsc28gc2xpY2UgdGhlIGRvdHRlZF9vcmRlciB0byBzdGFydCBmcm9tIHRoZSBuZXcgdHJhY2Ugcm9vdFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyBkZXNjZW5kYW50cyBvZiBhIHJlcm9vdGVkIGFuY2VzdG9yIGhhdmUgY29ycmVjdCBoaWVyYXJjaHlcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVJ1bi5kb3R0ZWRfb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VncyA9IGJhc2VSdW4uZG90dGVkX29yZGVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvb3RJZHggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBuZXcgdHJhY2Ugcm9vdCdzIHNlZ21lbnQgaW4gZG90dGVkX29yZGVyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlZ3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VnSWQgPSBzZWdzW2lkeF0uc2xpY2UoLVRJTUVTVEFNUF9MRU5HVEgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ0lkID09PSBhbmNlc3RvclJlcm9vdGVkVHJhY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RJZHggPSBpZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3RJZHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgc2VnbWVudHMgZnJvbSBuZXcgdHJhY2Ugcm9vdCBvbndhcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkU2VncyA9IHNlZ3Muc2xpY2Uocm9vdElkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlUnVuLmRvdHRlZF9vcmRlciA9IHRyaW1tZWRTZWdzLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlbWFwIElEcyBmb3IgdGhlIHJlcGxpY2EgdXNpbmcgdXVpZDUgKGRldGVybWluaXN0aWMpXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyBjb25zaXN0ZW5jeSBhY3Jvc3MgcnVucyBpbiB0aGUgc2FtZSByZXBsaWNhXG4gICAgICAgIGNvbnN0IG9sZElkID0gYmFzZVJ1bi5pZDtcbiAgICAgICAgY29uc3QgbmV3SWQgPSB1dWlkdjUoYCR7b2xkSWR9OiR7cHJvamVjdE5hbWV9YCwgVVVJRF9OQU1FU1BBQ0VfRE5TKTtcbiAgICAgICAgLy8gUmVtYXAgdHJhY2VfaWRcbiAgICAgICAgbGV0IG5ld1RyYWNlSWQ7XG4gICAgICAgIGlmIChiYXNlUnVuLnRyYWNlX2lkKSB7XG4gICAgICAgICAgICBuZXdUcmFjZUlkID0gdXVpZHY1KGAke2Jhc2VSdW4udHJhY2VfaWR9OiR7cHJvamVjdE5hbWV9YCwgVVVJRF9OQU1FU1BBQ0VfRE5TKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1RyYWNlSWQgPSBuZXdJZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1hcCBwYXJlbnRfcnVuX2lkXG4gICAgICAgIGxldCBuZXdQYXJlbnRJZDtcbiAgICAgICAgaWYgKGJhc2VSdW4ucGFyZW50X3J1bl9pZCkge1xuICAgICAgICAgICAgbmV3UGFyZW50SWQgPSB1dWlkdjUoYCR7YmFzZVJ1bi5wYXJlbnRfcnVuX2lkfToke3Byb2plY3ROYW1lfWAsIFVVSURfTkFNRVNQQUNFX0ROUyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtYXAgZG90dGVkX29yZGVyIHNlZ21lbnRzXG4gICAgICAgIGxldCBuZXdEb3R0ZWRPcmRlcjtcbiAgICAgICAgaWYgKGJhc2VSdW4uZG90dGVkX29yZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdzID0gYmFzZVJ1bi5kb3R0ZWRfb3JkZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgY29uc3QgcmVtYXBwZWRTZWdzID0gc2Vncy5tYXAoKHNlZykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIFVVSUQgZnJvbSB0aGUgc2VnbWVudCAobGFzdCBUSU1FU1RBTVBfTEVOR1RIIGNoYXJhY3RlcnMpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnSWQgPSBzZWcuc2xpY2UoLVRJTUVTVEFNUF9MRU5HVEgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFwcGVkSWQgPSB1dWlkdjUoYCR7c2VnSWR9OiR7cHJvamVjdE5hbWV9YCwgVVVJRF9OQU1FU1BBQ0VfRE5TKTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBVVUlEIHBhcnQgd2hpbGUga2VlcGluZyB0aGUgdGltZXN0YW1wIHByZWZpeFxuICAgICAgICAgICAgICAgIHJldHVybiBzZWcuc2xpY2UoMCwgLVRJTUVTVEFNUF9MRU5HVEgpICsgcmVtYXBwZWRJZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3RG90dGVkT3JkZXIgPSByZW1hcHBlZFNlZ3Muam9pbihcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmJhc2VSdW4sXG4gICAgICAgICAgICBpZDogbmV3SWQsXG4gICAgICAgICAgICB0cmFjZV9pZDogbmV3VHJhY2VJZCxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IG5ld1BhcmVudElkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBuZXdEb3R0ZWRPcmRlcixcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHBvc3RSdW4oZXhjbHVkZUNoaWxkUnVucyA9IHRydWUpIHtcbiAgICAgICAgLy8gQXBwbGllcyB3aGVuIGBwcm9jZXNzSW5wdXRzYCBpcyBhbiBhc3luYyBmdW5jdGlvblxuICAgICAgICBpZiAodGhpcy5fYXdhaXRJbnB1dHNPblBvc3QpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzID0gYXdhaXQgdGhpcy5pbnB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcGxpY2FzICYmIHRoaXMucmVwbGljYXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBwcm9qZWN0TmFtZSwgYXBpS2V5LCBhcGlVcmwsIHdvcmtzcGFjZUlkLCByZXJvb3QgfSBvZiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsaWNhcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBydW5DcmVhdGUgPSB0aGlzLl9yZW1hcEZvclByb2plY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdE5hbWU6IHByb2plY3ROYW1lID8/IHRoaXMucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVudGltZUVudixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVDaGlsZFJ1bnM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0cmlidXRlZFBhcmVudElkOiB0aGlzLmRpc3RyaWJ1dGVkUGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jrc3BhY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZVJ1bihydW5DcmVhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtzcGFjZUlkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydW5DcmVhdGUgPSB0aGlzLl9jb252ZXJ0VG9DcmVhdGUodGhpcywgcnVudGltZUVudiwgZXhjbHVkZUNoaWxkUnVucyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY3JlYXRlUnVuKHJ1bkNyZWF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGVDaGlsZFJ1bnMpIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZShcIlBvc3Rpbmcgd2l0aCBleGNsdWRlQ2hpbGRSdW5zPWZhbHNlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkUnVuIG9mIHRoaXMuY2hpbGRfcnVucykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGlsZFJ1bi5wb3N0UnVuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoaWxkX3J1bnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHBvc3RSdW4gZm9yIHJ1biAke3RoaXMuaWR9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXRjaFJ1bihvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcGxpY2FzICYmIHRoaXMucmVwbGljYXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHByb2plY3ROYW1lLCBhcGlLZXksIGFwaVVybCwgd29ya3NwYWNlSWQsIHVwZGF0ZXMsIHJlcm9vdCwgfSBvZiB0aGlzLnJlcGxpY2FzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVuRGF0YSA9IHRoaXMuX3JlbWFwRm9yUHJvamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3ROYW1lOiBwcm9qZWN0TmFtZSA/PyB0aGlzLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcnVudGltZUVudjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlQ2hpbGRSdW5zOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZXJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGVkUGFyZW50SWQ6IHRoaXMuZGlzdHJpYnV0ZWRQYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsLFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgICAgICAgIHdvcmtzcGFjZUlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBydW5EYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBydW5EYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJ1bl90eXBlOiBydW5EYXRhLnJ1bl90eXBlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydF90aW1lOiBydW5EYXRhLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IHJ1bkRhdGEub3V0cHV0cyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJ1bkRhdGEuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHJ1bkRhdGEucGFyZW50X3J1bl9pZCxcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiBydW5EYXRhLnNlc3Npb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHJ1bkRhdGEucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICAgICAgICAgIGVuZF90aW1lOiBydW5EYXRhLmVuZF90aW1lLFxuICAgICAgICAgICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHJ1bkRhdGEuZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogcnVuRGF0YS50cmFjZV9pZCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBydW5EYXRhLmV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogcnVuRGF0YS50YWdzLFxuICAgICAgICAgICAgICAgICAgICBleHRyYTogcnVuRGF0YS5leHRyYSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IHRoaXMuYXR0YWNobWVudHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBJbXBvcnRhbnQgdGhhdCBpbnB1dHMgaXMgbm90IGEga2V5IGluIHRoZSBydW4gdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gaWYgZXhjbHVkZWQgYmVjYXVzZSBpdCB3aWxsIG92ZXJ3cml0ZSB0aGUgcnVuIGNyZWF0ZSBpZiB0aGVcbiAgICAgICAgICAgICAgICAvLyB0d28gb3BlcmF0aW9ucyBhcmUgbWVyZ2VkIGR1cmluZyBiYXRjaGluZ1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucz8uZXhjbHVkZUlucHV0cykge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVQYXlsb2FkLmlucHV0cyA9IHJ1bkRhdGEuaW5wdXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4ocnVuRGF0YS5pZCwgdXBkYXRlUGF5bG9hZCwge1xuICAgICAgICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICAgICAgICAgICAgd29ya3NwYWNlSWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1blVwZGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBydW5fdHlwZTogdGhpcy5ydW5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfdGltZTogdGhpcy5fc2VyaWFsaXplZF9zdGFydF90aW1lID8/IHRoaXMuc3RhcnRfdGltZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kX3RpbWU6IHRoaXMuZW5kX3RpbWUsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHRoaXMucGFyZW50X3J1bj8uaWQgPz8gdGhpcy5wYXJlbnRfcnVuX2lkLFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZV9pZDogdGhpcy5yZWZlcmVuY2VfZXhhbXBsZV9pZCxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHRoaXMuZXh0cmEsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogdGhpcy5ldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogdGhpcy5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlX2lkLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiB0aGlzLnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiB0aGlzLmF0dGFjaG1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uX25hbWU6IHRoaXMucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gSW1wb3J0YW50IHRoYXQgaW5wdXRzIGlzIG5vdCBhIGtleSBpbiB0aGUgcnVuIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGlmIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgd2lsbCBvdmVyd3JpdGUgdGhlIHJ1biBjcmVhdGUgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gdHdvIG9wZXJhdGlvbnMgYXJlIG1lcmdlZCBkdXJpbmcgYmF0Y2hpbmdcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnM/LmV4Y2x1ZGVJbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuVXBkYXRlLmlucHV0cyA9IHRoaXMuaW5wdXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4odGhpcy5pZCwgcnVuVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHBhdGNoUnVuIGZvciBydW4gJHt0aGlzLmlkfWAsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkX3J1bnMgPSBbXTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydFRvQ3JlYXRlKHRoaXMsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgdG8gdGhlIHJ1biB0cmVlLlxuICAgICAqIEBwYXJhbSBldmVudCAtIEEgc2luZ2xlIGV2ZW50IG9yIHN0cmluZyB0byBhZGRcbiAgICAgKi9cbiAgICBhZGRFdmVudChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXZlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIC4uLmV2ZW50LFxuICAgICAgICAgICAgICAgIHRpbWU6IGV2ZW50LnRpbWUgPz8gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21SdW5uYWJsZUNvbmZpZyhwYXJlbnRDb25maWcsIHByb3BzKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgaGFuZGxlIHRoZSBjYWxsYmFjayBtYW5hZ2VyIGNhc2UgZm9yIG5vd1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXIgPSBwYXJlbnRDb25maWc/LmNhbGxiYWNrcztcbiAgICAgICAgbGV0IHBhcmVudFJ1bjtcbiAgICAgICAgbGV0IHByb2plY3ROYW1lO1xuICAgICAgICBsZXQgY2xpZW50O1xuICAgICAgICBsZXQgdHJhY2luZ0VuYWJsZWQgPSBpc1RyYWNpbmdFbmFibGVkKCk7XG4gICAgICAgIGlmIChjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFJ1bklkID0gY2FsbGJhY2tNYW5hZ2VyPy5nZXRQYXJlbnRSdW5JZD8uKCkgPz8gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGxhbmdDaGFpblRyYWNlciA9IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlcnM/LmZpbmQoKGhhbmRsZXIpID0+IGhhbmRsZXI/Lm5hbWUgPT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpO1xuICAgICAgICAgICAgcGFyZW50UnVuID0gbGFuZ0NoYWluVHJhY2VyPy5nZXRSdW4/LihwYXJlbnRSdW5JZCk7XG4gICAgICAgICAgICBwcm9qZWN0TmFtZSA9IGxhbmdDaGFpblRyYWNlcj8ucHJvamVjdE5hbWU7XG4gICAgICAgICAgICBjbGllbnQgPSBsYW5nQ2hhaW5UcmFjZXI/LmNsaWVudDtcbiAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkID0gdHJhY2luZ0VuYWJsZWQgfHwgISFsYW5nQ2hhaW5UcmFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkLFxuICAgICAgICAgICAgICAgIHByb2plY3RfbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRSdW5UcmVlID0gbmV3IFJ1blRyZWUoe1xuICAgICAgICAgICAgbmFtZTogcGFyZW50UnVuLm5hbWUsXG4gICAgICAgICAgICBpZDogcGFyZW50UnVuLmlkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IHBhcmVudFJ1bi50cmFjZV9pZCxcbiAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogcGFyZW50UnVuLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBwcm9qZWN0TmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IFtcbiAgICAgICAgICAgICAgICAuLi5uZXcgU2V0KChwYXJlbnRSdW4/LnRhZ3MgPz8gW10pLmNvbmNhdChwYXJlbnRDb25maWc/LnRhZ3MgPz8gW10pKSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcmVudFJ1bj8uZXh0cmE/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAuLi5wYXJlbnRDb25maWc/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmVudFJ1blRyZWUuY3JlYXRlQ2hpbGQocHJvcHMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbURvdHRlZE9yZGVyKGRvdHRlZE9yZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21IZWFkZXJzKHsgXCJsYW5nc21pdGgtdHJhY2VcIjogZG90dGVkT3JkZXIgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGVhZGVycyhoZWFkZXJzLCBpbmhlcml0QXJncykge1xuICAgICAgICBjb25zdCByYXdIZWFkZXJzID0gXCJnZXRcIiBpbiBoZWFkZXJzICYmIHR5cGVvZiBoZWFkZXJzLmdldCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBcImxhbmdzbWl0aC10cmFjZVwiOiBoZWFkZXJzLmdldChcImxhbmdzbWl0aC10cmFjZVwiKSxcbiAgICAgICAgICAgICAgICBiYWdnYWdlOiBoZWFkZXJzLmdldChcImJhZ2dhZ2VcIiksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGhlYWRlclRyYWNlID0gcmF3SGVhZGVyc1tcImxhbmdzbWl0aC10cmFjZVwiXTtcbiAgICAgICAgaWYgKCFoZWFkZXJUcmFjZSB8fCB0eXBlb2YgaGVhZGVyVHJhY2UgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwYXJlbnREb3R0ZWRPcmRlciA9IGhlYWRlclRyYWNlLnRyaW0oKTtcbiAgICAgICAgY29uc3QgcGFyc2VkRG90dGVkT3JkZXIgPSBwYXJlbnREb3R0ZWRPcmRlci5zcGxpdChcIi5cIikubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbc3RyVGltZSwgdXVpZF0gPSBwYXJ0LnNwbGl0KFwiWlwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN0clRpbWUsIHRpbWU6IERhdGUucGFyc2Uoc3RyVGltZSArIFwiWlwiKSwgdXVpZCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHJhY2VJZCA9IHBhcnNlZERvdHRlZE9yZGVyWzBdLnV1aWQ7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLmluaGVyaXRBcmdzLFxuICAgICAgICAgICAgbmFtZTogaW5oZXJpdEFyZ3M/LltcIm5hbWVcIl0gPz8gXCJwYXJlbnRcIixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBpbmhlcml0QXJncz8uW1wicnVuX3R5cGVcIl0gPz8gXCJjaGFpblwiLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogaW5oZXJpdEFyZ3M/LltcInN0YXJ0X3RpbWVcIl0gPz8gRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGlkOiBwYXJzZWREb3R0ZWRPcmRlci5hdCgtMSk/LnV1aWQsXG4gICAgICAgICAgICB0cmFjZV9pZDogdHJhY2VJZCxcbiAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogcGFyZW50RG90dGVkT3JkZXIsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyYXdIZWFkZXJzW1wiYmFnZ2FnZVwiXSAmJiB0eXBlb2YgcmF3SGVhZGVyc1tcImJhZ2dhZ2VcIl0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhZ2dhZ2UgPSBCYWdnYWdlLmZyb21IZWFkZXIocmF3SGVhZGVyc1tcImJhZ2dhZ2VcIl0pO1xuICAgICAgICAgICAgY29uZmlnLm1ldGFkYXRhID0gYmFnZ2FnZS5tZXRhZGF0YTtcbiAgICAgICAgICAgIGNvbmZpZy50YWdzID0gYmFnZ2FnZS50YWdzO1xuICAgICAgICAgICAgY29uZmlnLnByb2plY3RfbmFtZSA9IGJhZ2dhZ2UucHJvamVjdF9uYW1lO1xuICAgICAgICAgICAgY29uZmlnLnJlcGxpY2FzID0gYmFnZ2FnZS5yZXBsaWNhcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5UcmVlID0gbmV3IFJ1blRyZWUoY29uZmlnKTtcbiAgICAgICAgLy8gU2V0IHRoZSBkaXN0cmlidXRlZCBwYXJlbnQgSUQgdG8gdGhpcyBydW4ncyBJRCBmb3IgcmVyb290aW5nXG4gICAgICAgIHJ1blRyZWUuZGlzdHJpYnV0ZWRQYXJlbnRJZCA9IHJ1blRyZWUuaWQ7XG4gICAgICAgIHJldHVybiBydW5UcmVlO1xuICAgIH1cbiAgICB0b0hlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBcImxhbmdzbWl0aC10cmFjZVwiOiB0aGlzLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgIGJhZ2dhZ2U6IG5ldyBCYWdnYWdlKHRoaXMuZXh0cmE/Lm1ldGFkYXRhLCB0aGlzLnRhZ3MsIHRoaXMucHJvamVjdF9uYW1lLCB0aGlzLnJlcGxpY2FzKS50b0hlYWRlcigpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1blRyZWUsIFwic2hhcmVkQ2xpZW50XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogbnVsbFxufSk7XG5leHBvcnQgZnVuY3Rpb24gaXNSdW5UcmVlKHgpIHtcbiAgICByZXR1cm4gKHggIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgeC5jcmVhdGVDaGlsZCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiB4LnBvc3RSdW4gPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBpc0xhbmdDaGFpblRyYWNlckxpa2UoeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgeCAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB4Lm5hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgeC5uYW1lID09PSBcImxhbmdjaGFpbl90cmFjZXJcIik7XG59XG5mdW5jdGlvbiBjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoeCkge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh4KSAmJiB4LnNvbWUoKGNhbGxiYWNrKSA9PiBpc0xhbmdDaGFpblRyYWNlckxpa2UoY2FsbGJhY2spKSk7XG59XG5mdW5jdGlvbiBpc0NhbGxiYWNrTWFuYWdlckxpa2UoeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgeCAhPSBudWxsICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoeC5oYW5kbGVycykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUnVubmFibGVDb25maWdMaWtlKHgpIHtcbiAgICAvLyBDaGVjayB0aGF0IGl0J3MgYW4gb2JqZWN0IHdpdGggYSBjYWxsYmFja3MgYXJnXG4gICAgLy8gdGhhdCBoYXMgZWl0aGVyIGEgQ2FsbGJhY2tNYW5hZ2VyTGlrZSBvYmplY3Qgd2l0aCBhIGxhbmdjaGFpbiB0cmFjZXIgd2l0aGluIGl0XG4gICAgLy8gb3IgYW4gYXJyYXkgd2l0aCBhIExhbmdDaGFpblRyYWNlckxpa2Ugb2JqZWN0IHdpdGhpbiBpdFxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHg/LmNhbGxiYWNrcztcbiAgICByZXR1cm4gKHggIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgY2FsbGJhY2tzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIC8vIENhbGxiYWNrIG1hbmFnZXIgd2l0aCBhIGxhbmdjaGFpbiB0cmFjZXJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKGNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZShjYWxsYmFja3M/LmhhbmRsZXJzKSB8fFxuICAgICAgICAgICAgLy8gT3IgaXQncyBhbiBhcnJheSB3aXRoIGEgTGFuZ0NoYWluVHJhY2VyTGlrZSBvYmplY3Qgd2l0aGluIGl0XG4gICAgICAgICAgICBjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoY2FsbGJhY2tzKSkpO1xufVxuZnVuY3Rpb24gX2dldFdyaXRlUmVwbGljYXNGcm9tRW52KCkge1xuICAgIGNvbnN0IGVudlZhciA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HU01JVEhfUlVOU19FTkRQT0lOVFNcIik7XG4gICAgaWYgKCFlbnZWYXIpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGVudlZhcik7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxpY2FzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSBcIm9iamVjdFwiIHx8IGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIGl0ZW0gdHlwZSBpbiBMQU5HU01JVEhfUlVOU19FTkRQT0lOVFM6IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGV4cGVjdGVkIG9iamVjdCwgZ290ICR7dHlwZW9mIGl0ZW19YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0uYXBpX3VybCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgYXBpX3VybCB0eXBlIGluIExBTkdTTUlUSF9SVU5TX0VORFBPSU5UUzogYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2YgaXRlbS5hcGlfdXJsfWApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtLmFwaV9rZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIGFwaV9rZXkgdHlwZSBpbiBMQU5HU01JVEhfUlVOU19FTkRQT0lOVFM6IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIGl0ZW0uYXBpX2tleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcGxpY2FzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBhcGlVcmw6IGl0ZW0uYXBpX3VybC5yZXBsYWNlKC9cXC8kLywgXCJcIiksXG4gICAgICAgICAgICAgICAgICAgIGFwaUtleTogaXRlbS5hcGlfa2V5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxpY2FzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJzZWQgPT09IFwib2JqZWN0XCIgJiYgcGFyc2VkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfY2hlY2tFbmRwb2ludEVudlVuc2V0KHBhcnNlZCk7XG4gICAgICAgICAgICBjb25zdCByZXBsaWNhcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdXJsLCBrZXldIG9mIE9iamVjdC5lbnRyaWVzKHBhcnNlZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhblVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGljYXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlVcmw6IGNsZWFuVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpS2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHZhbHVlIHR5cGUgaW4gTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTIGZvciBVUkwgJHt1cmx9OiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXBsaWNhcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTIOKAkyBtdXN0IGJlIHZhbGlkIEpTT04gYXJyYXkgb2YgXCIgK1xuICAgICAgICAgICAgICAgIGBvYmplY3RzIHdpdGggYXBpX3VybCBhbmQgYXBpX2tleSBwcm9wZXJ0aWVzLCBvciBvYmplY3QgbWFwcGluZyB1cmwtPmFwaUtleSwgZ290ICR7dHlwZW9mIHBhcnNlZH1gKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaXNDb25mbGljdGluZ0VuZHBvaW50c0Vycm9yKGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTIOKAkyBtdXN0IGJlIHZhbGlkIEpTT04gYXJyYXkgb2YgXCIgK1xuICAgICAgICAgICAgXCJvYmplY3RzIHdpdGggYXBpX3VybCBhbmQgYXBpX2tleSBwcm9wZXJ0aWVzLCBvciBvYmplY3QgbWFwcGluZyB1cmwtPmFwaUtleVwiKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9lbnN1cmVXcml0ZVJlcGxpY2FzKHJlcGxpY2FzKSB7XG4gICAgLy8gSWYgbnVsbCAtPiBmZXRjaCBmcm9tIGVudlxuICAgIGlmIChyZXBsaWNhcykge1xuICAgICAgICByZXR1cm4gcmVwbGljYXMubWFwKChyZXBsaWNhKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXBsaWNhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3ROYW1lOiByZXBsaWNhWzBdLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVzOiByZXBsaWNhWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVwbGljYTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfZ2V0V3JpdGVSZXBsaWNhc0Zyb21FbnYoKTtcbn1cbmZ1bmN0aW9uIF9jaGVja0VuZHBvaW50RW52VW5zZXQocGFyc2VkKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoID4gMCAmJlxuICAgICAgICBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiRU5EUE9JTlRcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/run_trees.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/singletons/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _LC_CHILD_RUN_END_PROMISES_KEY: () => (/* binding */ _LC_CHILD_RUN_END_PROMISES_KEY),\n/* harmony export */   _LC_CONTEXT_VARIABLES_KEY: () => (/* binding */ _LC_CONTEXT_VARIABLES_KEY),\n/* harmony export */   _REPLICA_TRACE_ROOTS_KEY: () => (/* binding */ _REPLICA_TRACE_ROOTS_KEY)\n/* harmony export */ });\nconst _LC_CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\nconst _LC_CHILD_RUN_END_PROMISES_KEY = Symbol.for(\"lc:child_run_end_promises\");\nconst _REPLICA_TRACE_ROOTS_KEY = Symbol.for(\"langsmith:replica_trace_roots\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU87QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXZlcnkvdGVzdDIvYWdlbnQtY2hhdC11aS9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IF9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkgPSBTeW1ib2wuZm9yKFwibGM6Y29udGV4dF92YXJpYWJsZXNcIik7XG5leHBvcnQgY29uc3QgX0xDX0NISUxEX1JVTl9FTkRfUFJPTUlTRVNfS0VZID0gU3ltYm9sLmZvcihcImxjOmNoaWxkX3J1bl9lbmRfcHJvbWlzZXNcIik7XG5leHBvcnQgY29uc3QgX1JFUExJQ0FfVFJBQ0VfUk9PVFNfS0VZID0gU3ltYm9sLmZvcihcImxhbmdzbWl0aDpyZXBsaWNhX3RyYWNlX3Jvb3RzXCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/singletons/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/singletons/fetch.js":
/*!*********************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/fetch.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getFetchImplementation: () => (/* binding */ _getFetchImplementation),\n/* harmony export */   _globalFetchImplementationIsNodeFetch: () => (/* binding */ _globalFetchImplementationIsNodeFetch),\n/* harmony export */   clearFetchImplementation: () => (/* binding */ clearFetchImplementation),\n/* harmony export */   overrideFetchImplementation: () => (/* binding */ overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/env.js */ \"(ssr)/./node_modules/langsmith/dist/utils/env.js\");\n\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"ls:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch functino to use.\n */\nconst overrideFetchImplementation = (fetch) => {\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch;\n};\nconst clearFetchImplementation = () => {\n    delete globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];\n};\nconst _globalFetchImplementationIsNodeFetch = () => {\n    const fetchImpl = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];\n    if (!fetchImpl)\n        return false;\n    // Check if the implementation has node-fetch specific properties\n    return (typeof fetchImpl === \"function\" &&\n        \"Headers\" in fetchImpl &&\n        \"Request\" in fetchImpl &&\n        \"Response\" in fetchImpl);\n};\n/**\n * @internal\n */\nconst _getFetchImplementation = (debug) => {\n    return async (...args) => {\n        if (debug || (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"DEBUG\") === \"true\") {\n            const [url, options] = args;\n            console.log(` ${options?.method || \"GET\"} ${url}`);\n        }\n        const res = await (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ??\n            DEFAULT_FETCH_IMPLEMENTATION)(...args);\n        if (debug || (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"DEBUG\") === \"true\") {\n            console.log(` ${res.status} ${res.statusText} ${res.url}`);\n        }\n        return res;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxQkFBcUIsOEVBQStCO0FBQ3BEO0FBQ0EsNkJBQTZCLDBCQUEwQixFQUFFLElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhFQUErQjtBQUNwRCw2QkFBNkIsWUFBWSxFQUFFLGdCQUFnQixFQUFFLFFBQVE7QUFDckU7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL2ZldGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi4vdXRpbHMvZW52LmpzXCI7XG4vLyBXcmFwIHRoZSBkZWZhdWx0IGZldGNoIGNhbGwgZHVlIHRvIGlzc3VlcyB3aXRoIGlsbGVnYWwgaW52b2NhdGlvbnNcbi8vIGluIHNvbWUgZW52aXJvbm1lbnRzOlxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjk4NzY4NTkvd2h5LWRvZXMtYmluZC1maXgtZmFpbGVkLXRvLWV4ZWN1dGUtZmV0Y2gtb24td2luZG93LWlsbGVnYWwtaW52b2NhdGlvbi1lcnJcbi8vIEB0cy1leHBlY3QtZXJyb3IgQnJvYWQgdHlwaW5nIHRvIHN1cHBvcnQgYSByYW5nZSBvZiBmZXRjaCBpbXBsZW1lbnRhdGlvbnNcbmNvbnN0IERFRkFVTFRfRkVUQ0hfSU1QTEVNRU5UQVRJT04gPSAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG5jb25zdCBMQU5HU01JVEhfRkVUQ0hfSU1QTEVNRU5UQVRJT05fS0VZID0gU3ltYm9sLmZvcihcImxzOmZldGNoX2ltcGxlbWVudGF0aW9uXCIpO1xuLyoqXG4gKiBPdmVycmlkZXMgdGhlIGZldGNoIGltcGxlbWVudGF0aW9uIHVzZWQgZm9yIExhbmdTbWl0aCBjYWxscy5cbiAqIFlvdSBzaG91bGQgdXNlIHRoaXMgaWYgeW91IG5lZWQgdG8gdXNlIGFuIGltcGxlbWVudGF0aW9uIG9mIGZldGNoXG4gKiBvdGhlciB0aGFuIHRoZSBkZWZhdWx0IGdsb2JhbCAoZS5nLiBmb3IgZGVhbGluZyB3aXRoIHByb3hpZXMpLlxuICogQHBhcmFtIGZldGNoIFRoZSBuZXcgZmV0Y2ggZnVuY3Rpbm8gdG8gdXNlLlxuICovXG5leHBvcnQgY29uc3Qgb3ZlcnJpZGVGZXRjaEltcGxlbWVudGF0aW9uID0gKGZldGNoKSA9PiB7XG4gICAgZ2xvYmFsVGhpc1tMQU5HU01JVEhfRkVUQ0hfSU1QTEVNRU5UQVRJT05fS0VZXSA9IGZldGNoO1xufTtcbmV4cG9ydCBjb25zdCBjbGVhckZldGNoSW1wbGVtZW50YXRpb24gPSAoKSA9PiB7XG4gICAgZGVsZXRlIGdsb2JhbFRoaXNbTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWV07XG59O1xuZXhwb3J0IGNvbnN0IF9nbG9iYWxGZXRjaEltcGxlbWVudGF0aW9uSXNOb2RlRmV0Y2ggPSAoKSA9PiB7XG4gICAgY29uc3QgZmV0Y2hJbXBsID0gZ2xvYmFsVGhpc1tMQU5HU01JVEhfRkVUQ0hfSU1QTEVNRU5UQVRJT05fS0VZXTtcbiAgICBpZiAoIWZldGNoSW1wbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIENoZWNrIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBoYXMgbm9kZS1mZXRjaCBzcGVjaWZpYyBwcm9wZXJ0aWVzXG4gICAgcmV0dXJuICh0eXBlb2YgZmV0Y2hJbXBsID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgXCJIZWFkZXJzXCIgaW4gZmV0Y2hJbXBsICYmXG4gICAgICAgIFwiUmVxdWVzdFwiIGluIGZldGNoSW1wbCAmJlxuICAgICAgICBcIlJlc3BvbnNlXCIgaW4gZmV0Y2hJbXBsKTtcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgX2dldEZldGNoSW1wbGVtZW50YXRpb24gPSAoZGVidWcpID0+IHtcbiAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGRlYnVnIHx8IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJERUJVR1wiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IFt1cmwsIG9wdGlvbnNdID0gYXJncztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDihpIgJHtvcHRpb25zPy5tZXRob2QgfHwgXCJHRVRcIn0gJHt1cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgKGdsb2JhbFRoaXNbTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWV0gPz9cbiAgICAgICAgICAgIERFRkFVTFRfRkVUQ0hfSU1QTEVNRU5UQVRJT04pKC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZGVidWcgfHwgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkRFQlVHXCIpID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKGkCAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9ICR7cmVzLnVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/singletons/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/singletons/otel.js":
/*!********************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/otel.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OTELProviderSingleton: () => (/* binding */ OTELProviderSingleton),\n/* harmony export */   getDefaultOTLPTracerComponents: () => (/* binding */ getDefaultOTLPTracerComponents),\n/* harmony export */   getOTELContext: () => (/* binding */ getOTELContext),\n/* harmony export */   getOTELTrace: () => (/* binding */ getOTELTrace),\n/* harmony export */   setDefaultOTLPTracerComponents: () => (/* binding */ setDefaultOTLPTracerComponents),\n/* harmony export */   setOTELInstances: () => (/* binding */ setOTELInstances)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/env.js */ \"(ssr)/./node_modules/langsmith/dist/utils/env.js\");\n// Should not import any OTEL packages to avoid pulling in optional deps.\n\nclass MockTracer {\n    constructor() {\n        Object.defineProperty(this, \"hasWarned\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    startActiveSpan(_name, ...args) {\n        if (!this.hasWarned && (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getOtelEnabled)()) {\n            console.warn(\"You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. \" +\n                'Please add:\\n```\\nimport { initializeOTEL } from \"langsmith/experimental/otel/setup\";\\ninitializeOTEL();\\n```\\nat the beginning of your code.');\n            this.hasWarned = true;\n        }\n        // Handle different overloads:\n        // startActiveSpan(name, fn)\n        // startActiveSpan(name, options, fn)\n        // startActiveSpan(name, options, context, fn)\n        let fn;\n        if (args.length === 1 && typeof args[0] === \"function\") {\n            fn = args[0];\n        }\n        else if (args.length === 2 && typeof args[1] === \"function\") {\n            fn = args[1];\n        }\n        else if (args.length === 3 && typeof args[2] === \"function\") {\n            fn = args[2];\n        }\n        if (typeof fn === \"function\") {\n            return fn();\n        }\n        return undefined;\n    }\n}\nclass MockOTELTrace {\n    constructor() {\n        Object.defineProperty(this, \"mockTracer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new MockTracer()\n        });\n    }\n    getTracer(_name, _version) {\n        return this.mockTracer;\n    }\n    getActiveSpan() {\n        return undefined;\n    }\n    setSpan(context, _span) {\n        return context;\n    }\n    getSpan(_context) {\n        return undefined;\n    }\n    setSpanContext(context, _spanContext) {\n        return context;\n    }\n    getTracerProvider() {\n        return undefined;\n    }\n    setGlobalTracerProvider(_tracerProvider) {\n        return false;\n    }\n}\nclass MockOTELContext {\n    active() {\n        return {};\n    }\n    with(_context, fn) {\n        return fn();\n    }\n}\nconst OTEL_TRACE_KEY = Symbol.for(\"ls:otel_trace\");\nconst OTEL_CONTEXT_KEY = Symbol.for(\"ls:otel_context\");\nconst OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY = Symbol.for(\"ls:otel_get_default_otlp_tracer_provider\");\nconst mockOTELTrace = new MockOTELTrace();\nconst mockOTELContext = new MockOTELContext();\nclass OTELProvider {\n    getTraceInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[OTEL_TRACE_KEY] ?? mockOTELTrace;\n    }\n    getContextInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[OTEL_CONTEXT_KEY] ?? mockOTELContext;\n    }\n    initializeGlobalInstances(otel) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[OTEL_TRACE_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[OTEL_TRACE_KEY] = otel.trace;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[OTEL_CONTEXT_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[OTEL_CONTEXT_KEY] = otel.context;\n        }\n    }\n    setDefaultOTLPTracerComponents(components) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] = components;\n    }\n    getDefaultOTLPTracerComponents() {\n        return (globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] ??\n            undefined);\n    }\n}\nconst OTELProviderSingleton = new OTELProvider();\n/**\n * Get the current OTEL trace instance.\n * Returns a mock implementation if OTEL is not available.\n */\nfunction getOTELTrace() {\n    return OTELProviderSingleton.getTraceInstance();\n}\n/**\n * Get the current OTEL context instance.\n * Returns a mock implementation if OTEL is not available.\n */\nfunction getOTELContext() {\n    return OTELProviderSingleton.getContextInstance();\n}\n/**\n * Initialize the global OTEL instances.\n * Should be called once when OTEL packages are available.\n */\nfunction setOTELInstances(otel) {\n    OTELProviderSingleton.initializeGlobalInstances(otel);\n}\n/**\n * Set a getter function for the default OTLP tracer provider.\n * This allows lazy initialization of the tracer provider.\n */\nfunction setDefaultOTLPTracerComponents(components) {\n    OTELProviderSingleton.setDefaultOTLPTracerComponents(components);\n}\n/**\n * Get the default OTLP tracer provider instance.\n * Returns undefined if not set.\n */\nfunction getDefaultOTLPTracerComponents() {\n    return OTELProviderSingleton.getDefaultOTLPTracerComponents();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9vdGVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCLDZEQUFjO0FBQzdDO0FBQ0EsNENBQTRDLGlCQUFpQix5Q0FBeUMsbUJBQW1CO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXZlcnkvdGVzdDIvYWdlbnQtY2hhdC11aS9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9vdGVsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNob3VsZCBub3QgaW1wb3J0IGFueSBPVEVMIHBhY2thZ2VzIHRvIGF2b2lkIHB1bGxpbmcgaW4gb3B0aW9uYWwgZGVwcy5cbmltcG9ydCB7IGdldE90ZWxFbmFibGVkIH0gZnJvbSBcIi4uL3V0aWxzL2Vudi5qc1wiO1xuY2xhc3MgTW9ja1RyYWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhc1dhcm5lZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0QWN0aXZlU3BhbihfbmFtZSwgLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuaGFzV2FybmVkICYmIGdldE90ZWxFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIllvdSBoYXZlIGVuYWJsZWQgT1RFTCBleHBvcnQgdmlhIHRoZSBgT1RFTF9FTkFCTEVEYCBvciBgTEFOR1NNSVRIX09URUxfRU5BQkxFRGAgZW52aXJvbm1lbnQgdmFyaWFibGUsIGJ1dCBoYXZlIG5vdCBpbml0aWFsaXplZCB0aGUgcmVxdWlyZWQgT1RFTCBpbnN0YW5jZXMuIFwiICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIGFkZDpcXG5gYGBcXG5pbXBvcnQgeyBpbml0aWFsaXplT1RFTCB9IGZyb20gXCJsYW5nc21pdGgvZXhwZXJpbWVudGFsL290ZWwvc2V0dXBcIjtcXG5pbml0aWFsaXplT1RFTCgpO1xcbmBgYFxcbmF0IHRoZSBiZWdpbm5pbmcgb2YgeW91ciBjb2RlLicpO1xuICAgICAgICAgICAgdGhpcy5oYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgb3ZlcmxvYWRzOlxuICAgICAgICAvLyBzdGFydEFjdGl2ZVNwYW4obmFtZSwgZm4pXG4gICAgICAgIC8vIHN0YXJ0QWN0aXZlU3BhbihuYW1lLCBvcHRpb25zLCBmbilcbiAgICAgICAgLy8gc3RhcnRBY3RpdmVTcGFuKG5hbWUsIG9wdGlvbnMsIGNvbnRleHQsIGZuKVxuICAgICAgICBsZXQgZm47XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBmbiA9IGFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3NbMV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm4gPSBhcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAzICYmIHR5cGVvZiBhcmdzWzJdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZuID0gYXJnc1syXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgTW9ja09URUxUcmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vY2tUcmFjZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNb2NrVHJhY2VyKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFRyYWNlcihfbmFtZSwgX3ZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9ja1RyYWNlcjtcbiAgICB9XG4gICAgZ2V0QWN0aXZlU3BhbigpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0U3Bhbihjb250ZXh0LCBfc3Bhbikge1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgZ2V0U3BhbihfY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXRTcGFuQ29udGV4dChjb250ZXh0LCBfc3BhbkNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGdldFRyYWNlclByb3ZpZGVyKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXRHbG9iYWxUcmFjZXJQcm92aWRlcihfdHJhY2VyUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIE1vY2tPVEVMQ29udGV4dCB7XG4gICAgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHdpdGgoX2NvbnRleHQsIGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbn1cbmNvbnN0IE9URUxfVFJBQ0VfS0VZID0gU3ltYm9sLmZvcihcImxzOm90ZWxfdHJhY2VcIik7XG5jb25zdCBPVEVMX0NPTlRFWFRfS0VZID0gU3ltYm9sLmZvcihcImxzOm90ZWxfY29udGV4dFwiKTtcbmNvbnN0IE9URUxfR0VUX0RFRkFVTFRfT1RMUF9UUkFDRVJfUFJPVklERVJfS0VZID0gU3ltYm9sLmZvcihcImxzOm90ZWxfZ2V0X2RlZmF1bHRfb3RscF90cmFjZXJfcHJvdmlkZXJcIik7XG5jb25zdCBtb2NrT1RFTFRyYWNlID0gbmV3IE1vY2tPVEVMVHJhY2UoKTtcbmNvbnN0IG1vY2tPVEVMQ29udGV4dCA9IG5ldyBNb2NrT1RFTENvbnRleHQoKTtcbmNsYXNzIE9URUxQcm92aWRlciB7XG4gICAgZ2V0VHJhY2VJbnN0YW5jZSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXNbT1RFTF9UUkFDRV9LRVldID8/IG1vY2tPVEVMVHJhY2U7XG4gICAgfVxuICAgIGdldENvbnRleHRJbnN0YW5jZSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXNbT1RFTF9DT05URVhUX0tFWV0gPz8gbW9ja09URUxDb250ZXh0O1xuICAgIH1cbiAgICBpbml0aWFsaXplR2xvYmFsSW5zdGFuY2VzKG90ZWwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgaWYgKGdsb2JhbFRoaXNbT1RFTF9UUkFDRV9LRVldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBnbG9iYWxUaGlzW09URUxfVFJBQ0VfS0VZXSA9IG90ZWwudHJhY2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgaWYgKGdsb2JhbFRoaXNbT1RFTF9DT05URVhUX0tFWV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGdsb2JhbFRoaXNbT1RFTF9DT05URVhUX0tFWV0gPSBvdGVsLmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RGVmYXVsdE9UTFBUcmFjZXJDb21wb25lbnRzKGNvbXBvbmVudHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgZ2xvYmFsVGhpc1tPVEVMX0dFVF9ERUZBVUxUX09UTFBfVFJBQ0VSX1BST1ZJREVSX0tFWV0gPSBjb21wb25lbnRzO1xuICAgIH1cbiAgICBnZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMoKSB7XG4gICAgICAgIHJldHVybiAoZ2xvYmFsVGhpc1tPVEVMX0dFVF9ERUZBVUxUX09UTFBfVFJBQ0VSX1BST1ZJREVSX0tFWV0gPz9cbiAgICAgICAgICAgIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IE9URUxQcm92aWRlclNpbmdsZXRvbiA9IG5ldyBPVEVMUHJvdmlkZXIoKTtcbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IE9URUwgdHJhY2UgaW5zdGFuY2UuXG4gKiBSZXR1cm5zIGEgbW9jayBpbXBsZW1lbnRhdGlvbiBpZiBPVEVMIGlzIG5vdCBhdmFpbGFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPVEVMVHJhY2UoKSB7XG4gICAgcmV0dXJuIE9URUxQcm92aWRlclNpbmdsZXRvbi5nZXRUcmFjZUluc3RhbmNlKCk7XG59XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBPVEVMIGNvbnRleHQgaW5zdGFuY2UuXG4gKiBSZXR1cm5zIGEgbW9jayBpbXBsZW1lbnRhdGlvbiBpZiBPVEVMIGlzIG5vdCBhdmFpbGFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPVEVMQ29udGV4dCgpIHtcbiAgICByZXR1cm4gT1RFTFByb3ZpZGVyU2luZ2xldG9uLmdldENvbnRleHRJbnN0YW5jZSgpO1xufVxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBnbG9iYWwgT1RFTCBpbnN0YW5jZXMuXG4gKiBTaG91bGQgYmUgY2FsbGVkIG9uY2Ugd2hlbiBPVEVMIHBhY2thZ2VzIGFyZSBhdmFpbGFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRPVEVMSW5zdGFuY2VzKG90ZWwpIHtcbiAgICBPVEVMUHJvdmlkZXJTaW5nbGV0b24uaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlcyhvdGVsKTtcbn1cbi8qKlxuICogU2V0IGEgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgZGVmYXVsdCBPVExQIHRyYWNlciBwcm92aWRlci5cbiAqIFRoaXMgYWxsb3dzIGxhenkgaW5pdGlhbGl6YXRpb24gb2YgdGhlIHRyYWNlciBwcm92aWRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cyhjb21wb25lbnRzKSB7XG4gICAgT1RFTFByb3ZpZGVyU2luZ2xldG9uLnNldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cyhjb21wb25lbnRzKTtcbn1cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IE9UTFAgdHJhY2VyIHByb3ZpZGVyIGluc3RhbmNlLlxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgbm90IHNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cygpIHtcbiAgICByZXR1cm4gT1RFTFByb3ZpZGVyU2luZ2xldG9uLmdldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cygpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/singletons/otel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/singletons/traceable.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/traceable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),\n/* harmony export */   ROOT: () => (/* binding */ ROOT),\n/* harmony export */   getCurrentRunTree: () => (/* binding */ getCurrentRunTree),\n/* harmony export */   isTraceableFunction: () => (/* binding */ isTraceableFunction),\n/* harmony export */   withRunTree: () => (/* binding */ withRunTree)\n/* harmony export */ });\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_, callback) {\n        return callback();\n    }\n}\nconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n    }\n    initializeGlobalInstance(instance) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[TRACING_ALS_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[TRACING_ALS_KEY] = instance;\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\nfunction getCurrentRunTree(permitAbsentRunTree = false) {\n    const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();\n    if (!permitAbsentRunTree && runTree === undefined) {\n        throw new Error(\"Could not get the current run tree.\\n\\nPlease make sure you are calling this method within a traceable function and that tracing is enabled.\");\n    }\n    return runTree;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withRunTree(runTree, fn) {\n    const storage = AsyncLocalStorageProviderSingleton.getInstance();\n    return new Promise((resolve, reject) => {\n        storage.run(runTree, () => void Promise.resolve(fn()).then(resolve).catch(reject));\n    });\n}\nconst ROOT = Symbol.for(\"langsmith:traceable:root\");\nfunction isTraceableFunction(x\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    return typeof x === \"function\" && \"langsmith:traceable\" in x;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy90cmFjZWFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL3RyYWNlYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBNb2NrQXN5bmNMb2NhbFN0b3JhZ2Uge1xuICAgIGdldFN0b3JlKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBydW4oXywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuY29uc3QgVFJBQ0lOR19BTFNfS0VZID0gU3ltYm9sLmZvcihcImxzOnRyYWNpbmdfYXN5bmNfbG9jYWxfc3RvcmFnZVwiKTtcbmNvbnN0IG1vY2tBc3luY0xvY2FsU3RvcmFnZSA9IG5ldyBNb2NrQXN5bmNMb2NhbFN0b3JhZ2UoKTtcbmNsYXNzIEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXIge1xuICAgIGdldEluc3RhbmNlKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpc1tUUkFDSU5HX0FMU19LRVldID8/IG1vY2tBc3luY0xvY2FsU3RvcmFnZTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGlmIChnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGdsb2JhbFRoaXNbVFJBQ0lOR19BTFNfS0VZXSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlcigpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRSdW5UcmVlKHBlcm1pdEFic2VudFJ1blRyZWUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHJ1blRyZWUgPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLmdldEluc3RhbmNlKCkuZ2V0U3RvcmUoKTtcbiAgICBpZiAoIXBlcm1pdEFic2VudFJ1blRyZWUgJiYgcnVuVHJlZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgdGhlIGN1cnJlbnQgcnVuIHRyZWUuXFxuXFxuUGxlYXNlIG1ha2Ugc3VyZSB5b3UgYXJlIGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aGluIGEgdHJhY2VhYmxlIGZ1bmN0aW9uIGFuZCB0aGF0IHRyYWNpbmcgaXMgZW5hYmxlZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBydW5UcmVlO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiB3aXRoUnVuVHJlZShydW5UcmVlLCBmbikge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLmdldEluc3RhbmNlKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc3RvcmFnZS5ydW4ocnVuVHJlZSwgKCkgPT4gdm9pZCBQcm9taXNlLnJlc29sdmUoZm4oKSkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBST09UID0gU3ltYm9sLmZvcihcImxhbmdzbWl0aDp0cmFjZWFibGU6cm9vdFwiKTtcbmV4cG9ydCBmdW5jdGlvbiBpc1RyYWNlYWJsZUZ1bmN0aW9uKHhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiAmJiBcImxhbmdzbWl0aDp0cmFjZWFibGVcIiBpbiB4O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/singletons/traceable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/_uuid.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/_uuid.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertUuid: () => (/* binding */ assertUuid),\n/* harmony export */   getUuidVersion: () => (/* binding */ getUuidVersion),\n/* harmony export */   uuid7FromTime: () => (/* binding */ uuid7FromTime),\n/* harmony export */   warnIfNotUuidV7: () => (/* binding */ warnIfNotUuidV7)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v7.js\");\n/* harmony import */ var _warn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./warn.js */ \"(ssr)/./node_modules/langsmith/dist/utils/warn.js\");\n// Relaxed UUID validation regex (allows any valid UUID format including nil UUIDs)\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n\n\nlet UUID7_WARNING_EMITTED = false;\nfunction assertUuid(str, which) {\n    // Use relaxed regex validation instead of strict uuid.validate()\n    // This allows edge cases like nil UUIDs or test UUIDs that might not pass strict validation\n    if (!UUID_REGEX.test(str)) {\n        const msg = which !== undefined\n            ? `Invalid UUID for ${which}: ${str}`\n            : `Invalid UUID: ${str}`;\n        throw new Error(msg);\n    }\n    return str;\n}\n/**\n * Generate a UUID v7 from a timestamp.\n *\n * @param timestamp - The timestamp in milliseconds\n * @returns A UUID v7 string\n */\nfunction uuid7FromTime(timestamp) {\n    const msecs = typeof timestamp === \"string\" ? Date.parse(timestamp) : timestamp;\n    // Work around uuid@10 behavior where providing only { msecs }\n    // may not set the internal timestamp used for stringification.\n    // Providing a seq ensures the implementation updates its internal state\n    // and encodes the provided milliseconds into the UUID bytes.\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({ msecs, seq: 0 });\n}\n/**\n * Get the version of a UUID string.\n * @param uuidStr - The UUID string to check\n * @returns The version number (1-7) or null if invalid\n */\nfunction getUuidVersion(uuidStr) {\n    if (!UUID_REGEX.test(uuidStr)) {\n        return null;\n    }\n    // Version is in bits 48-51\n    // Format: xxxxxxxx-xxxx-Vxxx-xxxx-xxxxxxxxxxxx\n    const versionChar = uuidStr[14];\n    return parseInt(versionChar, 16);\n}\n/**\n * Warn if a UUID is not version 7.\n *\n * @param uuidStr - The UUID string to check\n * @param idType - The type of ID (e.g., \"run_id\", \"trace_id\") for the warning message\n */\nfunction warnIfNotUuidV7(uuidStr, _idType) {\n    const version = getUuidVersion(uuidStr);\n    if (version !== null && version !== 7 && !UUID7_WARNING_EMITTED) {\n        UUID7_WARNING_EMITTED = true;\n        (0,_warn_js__WEBPACK_IMPORTED_MODULE_0__.warnOnce)(`LangSmith now uses UUID v7 for run and trace identifiers. ` +\n            `This warning appears when passing custom IDs. ` +\n            `Please use: import { uuidv7 } from 'langsmith'; const id = uuidv7(); ` +\n            `Future versions will require UUID v7.`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvX3V1aWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQSw4QkFBOEIsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEdBQUc7QUFDN0M7QUFDQztBQUNyQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTSxJQUFJLElBQUk7QUFDaEQsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQU0sR0FBRyxlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBUTtBQUNoQjtBQUNBLGtDQUFrQyxTQUFTLGtCQUFrQixxQkFBcUI7QUFDbEY7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXZlcnkvdGVzdDIvYWdlbnQtY2hhdC11aS9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvX3V1aWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUmVsYXhlZCBVVUlEIHZhbGlkYXRpb24gcmVnZXggKGFsbG93cyBhbnkgdmFsaWQgVVVJRCBmb3JtYXQgaW5jbHVkaW5nIG5pbCBVVUlEcylcbmNvbnN0IFVVSURfUkVHRVggPSAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQvaTtcbmltcG9ydCB7IHY3IGFzIHV1aWR2NyB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gXCIuL3dhcm4uanNcIjtcbmxldCBVVUlEN19XQVJOSU5HX0VNSVRURUQgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRVdWlkKHN0ciwgd2hpY2gpIHtcbiAgICAvLyBVc2UgcmVsYXhlZCByZWdleCB2YWxpZGF0aW9uIGluc3RlYWQgb2Ygc3RyaWN0IHV1aWQudmFsaWRhdGUoKVxuICAgIC8vIFRoaXMgYWxsb3dzIGVkZ2UgY2FzZXMgbGlrZSBuaWwgVVVJRHMgb3IgdGVzdCBVVUlEcyB0aGF0IG1pZ2h0IG5vdCBwYXNzIHN0cmljdCB2YWxpZGF0aW9uXG4gICAgaWYgKCFVVUlEX1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgICAgICBjb25zdCBtc2cgPSB3aGljaCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGBJbnZhbGlkIFVVSUQgZm9yICR7d2hpY2h9OiAke3N0cn1gXG4gICAgICAgICAgICA6IGBJbnZhbGlkIFVVSUQ6ICR7c3RyfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIFVVSUQgdjcgZnJvbSBhIHRpbWVzdGFtcC5cbiAqXG4gKiBAcGFyYW0gdGltZXN0YW1wIC0gVGhlIHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIEEgVVVJRCB2NyBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWQ3RnJvbVRpbWUodGltZXN0YW1wKSB7XG4gICAgY29uc3QgbXNlY3MgPSB0eXBlb2YgdGltZXN0YW1wID09PSBcInN0cmluZ1wiID8gRGF0ZS5wYXJzZSh0aW1lc3RhbXApIDogdGltZXN0YW1wO1xuICAgIC8vIFdvcmsgYXJvdW5kIHV1aWRAMTAgYmVoYXZpb3Igd2hlcmUgcHJvdmlkaW5nIG9ubHkgeyBtc2VjcyB9XG4gICAgLy8gbWF5IG5vdCBzZXQgdGhlIGludGVybmFsIHRpbWVzdGFtcCB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24uXG4gICAgLy8gUHJvdmlkaW5nIGEgc2VxIGVuc3VyZXMgdGhlIGltcGxlbWVudGF0aW9uIHVwZGF0ZXMgaXRzIGludGVybmFsIHN0YXRlXG4gICAgLy8gYW5kIGVuY29kZXMgdGhlIHByb3ZpZGVkIG1pbGxpc2Vjb25kcyBpbnRvIHRoZSBVVUlEIGJ5dGVzLlxuICAgIHJldHVybiB1dWlkdjcoeyBtc2Vjcywgc2VxOiAwIH0pO1xufVxuLyoqXG4gKiBHZXQgdGhlIHZlcnNpb24gb2YgYSBVVUlEIHN0cmluZy5cbiAqIEBwYXJhbSB1dWlkU3RyIC0gVGhlIFVVSUQgc3RyaW5nIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBUaGUgdmVyc2lvbiBudW1iZXIgKDEtNykgb3IgbnVsbCBpZiBpbnZhbGlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVdWlkVmVyc2lvbih1dWlkU3RyKSB7XG4gICAgaWYgKCFVVUlEX1JFR0VYLnRlc3QodXVpZFN0cikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFZlcnNpb24gaXMgaW4gYml0cyA0OC01MVxuICAgIC8vIEZvcm1hdDogeHh4eHh4eHgteHh4eC1WeHh4LXh4eHgteHh4eHh4eHh4eHh4XG4gICAgY29uc3QgdmVyc2lvbkNoYXIgPSB1dWlkU3RyWzE0XTtcbiAgICByZXR1cm4gcGFyc2VJbnQodmVyc2lvbkNoYXIsIDE2KTtcbn1cbi8qKlxuICogV2FybiBpZiBhIFVVSUQgaXMgbm90IHZlcnNpb24gNy5cbiAqXG4gKiBAcGFyYW0gdXVpZFN0ciAtIFRoZSBVVUlEIHN0cmluZyB0byBjaGVja1xuICogQHBhcmFtIGlkVHlwZSAtIFRoZSB0eXBlIG9mIElEIChlLmcuLCBcInJ1bl9pZFwiLCBcInRyYWNlX2lkXCIpIGZvciB0aGUgd2FybmluZyBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YXJuSWZOb3RVdWlkVjcodXVpZFN0ciwgX2lkVHlwZSkge1xuICAgIGNvbnN0IHZlcnNpb24gPSBnZXRVdWlkVmVyc2lvbih1dWlkU3RyKTtcbiAgICBpZiAodmVyc2lvbiAhPT0gbnVsbCAmJiB2ZXJzaW9uICE9PSA3ICYmICFVVUlEN19XQVJOSU5HX0VNSVRURUQpIHtcbiAgICAgICAgVVVJRDdfV0FSTklOR19FTUlUVEVEID0gdHJ1ZTtcbiAgICAgICAgd2Fybk9uY2UoYExhbmdTbWl0aCBub3cgdXNlcyBVVUlEIHY3IGZvciBydW4gYW5kIHRyYWNlIGlkZW50aWZpZXJzLiBgICtcbiAgICAgICAgICAgIGBUaGlzIHdhcm5pbmcgYXBwZWFycyB3aGVuIHBhc3NpbmcgY3VzdG9tIElEcy4gYCArXG4gICAgICAgICAgICBgUGxlYXNlIHVzZTogaW1wb3J0IHsgdXVpZHY3IH0gZnJvbSAnbGFuZ3NtaXRoJzsgY29uc3QgaWQgPSB1dWlkdjcoKTsgYCArXG4gICAgICAgICAgICBgRnV0dXJlIHZlcnNpb25zIHdpbGwgcmVxdWlyZSBVVUlEIHY3LmApO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/_uuid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var _utils_p_retry_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/p-retry/index.js */ \"(ssr)/./node_modules/langsmith/dist/utils/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(ssr)/./node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_RETRYABLE = [\n    408, // Request Timeout\n    425, // Too Early\n    429, // Too Many Requests\n    500, // Internal Server Error\n    502, // Bad Gateway\n    503, // Service Unavailable\n    504, // Gateway Timeout\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxQueueSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queueSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        this.maxQueueSizeBytes = params.maxQueueSizeBytes;\n        if ( true) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                concurrency: this.maxConcurrency,\n            });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({ concurrency: this.maxConcurrency });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.callWithOptions({}, callable, ...args);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        const sizeBytes = options.sizeBytes ?? 0;\n        // Check if adding this call would exceed the byte size limit\n        if (this.maxQueueSizeBytes !== undefined &&\n            sizeBytes > 0 &&\n            this.queueSizeBytes + sizeBytes > this.maxQueueSizeBytes) {\n            return Promise.reject(new Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. ` +\n                `Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${sizeBytes} bytes.`));\n        }\n        // Add to queue size tracking\n        if (sizeBytes > 0) {\n            this.queueSizeBytes += sizeBytes;\n        }\n        const onFailedResponseHook = this.onFailedResponseHook;\n        let promise = this.queue.add(() => (0,_utils_p_retry_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(() => callable(...args).catch((error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            async onFailedAttempt({ error }) {\n                if (error.message.startsWith(\"Cancel\") ||\n                    error.message.startsWith(\"TimeoutError\") ||\n                    error.name === \"TimeoutError\" ||\n                    error.message.startsWith(\"AbortError\")) {\n                    throw error;\n                }\n                if (error?.code === \"ECONNABORTED\") {\n                    throw error;\n                }\n                const response = error?.response;\n                if (onFailedResponseHook) {\n                    const handled = await onFailedResponseHook(response);\n                    if (handled) {\n                        return;\n                    }\n                }\n                const status = response?.status ?? error?.status;\n                if (status) {\n                    if (!STATUS_RETRYABLE.includes(+status)) {\n                        throw error;\n                    }\n                }\n            },\n            retries: this.maxRetries,\n            randomize: true,\n        }), { throwOnTimeout: true });\n        // Decrement queue size when the call completes (success or failure)\n        if (sizeBytes > 0) {\n            promise = promise.finally(() => {\n                this.queueSizeBytes -= sizeBytes;\n            });\n        }\n        // Handle signal cancellation\n        if (options.signal) {\n            return Promise.race([\n                promise,\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return promise;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNmO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBc0I7QUFDbEM7QUFDQSw2QkFBNkIsK0NBQWlCO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQ0FBUyxHQUFHLGtDQUFrQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsd0JBQXdCO0FBQ3pGLHVDQUF1QyxxQkFBcUIsNkJBQTZCLFdBQVc7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1FQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVMsS0FBSyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2F2ZXJ5L3Rlc3QyL2FnZW50LWNoYXQtdWkvbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2FzeW5jX2NhbGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcFJldHJ5IGZyb20gXCIuLi91dGlscy9wLXJldHJ5L2luZGV4LmpzXCI7XG5pbXBvcnQgUFF1ZXVlTW9kIGZyb20gXCJwLXF1ZXVlXCI7XG5jb25zdCBTVEFUVVNfUkVUUllBQkxFID0gW1xuICAgIDQwOCwgLy8gUmVxdWVzdCBUaW1lb3V0XG4gICAgNDI1LCAvLyBUb28gRWFybHlcbiAgICA0MjksIC8vIFRvbyBNYW55IFJlcXVlc3RzXG4gICAgNTAwLCAvLyBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcbiAgICA1MDIsIC8vIEJhZCBHYXRld2F5XG4gICAgNTAzLCAvLyBTZXJ2aWNlIFVuYXZhaWxhYmxlXG4gICAgNTA0LCAvLyBHYXRld2F5IFRpbWVvdXRcbl07XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFzeW5jIGNhbGxzIHdpdGggY29uY3VycmVuY3kgYW5kIHJldHJ5IGxvZ2ljLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBtYWtpbmcgY2FsbHMgdG8gYW55IGtpbmQgb2YgXCJleHBlbnNpdmVcIiBleHRlcm5hbCByZXNvdXJjZSxcbiAqIGJlIGl0IGJlY2F1c2UgaXQncyByYXRlLWxpbWl0ZWQsIHN1YmplY3QgdG8gbmV0d29yayBpc3N1ZXMsIGV0Yy5cbiAqXG4gKiBDb25jdXJyZW50IGNhbGxzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4Q29uY3VycmVuY3lgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHNcbiAqIHRvIGBJbmZpbml0eWAuIFRoaXMgbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBhbGwgY2FsbHMgd2lsbCBiZSBtYWRlIGluIHBhcmFsbGVsLlxuICpcbiAqIFJldHJpZXMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhSZXRyaWVzYCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzIHRvIDYuIFRoaXNcbiAqIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgZWFjaCBjYWxsIHdpbGwgYmUgcmV0cmllZCB1cCB0byA2IHRpbWVzLCB3aXRoIGFuXG4gKiBleHBvbmVudGlhbCBiYWNrb2ZmIGJldHdlZW4gZWFjaCBhdHRlbXB0LlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNDYWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhDb25jdXJyZW5jeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhSZXRyaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFF1ZXVlU2l6ZUJ5dGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRmFpbGVkUmVzcG9uc2VIb29rXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXVlU2l6ZUJ5dGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gcGFyYW1zLm1heENvbmN1cnJlbmN5ID8/IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSBwYXJhbXMubWF4UmV0cmllcyA/PyA2O1xuICAgICAgICB0aGlzLm1heFF1ZXVlU2l6ZUJ5dGVzID0gcGFyYW1zLm1heFF1ZXVlU2l6ZUJ5dGVzO1xuICAgICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gUFF1ZXVlTW9kKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWVNb2QuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgY29uY3VycmVuY3k6IHRoaXMubWF4Q29uY3VycmVuY3ksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZU1vZCh7IGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25GYWlsZWRSZXNwb25zZUhvb2sgPSBwYXJhbXM/Lm9uRmFpbGVkUmVzcG9uc2VIb29rO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFdpdGhPcHRpb25zKHt9LCBjYWxsYWJsZSwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbFdpdGhPcHRpb25zKG9wdGlvbnMsIGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHNpemVCeXRlcyA9IG9wdGlvbnMuc2l6ZUJ5dGVzID8/IDA7XG4gICAgICAgIC8vIENoZWNrIGlmIGFkZGluZyB0aGlzIGNhbGwgd291bGQgZXhjZWVkIHRoZSBieXRlIHNpemUgbGltaXRcbiAgICAgICAgaWYgKHRoaXMubWF4UXVldWVTaXplQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc2l6ZUJ5dGVzID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5xdWV1ZVNpemVCeXRlcyArIHNpemVCeXRlcyA+IHRoaXMubWF4UXVldWVTaXplQnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFF1ZXVlIHNpemUgbGltaXQgKCR7dGhpcy5tYXhRdWV1ZVNpemVCeXRlc30gYnl0ZXMpIGV4Y2VlZGVkLiBgICtcbiAgICAgICAgICAgICAgICBgQ3VycmVudCBxdWV1ZSBzaXplOiAke3RoaXMucXVldWVTaXplQnl0ZXN9IGJ5dGVzLCBhdHRlbXB0ZWQgYWRkaXRpb246ICR7c2l6ZUJ5dGVzfSBieXRlcy5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRvIHF1ZXVlIHNpemUgdHJhY2tpbmdcbiAgICAgICAgaWYgKHNpemVCeXRlcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVTaXplQnl0ZXMgKz0gc2l6ZUJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRmFpbGVkUmVzcG9uc2VIb29rID0gdGhpcy5vbkZhaWxlZFJlc3BvbnNlSG9vaztcbiAgICAgICAgbGV0IHByb21pc2UgPSB0aGlzLnF1ZXVlLmFkZCgoKSA9PiBwUmV0cnkoKCkgPT4gY2FsbGFibGUoLi4uYXJncykuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBhc3luYyBvbkZhaWxlZEF0dGVtcHQoeyBlcnJvciB9KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkNhbmNlbFwiKSB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJUaW1lb3V0RXJyb3JcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9PT0gXCJUaW1lb3V0RXJyb3JcIiB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJBYm9ydEVycm9yXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3I/LmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyb3I/LnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChvbkZhaWxlZFJlc3BvbnNlSG9vaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVkID0gYXdhaXQgb25GYWlsZWRSZXNwb25zZUhvb2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlPy5zdGF0dXMgPz8gZXJyb3I/LnN0YXR1cztcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghU1RBVFVTX1JFVFJZQUJMRS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0cmllczogdGhpcy5tYXhSZXRyaWVzLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICB9KSwgeyB0aHJvd09uVGltZW91dDogdHJ1ZSB9KTtcbiAgICAgICAgLy8gRGVjcmVtZW50IHF1ZXVlIHNpemUgd2hlbiB0aGUgY2FsbCBjb21wbGV0ZXMgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgaWYgKHNpemVCeXRlcyA+IDApIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVTaXplQnl0ZXMgLT0gc2l6ZUJ5dGVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHNpZ25hbCBjYW5jZWxsYXRpb25cbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/context_vars.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/context_vars.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getContextVar: () => (/* binding */ getContextVar),\n/* harmony export */   setContextVar: () => (/* binding */ setContextVar)\n/* harmony export */ });\n/* harmony import */ var _singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/constants.js */ \"(ssr)/./node_modules/langsmith/dist/singletons/constants.js\");\n\n/**\n * Get a context variable from a run tree instance\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getContextVar(runTree, key) {\n    if (_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY in runTree) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const contextVars = runTree[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY];\n        return contextVars[key];\n    }\n    return undefined;\n}\n/**\n * Set a context variable on a run tree instance\n */\nfunction setContextVar(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrunTree, key, value) {\n    const contextVars = _singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY in runTree\n        ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            runTree[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY]\n        : {};\n    contextVars[key] = value;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    runTree[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY] = contextVars;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvY29udGV4dF92YXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSwrRUFBeUI7QUFDakM7QUFDQSxvQ0FBb0MsK0VBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLCtFQUF5QjtBQUNqRDtBQUNBLG9CQUFvQiwrRUFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrRUFBeUI7QUFDckMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9jb250ZXh0X3ZhcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSB9IGZyb20gXCIuLi9zaW5nbGV0b25zL2NvbnN0YW50cy5qc1wiO1xuLyoqXG4gKiBHZXQgYSBjb250ZXh0IHZhcmlhYmxlIGZyb20gYSBydW4gdHJlZSBpbnN0YW5jZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHRWYXIocnVuVHJlZSwga2V5KSB7XG4gICAgaWYgKF9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkgaW4gcnVuVHJlZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBjb250ZXh0VmFycyA9IHJ1blRyZWVbX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV07XG4gICAgICAgIHJldHVybiBjb250ZXh0VmFyc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBTZXQgYSBjb250ZXh0IHZhcmlhYmxlIG9uIGEgcnVuIHRyZWUgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENvbnRleHRWYXIoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucnVuVHJlZSwga2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGNvbnRleHRWYXJzID0gX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSBpbiBydW5UcmVlXG4gICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHJ1blRyZWVbX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV1cbiAgICAgICAgOiB7fTtcbiAgICBjb250ZXh0VmFyc1trZXldID0gdmFsdWU7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBydW5UcmVlW19MQ19DT05URVhUX1ZBUklBQkxFU19LRVldID0gY29udGV4dFZhcnM7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/context_vars.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/env.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getLangSmithEnvVarsMetadata: () => (/* binding */ getLangSmithEnvVarsMetadata),\n/* harmony export */   getLangSmithEnvironmentVariable: () => (/* binding */ getLangSmithEnvironmentVariable),\n/* harmony export */   getLangSmithEnvironmentVariables: () => (/* binding */ getLangSmithEnvironmentVariables),\n/* harmony export */   getOtelEnabled: () => (/* binding */ getOtelEnabled),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getShas: () => (/* binding */ getShas),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"(ssr)/./node_modules/langsmith/dist/index.js\");\n// Inlined from https://github.com/flexdinesh/browser-or-node\n\nlet globalEnv;\nconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nconst isWebWorker = () => typeof globalThis === \"object\" &&\n    globalThis.constructor &&\n    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n    (typeof navigator !== \"undefined\" && navigator.userAgent.includes(\"jsdom\"));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = () => typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = () => typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\" &&\n    !isDeno();\nconst getEnv = () => {\n    if (globalEnv) {\n        return globalEnv;\n    }\n    // @ts-expect-error Bun types are not imported due to conflicts with Node types\n    if (typeof Bun !== \"undefined\") {\n        globalEnv = \"bun\";\n    }\n    else if (isBrowser()) {\n        globalEnv = \"browser\";\n    }\n    else if (isNode()) {\n        globalEnv = \"node\";\n    }\n    else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    }\n    else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    }\n    else if (isDeno()) {\n        globalEnv = \"deno\";\n    }\n    else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nfunction getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__,\n            ...releaseEnv,\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangSmith-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangSmith-specific metadata environment variables.\n */\nfunction getLangSmithEnvVarsMetadata() {\n    const allEnvVars = getLangSmithEnvironmentVariables();\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\",\n        \"LANGSMITH_API_KEY\",\n        \"LANGSMITH_ENDPOINT\",\n        \"LANGSMITH_TRACING_V2\",\n        \"LANGSMITH_PROJECT\",\n        \"LANGSMITH_SESSION\",\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)) {\n        if (typeof value === \"string\" &&\n            !excluded.includes(key) &&\n            !key.toLowerCase().includes(\"key\") &&\n            !key.toLowerCase().includes(\"secret\") &&\n            !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            }\n            else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves only the LangChain/LangSmith-prefixed environment variables from the current runtime environment.\n * This is more efficient than copying all environment variables.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain/LangSmith environment variables.\n */\nfunction getLangSmithEnvironmentVariables() {\n    const envVars = {};\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            for (const [key, value] of Object.entries(process.env)) {\n                if ((key.startsWith(\"LANGCHAIN_\") || key.startsWith(\"LANGSMITH_\")) &&\n                    value != null) {\n                    if ((key.toLowerCase().includes(\"key\") ||\n                        key.toLowerCase().includes(\"secret\") ||\n                        key.toLowerCase().includes(\"token\")) &&\n                        typeof value === \"string\") {\n                        envVars[key] =\n                            value.slice(0, 2) +\n                                \"*\".repeat(value.length - 4) +\n                                value.slice(-2);\n                    }\n                    else {\n                        envVars[key] = value;\n                    }\n                }\n            }\n        }\n    }\n    catch (e) {\n        // Catch any errors that might occur while trying to access environment variables\n    }\n    return envVars;\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\nfunction getLangSmithEnvironmentVariable(name) {\n    return (getEnvironmentVariable(`LANGSMITH_${name}`) ||\n        getEnvironmentVariable(`LANGCHAIN_${name}`));\n}\nfunction setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */\nfunction getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\",\n    ];\n    const shas = {};\n    for (const env of common_release_envs) {\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\nfunction getOtelEnabled() {\n    return (getEnvironmentVariable(\"OTEL_ENABLED\") === \"true\" ||\n        getLangSmithEnvironmentVariable(\"OTEL_ENABLED\") === \"true\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzBDO0FBQzFDO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdEQUFnRCxLQUFLO0FBQ3JELDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2F2ZXJ5L3Rlc3QyL2FnZW50LWNoYXQtdWkvbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2Vudi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbmxpbmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZsZXhkaW5lc2gvYnJvd3Nlci1vci1ub2RlXG5pbXBvcnQgeyBfX3ZlcnNpb25fXyB9IGZyb20gXCIuLi9pbmRleC5qc1wiO1xubGV0IGdsb2JhbEVudjtcbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnQgY29uc3QgaXNXZWJXb3JrZXIgPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVcIjtcbmV4cG9ydCBjb25zdCBpc0pzRG9tID0gKCkgPT4gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hbWUgPT09IFwibm9kZWpzXCIpIHx8XG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcImpzZG9tXCIpKTtcbi8vIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb24gcHJvdmlkZXMgYSBgRGVub2AgZ2xvYmFsIG9iamVjdFxuLy8gd2l0aG91dCBgdmVyc2lvbmAgcHJvcGVydHlcbmV4cG9ydCBjb25zdCBpc0Rlbm8gPSAoKSA9PiB0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8vIE1hcmsgbm90LWFzLW5vZGUgaWYgaW4gU3VwYWJhc2UgRWRnZSBGdW5jdGlvblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICgpID0+IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgIWlzRGVubygpO1xuZXhwb3J0IGNvbnN0IGdldEVudiA9ICgpID0+IHtcbiAgICBpZiAoZ2xvYmFsRW52KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxFbnY7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQnVuIHR5cGVzIGFyZSBub3QgaW1wb3J0ZWQgZHVlIHRvIGNvbmZsaWN0cyB3aXRoIE5vZGUgdHlwZXNcbiAgICBpZiAodHlwZW9mIEJ1biAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImJ1blwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImJyb3dzZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOb2RlKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJub2RlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzV2ViV29ya2VyKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJ3ZWJ3b3JrZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNKc0RvbSgpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwianNkb21cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZW5vKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJkZW5vXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxFbnYgPSBcIm90aGVyXCI7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxFbnY7XG59O1xubGV0IHJ1bnRpbWVFbnZpcm9ubWVudDtcbmV4cG9ydCBmdW5jdGlvbiBnZXRSdW50aW1lRW52aXJvbm1lbnQoKSB7XG4gICAgaWYgKHJ1bnRpbWVFbnZpcm9ubWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVudiA9IGdldEVudigpO1xuICAgICAgICBjb25zdCByZWxlYXNlRW52ID0gZ2V0U2hhcygpO1xuICAgICAgICBydW50aW1lRW52aXJvbm1lbnQgPSB7XG4gICAgICAgICAgICBsaWJyYXJ5OiBcImxhbmdzbWl0aFwiLFxuICAgICAgICAgICAgcnVudGltZTogZW52LFxuICAgICAgICAgICAgc2RrOiBcImxhbmdzbWl0aC1qc1wiLFxuICAgICAgICAgICAgc2RrX3ZlcnNpb246IF9fdmVyc2lvbl9fLFxuICAgICAgICAgICAgLi4ucmVsZWFzZUVudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bnRpbWVFbnZpcm9ubWVudDtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBMYW5nU21pdGgtc3BlY2lmaWMgbWV0YWRhdGEgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogIC0gQSByZWNvcmQgb2YgTGFuZ1NtaXRoLXNwZWNpZmljIG1ldGFkYXRhIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdTbWl0aEVudlZhcnNNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBhbGxFbnZWYXJzID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZXMoKTtcbiAgICBjb25zdCBlbnZWYXJzID0ge307XG4gICAgY29uc3QgZXhjbHVkZWQgPSBbXG4gICAgICAgIFwiTEFOR0NIQUlOX0FQSV9LRVlcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9QUk9KRUNUXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1NFU1NJT05cIixcbiAgICAgICAgXCJMQU5HU01JVEhfQVBJX0tFWVwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9FTkRQT0lOVFwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR1NNSVRIX1BST0pFQ1RcIixcbiAgICAgICAgXCJMQU5HU01JVEhfU0VTU0lPTlwiLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsRW52VmFycykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgIWV4Y2x1ZGVkLmluY2x1ZGVzKGtleSkgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImtleVwiKSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic2VjcmV0XCIpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ0b2tlblwiKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJMQU5HQ0hBSU5fUkVWSVNJT05fSURcIikge1xuICAgICAgICAgICAgICAgIGVudlZhcnNbXCJyZXZpc2lvbl9pZFwiXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW52VmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudlZhcnM7XG59XG4vKipcbiAqIFJldHJpZXZlcyBvbmx5IHRoZSBMYW5nQ2hhaW4vTGFuZ1NtaXRoLXByZWZpeGVkIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gY29weWluZyBhbGwgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogIC0gQSByZWNvcmQgb2YgTGFuZ0NoYWluL0xhbmdTbWl0aCBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlcygpIHtcbiAgICBjb25zdCBlbnZWYXJzID0ge307XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIE5vZGUuanMgZW52aXJvbm1lbnRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9jZXNzLmVudikpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGtleS5zdGFydHNXaXRoKFwiTEFOR0NIQUlOX1wiKSB8fCBrZXkuc3RhcnRzV2l0aChcIkxBTkdTTUlUSF9cIikpICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImtleVwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzZWNyZXRcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwidG9rZW5cIikpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudlZhcnNba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoMCwgMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIipcIi5yZXBlYXQodmFsdWUubGVuZ3RoIC0gNCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgtMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDYXRjaCBhbnkgZXJyb3JzIHRoYXQgbWlnaHQgb2NjdXIgd2hpbGUgdHJ5aW5nIHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICB9XG4gICAgcmV0dXJuIGVudlZhcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9od2NoYXNlMTcvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIHJldHVybiAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShgTEFOR1NNSVRIXyR7bmFtZX1gKSB8fFxuICAgICAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGBMQU5HQ0hBSU5fJHtuYW1lfWApKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICBwcm9jZXNzLmVudltuYW1lXSA9IHZhbHVlO1xuICAgIH1cbn1cbmxldCBjYWNoZWRDb21taXRTSEFzO1xuLyoqXG4gKiBHZXQgdGhlIEdpdCBjb21taXQgU0hBIGZyb20gY29tbW9uIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogdXNlZCBieSBkaWZmZXJlbnQgQ0kvQ0QgcGxhdGZvcm1zLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIEdpdCBjb21taXQgU0hBIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFzKCkge1xuICAgIGlmIChjYWNoZWRDb21taXRTSEFzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZENvbW1pdFNIQXM7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbl9yZWxlYXNlX2VudnMgPSBbXG4gICAgICAgIFwiVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiTkVYVF9QVUJMSUNfVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ09NTUlUX1JFRlwiLFxuICAgICAgICBcIlJFTkRFUl9HSVRfQ09NTUlUXCIsXG4gICAgICAgIFwiQ0lfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIkNJUkNMRV9TSEExXCIsXG4gICAgICAgIFwiQ0ZfUEFHRVNfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIlJFQUNUX0FQUF9HSVRfU0hBXCIsXG4gICAgICAgIFwiU09VUkNFX1ZFUlNJT05cIixcbiAgICAgICAgXCJHSVRIVUJfU0hBXCIsXG4gICAgICAgIFwiVFJBVklTX0NPTU1JVFwiLFxuICAgICAgICBcIkdJVF9DT01NSVRcIixcbiAgICAgICAgXCJCVUlMRF9WQ1NfTlVNQkVSXCIsXG4gICAgICAgIFwiYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3JldmlzaW9uXCIsXG4gICAgICAgIFwiQnVpbGQuU291cmNlVmVyc2lvblwiLFxuICAgICAgICBcIkJJVEJVQ0tFVF9DT01NSVRcIixcbiAgICAgICAgXCJEUk9ORV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiU0VNQVBIT1JFX0dJVF9TSEFcIixcbiAgICAgICAgXCJCVUlMREtJVEVfQ09NTUlUXCIsXG4gICAgXTtcbiAgICBjb25zdCBzaGFzID0ge307XG4gICAgZm9yIChjb25zdCBlbnYgb2YgY29tbW9uX3JlbGVhc2VfZW52cykge1xuICAgICAgICBjb25zdCBlbnZWYXIgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGVudik7XG4gICAgICAgIGlmIChlbnZWYXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2hhc1tlbnZdID0gZW52VmFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhY2hlZENvbW1pdFNIQXMgPSBzaGFzO1xuICAgIHJldHVybiBzaGFzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE90ZWxFbmFibGVkKCkge1xuICAgIHJldHVybiAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIk9URUxfRU5BQkxFRFwiKSA9PT0gXCJ0cnVlXCIgfHxcbiAgICAgICAgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIk9URUxfRU5BQkxFRFwiKSA9PT0gXCJ0cnVlXCIpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/env.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/error.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/error.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictingEndpointsError: () => (/* binding */ ConflictingEndpointsError),\n/* harmony export */   LangSmithConflictError: () => (/* binding */ LangSmithConflictError),\n/* harmony export */   LangSmithNotFoundError: () => (/* binding */ LangSmithNotFoundError),\n/* harmony export */   isConflictingEndpointsError: () => (/* binding */ isConflictingEndpointsError),\n/* harmony export */   isLangSmithNotFoundError: () => (/* binding */ isLangSmithNotFoundError),\n/* harmony export */   printErrorStackTrace: () => (/* binding */ printErrorStackTrace),\n/* harmony export */   raiseForStatus: () => (/* binding */ raiseForStatus)\n/* harmony export */ });\nfunction getErrorStackTrace(e) {\n    if (typeof e !== \"object\" || e == null)\n        return undefined;\n    if (!(\"stack\" in e) || typeof e.stack !== \"string\")\n        return undefined;\n    let stack = e.stack;\n    const prevLine = `${e}`;\n    if (stack.startsWith(prevLine)) {\n        stack = stack.slice(prevLine.length);\n    }\n    if (stack.startsWith(\"\\n\")) {\n        stack = stack.slice(1);\n    }\n    return stack;\n}\nfunction printErrorStackTrace(e) {\n    const stack = getErrorStackTrace(e);\n    if (stack == null)\n        return;\n    console.error(stack);\n}\n/**\n * LangSmithConflictError\n *\n * Represents an error that occurs when there's a conflict during an operation,\n * typically corresponding to HTTP 409 status code responses.\n *\n * This error is thrown when an attempt to create or modify a resource conflicts\n * with the current state of the resource on the server. Common scenarios include:\n * - Attempting to create a resource that already exists\n * - Trying to update a resource that has been modified by another process\n * - Violating a uniqueness constraint in the data\n *\n * @extends Error\n *\n * @example\n * try {\n *   await createProject(\"existingProject\");\n * } catch (error) {\n *   if (error instanceof ConflictError) {\n *     console.log(\"A conflict occurred:\", error.message);\n *     // Handle the conflict, e.g., by suggesting a different project name\n *   } else {\n *     // Handle other types of errors\n *   }\n * }\n *\n * @property {string} name - Always set to 'ConflictError' for easy identification\n * @property {string} message - Detailed error message including server response\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409\n */\nclass LangSmithConflictError extends Error {\n    constructor(message) {\n        super(message);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"LangSmithConflictError\";\n        this.status = 409;\n    }\n}\n/**\n * LangSmithNotFoundError\n *\n * Represents an error that occurs when a requested resource is not found,\n * typically corresponding to HTTP 404 status code responses.\n *\n * @extends Error\n */\nclass LangSmithNotFoundError extends Error {\n    constructor(message) {\n        super(message);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"LangSmithNotFoundError\";\n        this.status = 404;\n    }\n}\nfunction isLangSmithNotFoundError(error) {\n    return (error != null &&\n        typeof error === \"object\" &&\n        \"name\" in error &&\n        error?.name === \"LangSmithNotFoundError\");\n}\n/**\n * Throws an appropriate error based on the response status and body.\n *\n * @param response - The fetch Response object\n * @param context - Additional context to include in the error message (e.g., operation being performed)\n * @throws {LangSmithConflictError} When the response status is 409\n * @throws {Error} For all other non-ok responses\n */\nasync function raiseForStatus(response, context, consumeOnSuccess) {\n    let errorBody;\n    if (response.ok) {\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        if (consumeOnSuccess) {\n            errorBody = await response.text();\n        }\n        return;\n    }\n    if (response.status === 403) {\n        try {\n            const errorData = await response.json();\n            const errorCode = errorData?.error;\n            if (errorCode === \"org_scoped_key_requires_workspace\") {\n                errorBody =\n                    \"This API key is org-scoped and requires workspace specification. \" +\n                        \"Please provide 'workspaceId' parameter, \" +\n                        \"or set LANGSMITH_WORKSPACE_ID environment variable.\";\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            const errorWithStatus = new Error(`${response.status} ${response.statusText}`);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            errorWithStatus.status = response?.status;\n            throw errorWithStatus;\n        }\n    }\n    if (errorBody === undefined) {\n        try {\n            errorBody = await response.text();\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            errorBody = \"\";\n        }\n    }\n    const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Message: ${errorBody}`;\n    if (response.status === 404) {\n        throw new LangSmithNotFoundError(fullMessage);\n    }\n    if (response.status === 409) {\n        throw new LangSmithConflictError(fullMessage);\n    }\n    const err = new Error(fullMessage);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    err.status = response.status;\n    throw err;\n}\nconst ERR_CONFLICTING_ENDPOINTS = \"ERR_CONFLICTING_ENDPOINTS\";\nclass ConflictingEndpointsError extends Error {\n    constructor() {\n        super(\"You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT \" +\n            \"and LANGSMITH_RUNS_ENDPOINTS.\");\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: ERR_CONFLICTING_ENDPOINTS\n        });\n        this.name = \"ConflictingEndpointsError\"; // helpful in logs\n    }\n}\nfunction isConflictingEndpointsError(err) {\n    return (typeof err === \"object\" &&\n        err !== null &&\n        err.code === ERR_CONFLICTING_ENDPOINTS);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCLEVBQUUsb0JBQW9CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUSxxQkFBcUIsZ0JBQWdCLEtBQUssb0JBQW9CLGFBQWEsVUFBVTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXZlcnkvdGVzdDIvYWdlbnQtY2hhdC11aS9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0RXJyb3JTdGFja1RyYWNlKGUpIHtcbiAgICBpZiAodHlwZW9mIGUgIT09IFwib2JqZWN0XCIgfHwgZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICghKFwic3RhY2tcIiBpbiBlKSB8fCB0eXBlb2YgZS5zdGFjayAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgc3RhY2sgPSBlLnN0YWNrO1xuICAgIGNvbnN0IHByZXZMaW5lID0gYCR7ZX1gO1xuICAgIGlmIChzdGFjay5zdGFydHNXaXRoKHByZXZMaW5lKSkge1xuICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKHByZXZMaW5lLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChzdGFjay5zdGFydHNXaXRoKFwiXFxuXCIpKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcmludEVycm9yU3RhY2tUcmFjZShlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBnZXRFcnJvclN0YWNrVHJhY2UoZSk7XG4gICAgaWYgKHN0YWNrID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zb2xlLmVycm9yKHN0YWNrKTtcbn1cbi8qKlxuICogTGFuZ1NtaXRoQ29uZmxpY3RFcnJvclxuICpcbiAqIFJlcHJlc2VudHMgYW4gZXJyb3IgdGhhdCBvY2N1cnMgd2hlbiB0aGVyZSdzIGEgY29uZmxpY3QgZHVyaW5nIGFuIG9wZXJhdGlvbixcbiAqIHR5cGljYWxseSBjb3JyZXNwb25kaW5nIHRvIEhUVFAgNDA5IHN0YXR1cyBjb2RlIHJlc3BvbnNlcy5cbiAqXG4gKiBUaGlzIGVycm9yIGlzIHRocm93biB3aGVuIGFuIGF0dGVtcHQgdG8gY3JlYXRlIG9yIG1vZGlmeSBhIHJlc291cmNlIGNvbmZsaWN0c1xuICogd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcmVzb3VyY2Ugb24gdGhlIHNlcnZlci4gQ29tbW9uIHNjZW5hcmlvcyBpbmNsdWRlOlxuICogLSBBdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIHJlc291cmNlIHRoYXQgYWxyZWFkeSBleGlzdHNcbiAqIC0gVHJ5aW5nIHRvIHVwZGF0ZSBhIHJlc291cmNlIHRoYXQgaGFzIGJlZW4gbW9kaWZpZWQgYnkgYW5vdGhlciBwcm9jZXNzXG4gKiAtIFZpb2xhdGluZyBhIHVuaXF1ZW5lc3MgY29uc3RyYWludCBpbiB0aGUgZGF0YVxuICpcbiAqIEBleHRlbmRzIEVycm9yXG4gKlxuICogQGV4YW1wbGVcbiAqIHRyeSB7XG4gKiAgIGF3YWl0IGNyZWF0ZVByb2plY3QoXCJleGlzdGluZ1Byb2plY3RcIik7XG4gKiB9IGNhdGNoIChlcnJvcikge1xuICogICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb25mbGljdEVycm9yKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJBIGNvbmZsaWN0IG9jY3VycmVkOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAqICAgICAvLyBIYW5kbGUgdGhlIGNvbmZsaWN0LCBlLmcuLCBieSBzdWdnZXN0aW5nIGEgZGlmZmVyZW50IHByb2plY3QgbmFtZVxuICogICB9IGVsc2Uge1xuICogICAgIC8vIEhhbmRsZSBvdGhlciB0eXBlcyBvZiBlcnJvcnNcbiAqICAgfVxuICogfVxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gQWx3YXlzIHNldCB0byAnQ29uZmxpY3RFcnJvcicgZm9yIGVhc3kgaWRlbnRpZmljYXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gRGV0YWlsZWQgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgc2VydmVyIHJlc3BvbnNlXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy80MDlcbiAqL1xuZXhwb3J0IGNsYXNzIExhbmdTbWl0aENvbmZsaWN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTGFuZ1NtaXRoQ29uZmxpY3RFcnJvclwiO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDQwOTtcbiAgICB9XG59XG4vKipcbiAqIExhbmdTbWl0aE5vdEZvdW5kRXJyb3JcbiAqXG4gKiBSZXByZXNlbnRzIGFuIGVycm9yIHRoYXQgb2NjdXJzIHdoZW4gYSByZXF1ZXN0ZWQgcmVzb3VyY2UgaXMgbm90IGZvdW5kLFxuICogdHlwaWNhbGx5IGNvcnJlc3BvbmRpbmcgdG8gSFRUUCA0MDQgc3RhdHVzIGNvZGUgcmVzcG9uc2VzLlxuICpcbiAqIEBleHRlbmRzIEVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBMYW5nU21pdGhOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkxhbmdTbWl0aE5vdEZvdW5kRXJyb3JcIjtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSA0MDQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTGFuZ1NtaXRoTm90Rm91bmRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiAoZXJyb3IgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgXCJuYW1lXCIgaW4gZXJyb3IgJiZcbiAgICAgICAgZXJyb3I/Lm5hbWUgPT09IFwiTGFuZ1NtaXRoTm90Rm91bmRFcnJvclwiKTtcbn1cbi8qKlxuICogVGhyb3dzIGFuIGFwcHJvcHJpYXRlIGVycm9yIGJhc2VkIG9uIHRoZSByZXNwb25zZSBzdGF0dXMgYW5kIGJvZHkuXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIGZldGNoIFJlc3BvbnNlIG9iamVjdFxuICogQHBhcmFtIGNvbnRleHQgLSBBZGRpdGlvbmFsIGNvbnRleHQgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IgbWVzc2FnZSAoZS5nLiwgb3BlcmF0aW9uIGJlaW5nIHBlcmZvcm1lZClcbiAqIEB0aHJvd3Mge0xhbmdTbWl0aENvbmZsaWN0RXJyb3J9IFdoZW4gdGhlIHJlc3BvbnNlIHN0YXR1cyBpcyA0MDlcbiAqIEB0aHJvd3Mge0Vycm9yfSBGb3IgYWxsIG90aGVyIG5vbi1vayByZXNwb25zZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBjb250ZXh0LCBjb25zdW1lT25TdWNjZXNzKSB7XG4gICAgbGV0IGVycm9yQm9keTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgICAgIGlmIChjb25zdW1lT25TdWNjZXNzKSB7XG4gICAgICAgICAgICBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IGVycm9yRGF0YT8uZXJyb3I7XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09PSBcIm9yZ19zY29wZWRfa2V5X3JlcXVpcmVzX3dvcmtzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JCb2R5ID1cbiAgICAgICAgICAgICAgICAgICAgXCJUaGlzIEFQSSBrZXkgaXMgb3JnLXNjb3BlZCBhbmQgcmVxdWlyZXMgd29ya3NwYWNlIHNwZWNpZmljYXRpb24uIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIHByb3ZpZGUgJ3dvcmtzcGFjZUlkJyBwYXJhbWV0ZXIsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwib3Igc2V0IExBTkdTTUlUSF9XT1JLU1BBQ0VfSUQgZW52aXJvbm1lbnQgdmFyaWFibGUuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvcldpdGhTdGF0dXMgPSBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZXJyb3JXaXRoU3RhdHVzLnN0YXR1cyA9IHJlc3BvbnNlPy5zdGF0dXM7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcldpdGhTdGF0dXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9yQm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckJvZHkgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZ1bGxNZXNzYWdlID0gYEZhaWxlZCB0byAke2NvbnRleHR9LiBSZWNlaXZlZCBzdGF0dXMgWyR7cmVzcG9uc2Uuc3RhdHVzfV06ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0uIE1lc3NhZ2U6ICR7ZXJyb3JCb2R5fWA7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHRocm93IG5ldyBMYW5nU21pdGhOb3RGb3VuZEVycm9yKGZ1bGxNZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgIHRocm93IG5ldyBMYW5nU21pdGhDb25mbGljdEVycm9yKGZ1bGxNZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGZ1bGxNZXNzYWdlKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVyci5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgdGhyb3cgZXJyO1xufVxuY29uc3QgRVJSX0NPTkZMSUNUSU5HX0VORFBPSU5UUyA9IFwiRVJSX0NPTkZMSUNUSU5HX0VORFBPSU5UU1wiO1xuZXhwb3J0IGNsYXNzIENvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiWW91IGNhbm5vdCBwcm92aWRlIGJvdGggTEFOR1NNSVRIX0VORFBPSU5UIC8gTEFOR0NIQUlOX0VORFBPSU5UIFwiICtcbiAgICAgICAgICAgIFwiYW5kIExBTkdTTUlUSF9SVU5TX0VORFBPSU5UUy5cIik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IEVSUl9DT05GTElDVElOR19FTkRQT0lOVFNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvclwiOyAvLyBoZWxwZnVsIGluIGxvZ3NcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb25mbGljdGluZ0VuZHBvaW50c0Vycm9yKGVycikge1xuICAgIHJldHVybiAodHlwZW9mIGVyciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBlcnIgIT09IG51bGwgJiZcbiAgICAgICAgZXJyLmNvZGUgPT09IEVSUl9DT05GTElDVElOR19FTkRQT0lOVFMpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/env.js */ \"(ssr)/./node_modules/langsmith/dist/utils/env.js\");\n/* eslint-disable */\n// @ts-nocheck\n\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = { result: \"[Circular]\" };\nvar arr = [];\nvar replacerStack = [];\nconst encoder = new TextEncoder();\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER,\n    };\n}\nfunction encodeString(str) {\n    return encoder.encode(str);\n}\n// Shared function to handle well-known types\nfunction serializeWellKnownTypes(val) {\n    if (val && typeof val === \"object\" && val !== null) {\n        if (val instanceof Map) {\n            return Object.fromEntries(val);\n        }\n        else if (val instanceof Set) {\n            return Array.from(val);\n        }\n        else if (val instanceof Date) {\n            return val.toISOString();\n        }\n        else if (val instanceof RegExp) {\n            return val.toString();\n        }\n        else if (val instanceof Error) {\n            return {\n                name: val.name,\n                message: val.message,\n            };\n        }\n    }\n    else if (typeof val === \"bigint\") {\n        return val.toString();\n    }\n    return val;\n}\n// Default replacer function to handle well-known types\nfunction createDefaultReplacer(userReplacer) {\n    return function (key, val) {\n        // Apply user replacer first if provided\n        if (userReplacer) {\n            const userResult = userReplacer.call(this, key, val);\n            // If user replacer returned undefined, fall back to our serialization\n            if (userResult !== undefined) {\n                return userResult;\n            }\n        }\n        // Fall back to our well-known type handling\n        return serializeWellKnownTypes(val);\n    };\n}\n// Regular stringify\nfunction serialize(obj, errorContext, replacer, spacer, options) {\n    try {\n        const str = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);\n        return encodeString(str);\n    }\n    catch (e) {\n        // Fall back to more complex stringify if circular reference\n        if (!e.message?.includes(\"Converting circular structure to JSON\")) {\n            console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n            return encodeString(\"[Unserializable]\");\n        }\n        (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"SUPPRESS_CIRCULAR_JSON_WARNINGS\") !==\n            \"true\" &&\n            console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n        if (typeof options === \"undefined\") {\n            options = defaultOptions();\n        }\n        decirc(obj, \"\", 0, [], undefined, 0, options);\n        let res;\n        try {\n            if (replacerStack.length === 0) {\n                res = JSON.stringify(obj, replacer, spacer);\n            }\n            else {\n                res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n            }\n        }\n        catch (_) {\n            return encodeString(\"[unable to serialize, circular reference is too complex to analyze]\");\n        }\n        finally {\n            while (arr.length !== 0) {\n                const part = arr.pop();\n                if (part.length === 4) {\n                    Object.defineProperty(part[0], part[1], part[3]);\n                }\n                else {\n                    part[0][part[1]] = part[2];\n                }\n            }\n        }\n        return encodeString(res);\n    }\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, { value: replace });\n            arr.push([parent, k, val, propertyDescriptor]);\n        }\n        else {\n            replacerStack.push([val, k, replace]);\n        }\n    }\n    else {\n        parent[k] = replace;\n        arr.push([parent, k, val]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            var keys = Object.keys(val);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        }\n        else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    }\n    catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    }\n    finally {\n        // Ensure that we restore the object as it was.\n        while (arr.length !== 0) {\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            }\n            else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        }\n        catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([parent, k, val]);\n                parent[k] = tmp;\n            }\n            else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer =\n        typeof replacer !== \"undefined\"\n            ? replacer\n            : function (k, v) {\n                return v;\n            };\n    return function (key, val) {\n        if (replacerStack.length > 0) {\n            for (var i = 0; i < replacerStack.length; i++) {\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDcUU7QUFDckU7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDZCQUE2QixhQUFhLE9BQU87QUFDaEk7QUFDQTtBQUNBLFFBQVEsOEVBQStCO0FBQ3ZDO0FBQ0EsZ0hBQWdILDZCQUE2QixhQUFhLE9BQU87QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2F2ZXJ5L3Rlc3QyL2FnZW50LWNoYXQtdWkvbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQgeyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2Vudi5qc1wiO1xudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9IFwiWy4uLl1cIjtcbnZhciBDSVJDVUxBUl9SRVBMQUNFX05PREUgPSB7IHJlc3VsdDogXCJbQ2lyY3VsYXJdXCIgfTtcbnZhciBhcnIgPSBbXTtcbnZhciByZXBsYWNlclN0YWNrID0gW107XG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBkZWZhdWx0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXB0aExpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgZWRnZXNMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoc3RyKTtcbn1cbi8vIFNoYXJlZCBmdW5jdGlvbiB0byBoYW5kbGUgd2VsbC1rbm93biB0eXBlc1xuZnVuY3Rpb24gc2VyaWFsaXplV2VsbEtub3duVHlwZXModmFsKSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB2YWwubmFtZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB2YWwubWVzc2FnZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICByZXR1cm4gdmFsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vLyBEZWZhdWx0IHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB3ZWxsLWtub3duIHR5cGVzXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0UmVwbGFjZXIodXNlclJlcGxhY2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICAvLyBBcHBseSB1c2VyIHJlcGxhY2VyIGZpcnN0IGlmIHByb3ZpZGVkXG4gICAgICAgIGlmICh1c2VyUmVwbGFjZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJSZXN1bHQgPSB1c2VyUmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbCk7XG4gICAgICAgICAgICAvLyBJZiB1c2VyIHJlcGxhY2VyIHJldHVybmVkIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG91ciBzZXJpYWxpemF0aW9uXG4gICAgICAgICAgICBpZiAodXNlclJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIG91ciB3ZWxsLWtub3duIHR5cGUgaGFuZGxpbmdcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVdlbGxLbm93blR5cGVzKHZhbCk7XG4gICAgfTtcbn1cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKG9iaiwgZXJyb3JDb250ZXh0LCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCBjcmVhdGVEZWZhdWx0UmVwbGFjZXIocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKHN0cik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBtb3JlIGNvbXBsZXggc3RyaW5naWZ5IGlmIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgICBpZiAoIWUubWVzc2FnZT8uaW5jbHVkZXMoXCJDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OXCIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtXQVJOSU5HXTogTGFuZ1NtaXRoIHJlY2VpdmVkIHVuc2VyaWFsaXphYmxlIHZhbHVlLiR7ZXJyb3JDb250ZXh0ID8gYFxcbkNvbnRleHQ6ICR7ZXJyb3JDb250ZXh0fWAgOiBcIlwifWApO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVN0cmluZyhcIltVbnNlcmlhbGl6YWJsZV1cIik7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlNVUFBSRVNTX0NJUkNVTEFSX0pTT05fV0FSTklOR1NcIikgIT09XG4gICAgICAgICAgICBcInRydWVcIiAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbV0FSTklOR106IExhbmdTbWl0aCByZWNlaXZlZCBjaXJjdWxhciBKU09OLiBUaGlzIHdpbGwgZGVjcmVhc2UgdHJhY2VyIHBlcmZvcm1hbmNlLiAke2Vycm9yQ29udGV4dCA/IGBcXG5Db250ZXh0OiAke2Vycm9yQ29udGV4dH1gIDogXCJcIn1gKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNpcmMob2JqLCBcIlwiLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKFwiW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcocmVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRSZXBsYWNlKHJlcGxhY2UsIHZhbCwgaywgcGFyZW50KSB7XG4gICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKTtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7IHZhbHVlOiByZXBsYWNlIH0pO1xuICAgICAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmVudFtrXSA9IHJlcGxhY2U7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBkZXB0aCArPSAxO1xuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgd2VsbC1rbm93biB0eXBlcyBiZWZvcmUgT2JqZWN0LmtleXMgaXRlcmF0aW9uXG4gICAgICAgICAgICB2YWwgPSBzZXJpYWxpemVXZWxsS25vd25UeXBlcyh2YWwpO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBkZWNpcmModmFsW2tleV0sIGtleSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH1cbn1cbi8vIFN0YWJsZS1zdHJpbmdpZnlcbmZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNTdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpO1xuICAgIH1cbiAgICB2YXIgdG1wID0gZGV0ZXJtaW5pc3RpY0RlY2lyYyhvYmosIFwiXCIsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpIHx8IG9iajtcbiAgICB2YXIgcmVzO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFwiW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXVwiKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc3RvcmUgdGhlIG9iamVjdCBhcyBpdCB3YXMuXG4gICAgICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICAgIGRlcHRoICs9IDE7XG4gICAgdmFyIGk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWwpO1xuICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRldGVybWluaXN0aWNEZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgd2VsbC1rbm93biB0eXBlcyBiZWZvcmUgT2JqZWN0LmtleXMgaXRlcmF0aW9uXG4gICAgICAgICAgICB2YWwgPSBzZXJpYWxpemVXZWxsS25vd25UeXBlcyh2YWwpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG9iamVjdCBpbiB0aGUgcmVxdWlyZWQgd2F5XG4gICAgICAgICAgICB2YXIgdG1wID0ge307XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0bXBba2V5XSA9IHZhbFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRba10gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH1cbn1cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICAgIHJlcGxhY2VyID1cbiAgICAgICAgdHlwZW9mIHJlcGxhY2VyICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IHJlcGxhY2VyXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNlclN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0WzFdID09PSBrZXkgJiYgcGFydFswXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnRbMl07XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VyU3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpO1xuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/is-network-error/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/is-network-error/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isNetworkError)\n/* harmony export */ });\n/* eslint-disable */\n// @ts-nocheck\n// is-network-error vendored to avoid import issues\n// Source: https://github.com/sindresorhus/is-network-error\nconst objectToString = Object.prototype.toString;\nconst isError = (value) => objectToString.call(value) === \"[object Error]\";\nconst errorMessages = new Set([\n    \"network error\", // Chrome\n    \"Failed to fetch\", // Chrome\n    \"NetworkError when attempting to fetch resource.\", // Firefox\n    \"The Internet connection appears to be offline.\", // Safari 16\n    \"Network request failed\", // `cross-fetch`\n    \"fetch failed\", // Undici (Node.js)\n    \"terminated\", // Undici (Node.js)\n    \" A network error occurred.\", // Bun (WebKit)\n    \"Network connection lost\", // Cloudflare Workers (fetch)\n]);\nfunction isNetworkError(error) {\n    const isValid = error &&\n        isError(error) &&\n        error.name === \"TypeError\" &&\n        typeof error.message === \"string\";\n    if (!isValid) {\n        return false;\n    }\n    const { message, stack } = error;\n    // Safari 17+ has generic message but no stack for network errors\n    if (message === \"Load failed\") {\n        return (stack === undefined ||\n            // Sentry adds its own stack trace to the fetch error, so also check for that\n            \"__sentry_captured__\" in error);\n    }\n    // Deno network errors start with specific text\n    if (message.startsWith(\"error sending request for url\")) {\n        return true;\n    }\n    // Standard network error messages\n    return errorMessages.has(message);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvaXMtbmV0d29yay1lcnJvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2F2ZXJ5L3Rlc3QyL2FnZW50LWNoYXQtdWkvbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2lzLW5ldHdvcmstZXJyb3IvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG4vLyBpcy1uZXR3b3JrLWVycm9yIHZlbmRvcmVkIHRvIGF2b2lkIGltcG9ydCBpc3N1ZXNcbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9pcy1uZXR3b3JrLWVycm9yXG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCBpc0Vycm9yID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IEVycm9yXVwiO1xuY29uc3QgZXJyb3JNZXNzYWdlcyA9IG5ldyBTZXQoW1xuICAgIFwibmV0d29yayBlcnJvclwiLCAvLyBDaHJvbWVcbiAgICBcIkZhaWxlZCB0byBmZXRjaFwiLCAvLyBDaHJvbWVcbiAgICBcIk5ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuXCIsIC8vIEZpcmVmb3hcbiAgICBcIlRoZSBJbnRlcm5ldCBjb25uZWN0aW9uIGFwcGVhcnMgdG8gYmUgb2ZmbGluZS5cIiwgLy8gU2FmYXJpIDE2XG4gICAgXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkXCIsIC8vIGBjcm9zcy1mZXRjaGBcbiAgICBcImZldGNoIGZhaWxlZFwiLCAvLyBVbmRpY2kgKE5vZGUuanMpXG4gICAgXCJ0ZXJtaW5hdGVkXCIsIC8vIFVuZGljaSAoTm9kZS5qcylcbiAgICBcIiBBIG5ldHdvcmsgZXJyb3Igb2NjdXJyZWQuXCIsIC8vIEJ1biAoV2ViS2l0KVxuICAgIFwiTmV0d29yayBjb25uZWN0aW9uIGxvc3RcIiwgLy8gQ2xvdWRmbGFyZSBXb3JrZXJzIChmZXRjaClcbl0pO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IoZXJyb3IpIHtcbiAgICBjb25zdCBpc1ZhbGlkID0gZXJyb3IgJiZcbiAgICAgICAgaXNFcnJvcihlcnJvcikgJiZcbiAgICAgICAgZXJyb3IubmFtZSA9PT0gXCJUeXBlRXJyb3JcIiAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gXCJzdHJpbmdcIjtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IG1lc3NhZ2UsIHN0YWNrIH0gPSBlcnJvcjtcbiAgICAvLyBTYWZhcmkgMTcrIGhhcyBnZW5lcmljIG1lc3NhZ2UgYnV0IG5vIHN0YWNrIGZvciBuZXR3b3JrIGVycm9yc1xuICAgIGlmIChtZXNzYWdlID09PSBcIkxvYWQgZmFpbGVkXCIpIHtcbiAgICAgICAgcmV0dXJuIChzdGFjayA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAvLyBTZW50cnkgYWRkcyBpdHMgb3duIHN0YWNrIHRyYWNlIHRvIHRoZSBmZXRjaCBlcnJvciwgc28gYWxzbyBjaGVjayBmb3IgdGhhdFxuICAgICAgICAgICAgXCJfX3NlbnRyeV9jYXB0dXJlZF9fXCIgaW4gZXJyb3IpO1xuICAgIH1cbiAgICAvLyBEZW5vIG5ldHdvcmsgZXJyb3JzIHN0YXJ0IHdpdGggc3BlY2lmaWMgdGV4dFxuICAgIGlmIChtZXNzYWdlLnN0YXJ0c1dpdGgoXCJlcnJvciBzZW5kaW5nIHJlcXVlc3QgZm9yIHVybFwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gU3RhbmRhcmQgbmV0d29yayBlcnJvciBtZXNzYWdlc1xuICAgIHJldHVybiBlcnJvck1lc3NhZ2VzLmhhcyhtZXNzYWdlKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/is-network-error/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),\n/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)\n/* harmony export */ });\nfunction isLangChainMessage(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmessage) {\n    return typeof message?._getType === \"function\";\n}\nfunction convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: { content: message.content },\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs &&\n        Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = { ...message.additional_kwargs };\n    }\n    return converted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9tZXNzYWdlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNMYW5nQ2hhaW5NZXNzYWdlKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbm1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2U/Ll9nZXRUeXBlID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUobWVzc2FnZSkge1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IHtcbiAgICAgICAgdHlwZTogbWVzc2FnZS5fZ2V0VHlwZSgpLFxuICAgICAgICBkYXRhOiB7IGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCB9LFxuICAgIH07XG4gICAgLy8gQ2hlY2sgZm9yIHByZXNlbmNlIG9mIGtleXMgaW4gYWRkaXRpb25hbF9rd2FyZ3NcbiAgICBpZiAobWVzc2FnZT8uYWRkaXRpb25hbF9rd2FyZ3MgJiZcbiAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncykubGVuZ3RoID4gMCkge1xuICAgICAgICBjb252ZXJ0ZWQuZGF0YS5hZGRpdGlvbmFsX2t3YXJncyA9IHsgLi4ubWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncyB9O1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVkO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/messages.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/p-retry/index.js":
/*!************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/p-retry/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   \"default\": () => (/* binding */ pRetry),\n/* harmony export */   makeRetriable: () => (/* binding */ makeRetriable)\n/* harmony export */ });\n/* harmony import */ var _is_network_error_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../is-network-error/index.js */ \"(ssr)/./node_modules/langsmith/dist/utils/is-network-error/index.js\");\n/* eslint-disable */\n// @ts-nocheck\n// p-retry code vendored to avoid import issues\n// Source: https://github.com/sindresorhus/p-retry\n\nfunction validateRetries(retries) {\n    if (typeof retries === \"number\") {\n        if (retries < 0) {\n            throw new TypeError(\"Expected `retries` to be a non-negative number.\");\n        }\n        if (Number.isNaN(retries)) {\n            throw new TypeError(\"Expected `retries` to be a valid number or Infinity, got NaN.\");\n        }\n    }\n    else if (retries !== undefined) {\n        throw new TypeError(\"Expected `retries` to be a number or Infinity.\");\n    }\n}\nfunction validateNumberOption(name, value, { min = 0, allowInfinity = false } = {}) {\n    if (value === undefined) {\n        return;\n    }\n    if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new TypeError(`Expected \\`${name}\\` to be a number${allowInfinity ? \" or Infinity\" : \"\"}.`);\n    }\n    if (!allowInfinity && !Number.isFinite(value)) {\n        throw new TypeError(`Expected \\`${name}\\` to be a finite number.`);\n    }\n    if (value < min) {\n        throw new TypeError(`Expected \\`${name}\\` to be \\u2265 ${min}.`);\n    }\n}\nclass AbortError extends Error {\n    constructor(message) {\n        super();\n        if (message instanceof Error) {\n            this.originalError = message;\n            ({ message } = message);\n        }\n        else {\n            this.originalError = new Error(message);\n            this.originalError.stack = this.stack;\n        }\n        this.name = \"AbortError\";\n        this.message = message;\n    }\n}\nfunction calculateDelay(retriesConsumed, options) {\n    const attempt = Math.max(1, retriesConsumed + 1);\n    const random = options.randomize ? Math.random() + 1 : 1;\n    let timeout = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));\n    timeout = Math.min(timeout, options.maxTimeout);\n    return timeout;\n}\nfunction calculateRemainingTime(start, max) {\n    if (!Number.isFinite(max)) {\n        return max;\n    }\n    return max - (performance.now() - start);\n}\nasync function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime, options, }) {\n    const normalizedError = error instanceof Error\n        ? error\n        : new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n    if (normalizedError instanceof AbortError) {\n        throw normalizedError.originalError;\n    }\n    const retriesLeft = Number.isFinite(options.retries)\n        ? Math.max(0, options.retries - retriesConsumed)\n        : options.retries;\n    const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;\n    const context = Object.freeze({\n        error: normalizedError,\n        attemptNumber,\n        retriesLeft,\n        retriesConsumed,\n    });\n    await options.onFailedAttempt(context);\n    if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {\n        throw normalizedError;\n    }\n    const consumeRetry = await options.shouldConsumeRetry(context);\n    const remainingTime = calculateRemainingTime(startTime, maxRetryTime);\n    if (remainingTime <= 0 || retriesLeft <= 0) {\n        throw normalizedError;\n    }\n    if (normalizedError instanceof TypeError &&\n        !(0,_is_network_error_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(normalizedError)) {\n        if (consumeRetry) {\n            throw normalizedError;\n        }\n        options.signal?.throwIfAborted();\n        return false;\n    }\n    if (!(await options.shouldRetry(context))) {\n        throw normalizedError;\n    }\n    if (!consumeRetry) {\n        options.signal?.throwIfAborted();\n        return false;\n    }\n    const delayTime = calculateDelay(retriesConsumed, options);\n    const finalDelay = Math.min(delayTime, remainingTime);\n    if (finalDelay > 0) {\n        await new Promise((resolve, reject) => {\n            const onAbort = () => {\n                clearTimeout(timeoutToken);\n                options.signal?.removeEventListener(\"abort\", onAbort);\n                reject(options.signal.reason);\n            };\n            const timeoutToken = setTimeout(() => {\n                options.signal?.removeEventListener(\"abort\", onAbort);\n                resolve();\n            }, finalDelay);\n            if (options.unref) {\n                timeoutToken.unref?.();\n            }\n            options.signal?.addEventListener(\"abort\", onAbort, { once: true });\n        });\n    }\n    options.signal?.throwIfAborted();\n    return true;\n}\nasync function pRetry(input, options = {}) {\n    options = { ...options };\n    validateRetries(options.retries);\n    if (Object.hasOwn(options, \"forever\")) {\n        throw new Error(\"The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.\");\n    }\n    options.retries ??= 10;\n    options.factor ??= 2;\n    options.minTimeout ??= 1000;\n    options.maxTimeout ??= Number.POSITIVE_INFINITY;\n    options.maxRetryTime ??= Number.POSITIVE_INFINITY;\n    options.randomize ??= false;\n    options.onFailedAttempt ??= () => { };\n    options.shouldRetry ??= () => true;\n    options.shouldConsumeRetry ??= () => true;\n    // Validate numeric options and normalize edge cases\n    validateNumberOption(\"factor\", options.factor, {\n        min: 0,\n        allowInfinity: false,\n    });\n    validateNumberOption(\"minTimeout\", options.minTimeout, {\n        min: 0,\n        allowInfinity: false,\n    });\n    validateNumberOption(\"maxTimeout\", options.maxTimeout, {\n        min: 0,\n        allowInfinity: true,\n    });\n    validateNumberOption(\"maxRetryTime\", options.maxRetryTime, {\n        min: 0,\n        allowInfinity: true,\n    });\n    // Treat non-positive factor as 1 to avoid zero backoff or negative behavior\n    if (!(options.factor > 0)) {\n        options.factor = 1;\n    }\n    options.signal?.throwIfAborted();\n    let attemptNumber = 0;\n    let retriesConsumed = 0;\n    const startTime = performance.now();\n    while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {\n        attemptNumber++;\n        try {\n            options.signal?.throwIfAborted();\n            const result = await input(attemptNumber);\n            options.signal?.throwIfAborted();\n            return result;\n        }\n        catch (error) {\n            if (await onAttemptFailure({\n                error,\n                attemptNumber,\n                retriesConsumed,\n                startTime,\n                options,\n            })) {\n                retriesConsumed++;\n            }\n        }\n    }\n    // Should not reach here, but in case it does, throw an error\n    throw new Error(\"Retry attempts exhausted without throwing an error.\");\n}\nfunction makeRetriable(function_, options) {\n    return function (...arguments_) {\n        return pRetry(() => function_.apply(this, arguments_), options);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcC1yZXRyeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQWlDLElBQUk7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSyxtQkFBbUIsb0NBQW9DO0FBQ3RHO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0EsMENBQTBDLEtBQUssa0JBQWtCLElBQUk7QUFDckU7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNERBQTREO0FBQzlGO0FBQ0E7QUFDQSxrREFBa0QsTUFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNFQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxZQUFZO0FBQzdFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNlLHlDQUF5QztBQUN4RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2F2ZXJ5L3Rlc3QyL2FnZW50LWNoYXQtdWkvbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL3AtcmV0cnkvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG4vLyBwLXJldHJ5IGNvZGUgdmVuZG9yZWQgdG8gYXZvaWQgaW1wb3J0IGlzc3Vlc1xuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtcmV0cnlcbmltcG9ydCBpc05ldHdvcmtFcnJvciBmcm9tIFwiLi4vaXMtbmV0d29yay1lcnJvci9pbmRleC5qc1wiO1xuZnVuY3Rpb24gdmFsaWRhdGVSZXRyaWVzKHJldHJpZXMpIHtcbiAgICBpZiAodHlwZW9mIHJldHJpZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKHJldHJpZXMgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYHJldHJpZXNgIHRvIGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc05hTihyZXRyaWVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGByZXRyaWVzYCB0byBiZSBhIHZhbGlkIG51bWJlciBvciBJbmZpbml0eSwgZ290IE5hTi5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmV0cmllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBgcmV0cmllc2AgdG8gYmUgYSBudW1iZXIgb3IgSW5maW5pdHkuXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyT3B0aW9uKG5hbWUsIHZhbHVlLCB7IG1pbiA9IDAsIGFsbG93SW5maW5pdHkgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgfHwgTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGAke25hbWV9XFxgIHRvIGJlIGEgbnVtYmVyJHthbGxvd0luZmluaXR5ID8gXCIgb3IgSW5maW5pdHlcIiA6IFwiXCJ9LmApO1xuICAgIH1cbiAgICBpZiAoIWFsbG93SW5maW5pdHkgJiYgIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgJHtuYW1lfVxcYCB0byBiZSBhIGZpbml0ZSBudW1iZXIuYCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGAke25hbWV9XFxgIHRvIGJlIFxcdTIyNjUgJHttaW59LmApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gbWVzc2FnZTtcbiAgICAgICAgICAgICh7IG1lc3NhZ2UgfSA9IG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSBcIkFib3J0RXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWxheShyZXRyaWVzQ29uc3VtZWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhdHRlbXB0ID0gTWF0aC5tYXgoMSwgcmV0cmllc0NvbnN1bWVkICsgMSk7XG4gICAgY29uc3QgcmFuZG9tID0gb3B0aW9ucy5yYW5kb21pemUgPyBNYXRoLnJhbmRvbSgpICsgMSA6IDE7XG4gICAgbGV0IHRpbWVvdXQgPSBNYXRoLnJvdW5kKHJhbmRvbSAqIG9wdGlvbnMubWluVGltZW91dCAqIG9wdGlvbnMuZmFjdG9yICoqIChhdHRlbXB0IC0gMSkpO1xuICAgIHRpbWVvdXQgPSBNYXRoLm1pbih0aW1lb3V0LCBvcHRpb25zLm1heFRpbWVvdXQpO1xuICAgIHJldHVybiB0aW1lb3V0O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVtYWluaW5nVGltZShzdGFydCwgbWF4KSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobWF4KSkge1xuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gbWF4IC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gb25BdHRlbXB0RmFpbHVyZSh7IGVycm9yLCBhdHRlbXB0TnVtYmVyLCByZXRyaWVzQ29uc3VtZWQsIHN0YXJ0VGltZSwgb3B0aW9ucywgfSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRFcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgPyBlcnJvclxuICAgICAgICA6IG5ldyBUeXBlRXJyb3IoYE5vbi1lcnJvciB3YXMgdGhyb3duOiBcIiR7ZXJyb3J9XCIuIFlvdSBzaG91bGQgb25seSB0aHJvdyBlcnJvcnMuYCk7XG4gICAgaWYgKG5vcm1hbGl6ZWRFcnJvciBpbnN0YW5jZW9mIEFib3J0RXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbm9ybWFsaXplZEVycm9yLm9yaWdpbmFsRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHJldHJpZXNMZWZ0ID0gTnVtYmVyLmlzRmluaXRlKG9wdGlvbnMucmV0cmllcylcbiAgICAgICAgPyBNYXRoLm1heCgwLCBvcHRpb25zLnJldHJpZXMgLSByZXRyaWVzQ29uc3VtZWQpXG4gICAgICAgIDogb3B0aW9ucy5yZXRyaWVzO1xuICAgIGNvbnN0IG1heFJldHJ5VGltZSA9IG9wdGlvbnMubWF4UmV0cnlUaW1lID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBjb250ZXh0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGVycm9yOiBub3JtYWxpemVkRXJyb3IsXG4gICAgICAgIGF0dGVtcHROdW1iZXIsXG4gICAgICAgIHJldHJpZXNMZWZ0LFxuICAgICAgICByZXRyaWVzQ29uc3VtZWQsXG4gICAgfSk7XG4gICAgYXdhaXQgb3B0aW9ucy5vbkZhaWxlZEF0dGVtcHQoY29udGV4dCk7XG4gICAgaWYgKGNhbGN1bGF0ZVJlbWFpbmluZ1RpbWUoc3RhcnRUaW1lLCBtYXhSZXRyeVRpbWUpIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbm9ybWFsaXplZEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBjb25zdW1lUmV0cnkgPSBhd2FpdCBvcHRpb25zLnNob3VsZENvbnN1bWVSZXRyeShjb250ZXh0KTtcbiAgICBjb25zdCByZW1haW5pbmdUaW1lID0gY2FsY3VsYXRlUmVtYWluaW5nVGltZShzdGFydFRpbWUsIG1heFJldHJ5VGltZSk7XG4gICAgaWYgKHJlbWFpbmluZ1RpbWUgPD0gMCB8fCByZXRyaWVzTGVmdCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5vcm1hbGl6ZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWRFcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJlxuICAgICAgICAhaXNOZXR3b3JrRXJyb3Iobm9ybWFsaXplZEVycm9yKSkge1xuICAgICAgICBpZiAoY29uc3VtZVJldHJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBub3JtYWxpemVkRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCEoYXdhaXQgb3B0aW9ucy5zaG91bGRSZXRyeShjb250ZXh0KSkpIHtcbiAgICAgICAgdGhyb3cgbm9ybWFsaXplZEVycm9yO1xuICAgIH1cbiAgICBpZiAoIWNvbnN1bWVSZXRyeSkge1xuICAgICAgICBvcHRpb25zLnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkZWxheVRpbWUgPSBjYWxjdWxhdGVEZWxheShyZXRyaWVzQ29uc3VtZWQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGZpbmFsRGVsYXkgPSBNYXRoLm1pbihkZWxheVRpbWUsIHJlbWFpbmluZ1RpbWUpO1xuICAgIGlmIChmaW5hbERlbGF5ID4gMCkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbkFib3J0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VG9rZW4pO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG9wdGlvbnMuc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdGltZW91dFRva2VuID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBmaW5hbERlbGF5KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVucmVmKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dFRva2VuLnVucmVmPy4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb3B0aW9ucy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwUmV0cnkoaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICB2YWxpZGF0ZVJldHJpZXMob3B0aW9ucy5yZXRyaWVzKTtcbiAgICBpZiAoT2JqZWN0Lmhhc093bihvcHRpb25zLCBcImZvcmV2ZXJcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBmb3JldmVyYCBvcHRpb24gaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gRm9yIG1hbnkgdXNlLWNhc2VzLCB5b3UgY2FuIHNldCBgcmV0cmllczogSW5maW5pdHlgIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBvcHRpb25zLnJldHJpZXMgPz89IDEwO1xuICAgIG9wdGlvbnMuZmFjdG9yID8/PSAyO1xuICAgIG9wdGlvbnMubWluVGltZW91dCA/Pz0gMTAwMDtcbiAgICBvcHRpb25zLm1heFRpbWVvdXQgPz89IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBvcHRpb25zLm1heFJldHJ5VGltZSA/Pz0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIG9wdGlvbnMucmFuZG9taXplID8/PSBmYWxzZTtcbiAgICBvcHRpb25zLm9uRmFpbGVkQXR0ZW1wdCA/Pz0gKCkgPT4geyB9O1xuICAgIG9wdGlvbnMuc2hvdWxkUmV0cnkgPz89ICgpID0+IHRydWU7XG4gICAgb3B0aW9ucy5zaG91bGRDb25zdW1lUmV0cnkgPz89ICgpID0+IHRydWU7XG4gICAgLy8gVmFsaWRhdGUgbnVtZXJpYyBvcHRpb25zIGFuZCBub3JtYWxpemUgZWRnZSBjYXNlc1xuICAgIHZhbGlkYXRlTnVtYmVyT3B0aW9uKFwiZmFjdG9yXCIsIG9wdGlvbnMuZmFjdG9yLCB7XG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgYWxsb3dJbmZpbml0eTogZmFsc2UsXG4gICAgfSk7XG4gICAgdmFsaWRhdGVOdW1iZXJPcHRpb24oXCJtaW5UaW1lb3V0XCIsIG9wdGlvbnMubWluVGltZW91dCwge1xuICAgICAgICBtaW46IDAsXG4gICAgICAgIGFsbG93SW5maW5pdHk6IGZhbHNlLFxuICAgIH0pO1xuICAgIHZhbGlkYXRlTnVtYmVyT3B0aW9uKFwibWF4VGltZW91dFwiLCBvcHRpb25zLm1heFRpbWVvdXQsIHtcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBhbGxvd0luZmluaXR5OiB0cnVlLFxuICAgIH0pO1xuICAgIHZhbGlkYXRlTnVtYmVyT3B0aW9uKFwibWF4UmV0cnlUaW1lXCIsIG9wdGlvbnMubWF4UmV0cnlUaW1lLCB7XG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgYWxsb3dJbmZpbml0eTogdHJ1ZSxcbiAgICB9KTtcbiAgICAvLyBUcmVhdCBub24tcG9zaXRpdmUgZmFjdG9yIGFzIDEgdG8gYXZvaWQgemVybyBiYWNrb2ZmIG9yIG5lZ2F0aXZlIGJlaGF2aW9yXG4gICAgaWYgKCEob3B0aW9ucy5mYWN0b3IgPiAwKSkge1xuICAgICAgICBvcHRpb25zLmZhY3RvciA9IDE7XG4gICAgfVxuICAgIG9wdGlvbnMuc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgIGxldCBhdHRlbXB0TnVtYmVyID0gMDtcbiAgICBsZXQgcmV0cmllc0NvbnN1bWVkID0gMDtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB3aGlsZSAoTnVtYmVyLmlzRmluaXRlKG9wdGlvbnMucmV0cmllcykgPyByZXRyaWVzQ29uc3VtZWQgPD0gb3B0aW9ucy5yZXRyaWVzIDogdHJ1ZSkge1xuICAgICAgICBhdHRlbXB0TnVtYmVyKys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlucHV0KGF0dGVtcHROdW1iZXIpO1xuICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGF3YWl0IG9uQXR0ZW1wdEZhaWx1cmUoe1xuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGF0dGVtcHROdW1iZXIsXG4gICAgICAgICAgICAgICAgcmV0cmllc0NvbnN1bWVkLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXRyaWVzQ29uc3VtZWQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTaG91bGQgbm90IHJlYWNoIGhlcmUsIGJ1dCBpbiBjYXNlIGl0IGRvZXMsIHRocm93IGFuIGVycm9yXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmV0cnkgYXR0ZW1wdHMgZXhoYXVzdGVkIHdpdGhvdXQgdGhyb3dpbmcgYW4gZXJyb3IuXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSZXRyaWFibGUoZnVuY3Rpb25fLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG4gICAgICAgIHJldHVybiBwUmV0cnkoKCkgPT4gZnVuY3Rpb25fLmFwcGx5KHRoaXMsIGFyZ3VtZW50c18pLCBvcHRpb25zKTtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/p-retry/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/project.js":
/*!******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/project.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultProjectName: () => (/* binding */ getDefaultProjectName)\n/* harmony export */ });\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env.js */ \"(ssr)/./node_modules/langsmith/dist/utils/env.js\");\n\nconst getDefaultProjectName = () => {\n    return ((0,_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"PROJECT\") ??\n        (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n        \"default\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvamVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRjtBQUM3RTtBQUNQLFlBQVksd0VBQStCO0FBQzNDLFFBQVEsK0RBQXNCO0FBQzlCO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9wcm9qZWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUsIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUsIH0gZnJvbSBcIi4vZW52LmpzXCI7XG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdFByb2plY3ROYW1lID0gKCkgPT4ge1xuICAgIHJldHVybiAoZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlBST0pFQ1RcIikgPz9cbiAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9TRVNTSU9OXCIpID8/IC8vIFRPRE86IERlcHJlY2F0ZVxuICAgICAgICBcImRlZmF1bHRcIik7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/project.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/prompts.js":
/*!******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/prompts.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionGreaterOrEqual: () => (/* binding */ isVersionGreaterOrEqual),\n/* harmony export */   parsePromptIdentifier: () => (/* binding */ parsePromptIdentifier)\n/* harmony export */ });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"(ssr)/./node_modules/semver/index.js\");\n\nfunction isVersionGreaterOrEqual(current_version, target_version) {\n    const current = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(current_version);\n    const target = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(target_version);\n    if (!current || !target) {\n        throw new Error(\"Invalid version format.\");\n    }\n    return current.compare(target) >= 0;\n}\nfunction parsePromptIdentifier(identifier) {\n    if (!identifier ||\n        identifier.split(\"/\").length > 2 ||\n        identifier.startsWith(\"/\") ||\n        identifier.endsWith(\"/\") ||\n        identifier.split(\":\").length > 2) {\n        throw new Error(`Invalid identifier format: ${identifier}`);\n    }\n    const [ownerNamePart, commitPart] = identifier.split(\":\");\n    const commit = commitPart || \"latest\";\n    if (ownerNamePart.includes(\"/\")) {\n        const [owner, name] = ownerNamePart.split(\"/\", 2);\n        if (!owner || !name) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [owner, name, commit];\n    }\n    else {\n        if (!ownerNamePart) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\"-\", ownerNamePart, commit];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDeEM7QUFDUCxvQkFBb0IsNkNBQVk7QUFDaEMsbUJBQW1CLDZDQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9wcm9tcHRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlIGFzIHBhcnNlVmVyc2lvbiB9IGZyb20gXCJzZW12ZXJcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc1ZlcnNpb25HcmVhdGVyT3JFcXVhbChjdXJyZW50X3ZlcnNpb24sIHRhcmdldF92ZXJzaW9uKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHBhcnNlVmVyc2lvbihjdXJyZW50X3ZlcnNpb24pO1xuICAgIGNvbnN0IHRhcmdldCA9IHBhcnNlVmVyc2lvbih0YXJnZXRfdmVyc2lvbik7XG4gICAgaWYgKCFjdXJyZW50IHx8ICF0YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2ZXJzaW9uIGZvcm1hdC5cIik7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LmNvbXBhcmUodGFyZ2V0KSA+PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHJvbXB0SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgaWYgKCFpZGVudGlmaWVyIHx8XG4gICAgICAgIGlkZW50aWZpZXIuc3BsaXQoXCIvXCIpLmxlbmd0aCA+IDIgfHxcbiAgICAgICAgaWRlbnRpZmllci5zdGFydHNXaXRoKFwiL1wiKSB8fFxuICAgICAgICBpZGVudGlmaWVyLmVuZHNXaXRoKFwiL1wiKSB8fFxuICAgICAgICBpZGVudGlmaWVyLnNwbGl0KFwiOlwiKS5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpZGVudGlmaWVyIGZvcm1hdDogJHtpZGVudGlmaWVyfWApO1xuICAgIH1cbiAgICBjb25zdCBbb3duZXJOYW1lUGFydCwgY29tbWl0UGFydF0gPSBpZGVudGlmaWVyLnNwbGl0KFwiOlwiKTtcbiAgICBjb25zdCBjb21taXQgPSBjb21taXRQYXJ0IHx8IFwibGF0ZXN0XCI7XG4gICAgaWYgKG93bmVyTmFtZVBhcnQuaW5jbHVkZXMoXCIvXCIpKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgbmFtZV0gPSBvd25lck5hbWVQYXJ0LnNwbGl0KFwiL1wiLCAyKTtcbiAgICAgICAgaWYgKCFvd25lciB8fCAhbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlkZW50aWZpZXIgZm9ybWF0OiAke2lkZW50aWZpZXJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtvd25lciwgbmFtZSwgY29tbWl0XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghb3duZXJOYW1lUGFydCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlkZW50aWZpZXIgZm9ybWF0OiAke2lkZW50aWZpZXJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcIi1cIiwgb3duZXJOYW1lUGFydCwgY29tbWl0XTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/prompts.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/prompts_cache.js":
/*!************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/prompts_cache.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cache: () => (/* binding */ Cache)\n/* harmony export */ });\n/* harmony import */ var _prompts_cache_fs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prompts_cache_fs.js */ \"(ssr)/./node_modules/langsmith/dist/utils/prompts_cache_fs.js\");\n/**\n * Prompt caching module for LangSmith SDK.\n *\n * Provides an LRU cache with background refresh for prompt caching.\n * Uses stale-while-revalidate pattern for optimal performance.\n *\n * Works in all environments. File operations (dump/load) use helpers\n * that are swapped for browser builds via package.json browser field.\n */\n\n/**\n * Check if a cache entry is stale based on TTL.\n */\nfunction isStale(entry, ttlSeconds) {\n    if (ttlSeconds === null) {\n        return false; // Infinite TTL, never stale\n    }\n    const ageMs = Date.now() - entry.createdAt;\n    return ageMs > ttlSeconds * 1000;\n}\n/**\n * LRU cache with background refresh for prompts.\n *\n * Features:\n * - In-memory LRU cache with configurable max size\n * - Background refresh using setInterval\n * - Stale-while-revalidate: returns stale data while refresh happens\n * - JSON dump/load for offline use\n *\n * @example\n * ```typescript\n * const cache = new Cache({\n *   maxSize: 100,\n *   ttlSeconds: 3600,\n *   fetchFunc: async (key) => client.pullPromptCommit(key),\n * });\n *\n * // Use the cache\n * cache.set(\"my-prompt:latest\", promptCommit);\n * const cached = cache.get(\"my-prompt:latest\");\n *\n * // Cleanup\n * cache.stop();\n * ```\n */\nclass Cache {\n    constructor(config = {}) {\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ttlSeconds\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"refreshIntervalSeconds\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchFunc\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"refreshTimer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_metrics\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                hits: 0,\n                misses: 0,\n                refreshes: 0,\n                refreshErrors: 0,\n            }\n        });\n        this.maxSize = config.maxSize ?? 100;\n        this.ttlSeconds = config.ttlSeconds ?? 3600;\n        this.refreshIntervalSeconds = config.refreshIntervalSeconds ?? 60;\n        this.fetchFunc = config.fetchFunc;\n        // Start background refresh if fetch function provided and TTL is set\n        if (this.fetchFunc && this.ttlSeconds !== null) {\n            this.startRefreshLoop();\n        }\n    }\n    /**\n     * Get cache performance metrics.\n     */\n    get metrics() {\n        return { ...this._metrics };\n    }\n    /**\n     * Get total cache requests (hits + misses).\n     */\n    get totalRequests() {\n        return this._metrics.hits + this._metrics.misses;\n    }\n    /**\n     * Get cache hit rate (0.0 to 1.0).\n     */\n    get hitRate() {\n        const total = this.totalRequests;\n        return total > 0 ? this._metrics.hits / total : 0;\n    }\n    /**\n     * Reset all metrics to zero.\n     */\n    resetMetrics() {\n        this._metrics = {\n            hits: 0,\n            misses: 0,\n            refreshes: 0,\n            refreshErrors: 0,\n        };\n    }\n    /**\n     * Get a value from cache.\n     *\n     * Returns the cached value or undefined if not found.\n     * Stale entries are still returned (background refresh handles updates).\n     */\n    get(key) {\n        const entry = this.cache.get(key);\n        if (!entry) {\n            this._metrics.misses += 1;\n            return undefined;\n        }\n        // Move to end for LRU (delete and re-add)\n        this.cache.delete(key);\n        this.cache.set(key, entry);\n        this._metrics.hits += 1;\n        return entry.value;\n    }\n    /**\n     * Set a value in the cache.\n     */\n    set(key, value) {\n        // Check if we need to evict (and key is new)\n        if (!this.cache.has(key) && this.cache.size >= this.maxSize) {\n            // Evict oldest (first item in Map)\n            const oldestKey = this.cache.keys().next().value;\n            if (oldestKey !== undefined) {\n                this.cache.delete(oldestKey);\n            }\n        }\n        const entry = {\n            value,\n            createdAt: Date.now(),\n        };\n        // Delete first to ensure it's at the end\n        this.cache.delete(key);\n        this.cache.set(key, entry);\n    }\n    /**\n     * Remove a specific entry from cache.\n     */\n    invalidate(key) {\n        this.cache.delete(key);\n    }\n    /**\n     * Clear all cache entries.\n     */\n    clear() {\n        this.cache.clear();\n    }\n    /**\n     * Get the number of entries in the cache.\n     */\n    get size() {\n        return this.cache.size;\n    }\n    /**\n     * Stop background refresh.\n     * Should be called when the client is being cleaned up.\n     */\n    stop() {\n        if (this.refreshTimer) {\n            clearInterval(this.refreshTimer);\n            this.refreshTimer = undefined;\n        }\n    }\n    /**\n     * Dump cache contents to a JSON file for offline use.\n     */\n    dump(filePath) {\n        const entries = {};\n        for (const [key, entry] of this.cache.entries()) {\n            entries[key] = entry.value;\n        }\n        (0,_prompts_cache_fs_js__WEBPACK_IMPORTED_MODULE_0__.dumpCache)(filePath, entries);\n    }\n    /**\n     * Load cache contents from a JSON file.\n     *\n     * Loaded entries get a fresh TTL starting from load time.\n     *\n     * @returns Number of entries loaded.\n     */\n    load(filePath) {\n        const entries = (0,_prompts_cache_fs_js__WEBPACK_IMPORTED_MODULE_0__.loadCache)(filePath);\n        if (!entries) {\n            return 0;\n        }\n        let loaded = 0;\n        const now = Date.now();\n        for (const [key, value] of Object.entries(entries)) {\n            if (this.cache.size >= this.maxSize) {\n                break;\n            }\n            const entry = {\n                value: value,\n                createdAt: now, // Fresh TTL from load time\n            };\n            this.cache.set(key, entry);\n            loaded += 1;\n        }\n        return loaded;\n    }\n    /**\n     * Start the background refresh loop.\n     */\n    startRefreshLoop() {\n        this.refreshTimer = setInterval(() => {\n            this.refreshStaleEntries().catch((e) => {\n                // Log but don't die - keep the refresh loop running\n                console.warn(\"Unexpected error in cache refresh loop:\", e);\n            });\n        }, this.refreshIntervalSeconds * 1000);\n        // Don't block Node.js from exiting\n        if (this.refreshTimer.unref) {\n            this.refreshTimer.unref();\n        }\n    }\n    /**\n     * Get list of stale cache keys.\n     */\n    getStaleKeys() {\n        const staleKeys = [];\n        for (const [key, entry] of this.cache.entries()) {\n            if (isStale(entry, this.ttlSeconds)) {\n                staleKeys.push(key);\n            }\n        }\n        return staleKeys;\n    }\n    /**\n     * Check for stale entries and refresh them.\n     */\n    async refreshStaleEntries() {\n        if (!this.fetchFunc) {\n            return;\n        }\n        const staleKeys = this.getStaleKeys();\n        if (staleKeys.length === 0) {\n            return;\n        }\n        for (const key of staleKeys) {\n            try {\n                const newValue = await this.fetchFunc(key);\n                this.set(key, newValue);\n                this._metrics.refreshes += 1;\n            }\n            catch (e) {\n                // Keep stale data on refresh failure\n                this._metrics.refreshErrors += 1;\n                console.warn(`Failed to refresh cache entry ${key}:`, e);\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0c19jYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELElBQUk7QUFDbEU7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9wcm9tcHRzX2NhY2hlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHJvbXB0IGNhY2hpbmcgbW9kdWxlIGZvciBMYW5nU21pdGggU0RLLlxuICpcbiAqIFByb3ZpZGVzIGFuIExSVSBjYWNoZSB3aXRoIGJhY2tncm91bmQgcmVmcmVzaCBmb3IgcHJvbXB0IGNhY2hpbmcuXG4gKiBVc2VzIHN0YWxlLXdoaWxlLXJldmFsaWRhdGUgcGF0dGVybiBmb3Igb3B0aW1hbCBwZXJmb3JtYW5jZS5cbiAqXG4gKiBXb3JrcyBpbiBhbGwgZW52aXJvbm1lbnRzLiBGaWxlIG9wZXJhdGlvbnMgKGR1bXAvbG9hZCkgdXNlIGhlbHBlcnNcbiAqIHRoYXQgYXJlIHN3YXBwZWQgZm9yIGJyb3dzZXIgYnVpbGRzIHZpYSBwYWNrYWdlLmpzb24gYnJvd3NlciBmaWVsZC5cbiAqL1xuaW1wb3J0IHsgZHVtcENhY2hlLCBsb2FkQ2FjaGUgfSBmcm9tIFwiLi9wcm9tcHRzX2NhY2hlX2ZzLmpzXCI7XG4vKipcbiAqIENoZWNrIGlmIGEgY2FjaGUgZW50cnkgaXMgc3RhbGUgYmFzZWQgb24gVFRMLlxuICovXG5mdW5jdGlvbiBpc1N0YWxlKGVudHJ5LCB0dGxTZWNvbmRzKSB7XG4gICAgaWYgKHR0bFNlY29uZHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJbmZpbml0ZSBUVEwsIG5ldmVyIHN0YWxlXG4gICAgfVxuICAgIGNvbnN0IGFnZU1zID0gRGF0ZS5ub3coKSAtIGVudHJ5LmNyZWF0ZWRBdDtcbiAgICByZXR1cm4gYWdlTXMgPiB0dGxTZWNvbmRzICogMTAwMDtcbn1cbi8qKlxuICogTFJVIGNhY2hlIHdpdGggYmFja2dyb3VuZCByZWZyZXNoIGZvciBwcm9tcHRzLlxuICpcbiAqIEZlYXR1cmVzOlxuICogLSBJbi1tZW1vcnkgTFJVIGNhY2hlIHdpdGggY29uZmlndXJhYmxlIG1heCBzaXplXG4gKiAtIEJhY2tncm91bmQgcmVmcmVzaCB1c2luZyBzZXRJbnRlcnZhbFxuICogLSBTdGFsZS13aGlsZS1yZXZhbGlkYXRlOiByZXR1cm5zIHN0YWxlIGRhdGEgd2hpbGUgcmVmcmVzaCBoYXBwZW5zXG4gKiAtIEpTT04gZHVtcC9sb2FkIGZvciBvZmZsaW5lIHVzZVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBjYWNoZSA9IG5ldyBDYWNoZSh7XG4gKiAgIG1heFNpemU6IDEwMCxcbiAqICAgdHRsU2Vjb25kczogMzYwMCxcbiAqICAgZmV0Y2hGdW5jOiBhc3luYyAoa2V5KSA9PiBjbGllbnQucHVsbFByb21wdENvbW1pdChrZXkpLFxuICogfSk7XG4gKlxuICogLy8gVXNlIHRoZSBjYWNoZVxuICogY2FjaGUuc2V0KFwibXktcHJvbXB0OmxhdGVzdFwiLCBwcm9tcHRDb21taXQpO1xuICogY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KFwibXktcHJvbXB0OmxhdGVzdFwiKTtcbiAqXG4gKiAvLyBDbGVhbnVwXG4gKiBjYWNoZS5zdG9wKCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIENhY2hlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWNoZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInR0bFNlY29uZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmcmVzaEludGVydmFsU2Vjb25kc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZXRjaEZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmcmVzaFRpbWVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tZXRyaWNzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgaGl0czogMCxcbiAgICAgICAgICAgICAgICBtaXNzZXM6IDAsXG4gICAgICAgICAgICAgICAgcmVmcmVzaGVzOiAwLFxuICAgICAgICAgICAgICAgIHJlZnJlc2hFcnJvcnM6IDAsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heFNpemUgPSBjb25maWcubWF4U2l6ZSA/PyAxMDA7XG4gICAgICAgIHRoaXMudHRsU2Vjb25kcyA9IGNvbmZpZy50dGxTZWNvbmRzID8/IDM2MDA7XG4gICAgICAgIHRoaXMucmVmcmVzaEludGVydmFsU2Vjb25kcyA9IGNvbmZpZy5yZWZyZXNoSW50ZXJ2YWxTZWNvbmRzID8/IDYwO1xuICAgICAgICB0aGlzLmZldGNoRnVuYyA9IGNvbmZpZy5mZXRjaEZ1bmM7XG4gICAgICAgIC8vIFN0YXJ0IGJhY2tncm91bmQgcmVmcmVzaCBpZiBmZXRjaCBmdW5jdGlvbiBwcm92aWRlZCBhbmQgVFRMIGlzIHNldFxuICAgICAgICBpZiAodGhpcy5mZXRjaEZ1bmMgJiYgdGhpcy50dGxTZWNvbmRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVmcmVzaExvb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUgcGVyZm9ybWFuY2UgbWV0cmljcy5cbiAgICAgKi9cbiAgICBnZXQgbWV0cmljcygpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4udGhpcy5fbWV0cmljcyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdG90YWwgY2FjaGUgcmVxdWVzdHMgKGhpdHMgKyBtaXNzZXMpLlxuICAgICAqL1xuICAgIGdldCB0b3RhbFJlcXVlc3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0cmljcy5oaXRzICsgdGhpcy5fbWV0cmljcy5taXNzZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZSBoaXQgcmF0ZSAoMC4wIHRvIDEuMCkuXG4gICAgICovXG4gICAgZ2V0IGhpdFJhdGUoKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gdGhpcy50b3RhbFJlcXVlc3RzO1xuICAgICAgICByZXR1cm4gdG90YWwgPiAwID8gdGhpcy5fbWV0cmljcy5oaXRzIC8gdG90YWwgOiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCBhbGwgbWV0cmljcyB0byB6ZXJvLlxuICAgICAqL1xuICAgIHJlc2V0TWV0cmljcygpIHtcbiAgICAgICAgdGhpcy5fbWV0cmljcyA9IHtcbiAgICAgICAgICAgIGhpdHM6IDAsXG4gICAgICAgICAgICBtaXNzZXM6IDAsXG4gICAgICAgICAgICByZWZyZXNoZXM6IDAsXG4gICAgICAgICAgICByZWZyZXNoRXJyb3JzOiAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSB2YWx1ZSBmcm9tIGNhY2hlLlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGVkIHZhbHVlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gICAgICogU3RhbGUgZW50cmllcyBhcmUgc3RpbGwgcmV0dXJuZWQgKGJhY2tncm91bmQgcmVmcmVzaCBoYW5kbGVzIHVwZGF0ZXMpLlxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9tZXRyaWNzLm1pc3NlcyArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNb3ZlIHRvIGVuZCBmb3IgTFJVIChkZWxldGUgYW5kIHJlLWFkZClcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBlbnRyeSk7XG4gICAgICAgIHRoaXMuX21ldHJpY3MuaGl0cyArPSAxO1xuICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIHZhbHVlIGluIHRoZSBjYWNoZS5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGV2aWN0IChhbmQga2V5IGlzIG5ldylcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpICYmIHRoaXMuY2FjaGUuc2l6ZSA+PSB0aGlzLm1heFNpemUpIHtcbiAgICAgICAgICAgIC8vIEV2aWN0IG9sZGVzdCAoZmlyc3QgaXRlbSBpbiBNYXApXG4gICAgICAgICAgICBjb25zdCBvbGRlc3RLZXkgPSB0aGlzLmNhY2hlLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICBpZiAob2xkZXN0S2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShvbGRlc3RLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIH07XG4gICAgICAgIC8vIERlbGV0ZSBmaXJzdCB0byBlbnN1cmUgaXQncyBhdCB0aGUgZW5kXG4gICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgZW50cnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzcGVjaWZpYyBlbnRyeSBmcm9tIGNhY2hlLlxuICAgICAqL1xuICAgIGludmFsaWRhdGUoa2V5KSB7XG4gICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBjYWNoZSBlbnRyaWVzLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNhY2hlLlxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIGJhY2tncm91bmQgcmVmcmVzaC5cbiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGNsaWVudCBpcyBiZWluZyBjbGVhbmVkIHVwLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlZnJlc2hUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEdW1wIGNhY2hlIGNvbnRlbnRzIHRvIGEgSlNPTiBmaWxlIGZvciBvZmZsaW5lIHVzZS5cbiAgICAgKi9cbiAgICBkdW1wKGZpbGVQYXRoKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgdGhpcy5jYWNoZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGVudHJpZXNba2V5XSA9IGVudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGR1bXBDYWNoZShmaWxlUGF0aCwgZW50cmllcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgY2FjaGUgY29udGVudHMgZnJvbSBhIEpTT04gZmlsZS5cbiAgICAgKlxuICAgICAqIExvYWRlZCBlbnRyaWVzIGdldCBhIGZyZXNoIFRUTCBzdGFydGluZyBmcm9tIGxvYWQgdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiBlbnRyaWVzIGxvYWRlZC5cbiAgICAgKi9cbiAgICBsb2FkKGZpbGVQYXRoKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBsb2FkQ2FjaGUoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoIWVudHJpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsb2FkZWQgPSAwO1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhlbnRyaWVzKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGUuc2l6ZSA+PSB0aGlzLm1heFNpemUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5vdywgLy8gRnJlc2ggVFRMIGZyb20gbG9hZCB0aW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBlbnRyeSk7XG4gICAgICAgICAgICBsb2FkZWQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9hZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgYmFja2dyb3VuZCByZWZyZXNoIGxvb3AuXG4gICAgICovXG4gICAgc3RhcnRSZWZyZXNoTG9vcCgpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hTdGFsZUVudHJpZXMoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIExvZyBidXQgZG9uJ3QgZGllIC0ga2VlcCB0aGUgcmVmcmVzaCBsb29wIHJ1bm5pbmdcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkIGVycm9yIGluIGNhY2hlIHJlZnJlc2ggbG9vcDpcIiwgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcy5yZWZyZXNoSW50ZXJ2YWxTZWNvbmRzICogMTAwMCk7XG4gICAgICAgIC8vIERvbid0IGJsb2NrIE5vZGUuanMgZnJvbSBleGl0aW5nXG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hUaW1lci51bnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVGltZXIudW5yZWYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbGlzdCBvZiBzdGFsZSBjYWNoZSBrZXlzLlxuICAgICAqL1xuICAgIGdldFN0YWxlS2V5cygpIHtcbiAgICAgICAgY29uc3Qgc3RhbGVLZXlzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIHRoaXMuY2FjaGUuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoaXNTdGFsZShlbnRyeSwgdGhpcy50dGxTZWNvbmRzKSkge1xuICAgICAgICAgICAgICAgIHN0YWxlS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWxlS2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIHN0YWxlIGVudHJpZXMgYW5kIHJlZnJlc2ggdGhlbS5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoU3RhbGVFbnRyaWVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuZmV0Y2hGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhbGVLZXlzID0gdGhpcy5nZXRTdGFsZUtleXMoKTtcbiAgICAgICAgaWYgKHN0YWxlS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzdGFsZUtleXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBhd2FpdCB0aGlzLmZldGNoRnVuYyhrZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21ldHJpY3MucmVmcmVzaGVzICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgc3RhbGUgZGF0YSBvbiByZWZyZXNoIGZhaWx1cmVcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXRyaWNzLnJlZnJlc2hFcnJvcnMgKz0gMTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byByZWZyZXNoIGNhY2hlIGVudHJ5ICR7a2V5fTpgLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/prompts_cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/prompts_cache_fs.js":
/*!***************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/prompts_cache_fs.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dumpCache: () => (/* binding */ dumpCache),\n/* harmony export */   loadCache: () => (/* binding */ loadCache)\n/* harmony export */ });\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/**\n * File system operations for prompt cache (Node.js version).\n *\n * This file is swapped with prompts_cache_fs.browser.ts for browser builds\n * via the package.json browser field.\n */\n\n\n/**\n * Dump cache entries to a JSON file.\n */\nfunction dumpCache(filePath, entries) {\n    const dir = node_path__WEBPACK_IMPORTED_MODULE_1__.dirname(filePath);\n    if (!node_fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(dir)) {\n        node_fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync(dir, { recursive: true });\n    }\n    const data = { entries };\n    // Atomic write: write to temp file then rename\n    const tempPath = `${filePath}.tmp`;\n    try {\n        node_fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync(tempPath, JSON.stringify(data, null, 2));\n        node_fs__WEBPACK_IMPORTED_MODULE_0__.renameSync(tempPath, filePath);\n    }\n    catch (e) {\n        // Clean up temp file on failure\n        if (node_fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(tempPath)) {\n            node_fs__WEBPACK_IMPORTED_MODULE_0__.unlinkSync(tempPath);\n        }\n        throw e;\n    }\n}\n/**\n * Load cache entries from a JSON file.\n *\n * @returns The entries object, or null if file doesn't exist or is invalid.\n */\nfunction loadCache(filePath) {\n    if (!node_fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(filePath)) {\n        return null;\n    }\n    try {\n        const content = node_fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync(filePath, \"utf-8\");\n        const data = JSON.parse(content);\n        return data.entries ?? null;\n    }\n    catch {\n        return null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0c19jYWNoZV9mcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhCO0FBQ0k7QUFDbEM7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0IsOENBQVk7QUFDNUIsU0FBUywrQ0FBYTtBQUN0QixRQUFRLDhDQUFZLFFBQVEsaUJBQWlCO0FBQzdDO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQSxRQUFRLGtEQUFnQjtBQUN4QixRQUFRLCtDQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQWE7QUFDekIsWUFBWSwrQ0FBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMsK0NBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXZlcnkvdGVzdDIvYWdlbnQtY2hhdC11aS9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0c19jYWNoZV9mcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZpbGUgc3lzdGVtIG9wZXJhdGlvbnMgZm9yIHByb21wdCBjYWNoZSAoTm9kZS5qcyB2ZXJzaW9uKS5cbiAqXG4gKiBUaGlzIGZpbGUgaXMgc3dhcHBlZCB3aXRoIHByb21wdHNfY2FjaGVfZnMuYnJvd3Nlci50cyBmb3IgYnJvd3NlciBidWlsZHNcbiAqIHZpYSB0aGUgcGFja2FnZS5qc29uIGJyb3dzZXIgZmllbGQuXG4gKi9cbmltcG9ydCAqIGFzIGZzIGZyb20gXCJub2RlOmZzXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJub2RlOnBhdGhcIjtcbi8qKlxuICogRHVtcCBjYWNoZSBlbnRyaWVzIHRvIGEgSlNPTiBmaWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZHVtcENhY2hlKGZpbGVQYXRoLCBlbnRyaWVzKSB7XG4gICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkge1xuICAgICAgICBmcy5ta2RpclN5bmMoZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHsgZW50cmllcyB9O1xuICAgIC8vIEF0b21pYyB3cml0ZTogd3JpdGUgdG8gdGVtcCBmaWxlIHRoZW4gcmVuYW1lXG4gICAgY29uc3QgdGVtcFBhdGggPSBgJHtmaWxlUGF0aH0udG1wYDtcbiAgICB0cnkge1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHRlbXBQYXRoLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XG4gICAgICAgIGZzLnJlbmFtZVN5bmModGVtcFBhdGgsIGZpbGVQYXRoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgdGVtcCBmaWxlIG9uIGZhaWx1cmVcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmModGVtcFBhdGgpKSB7XG4gICAgICAgICAgICBmcy51bmxpbmtTeW5jKHRlbXBQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbi8qKlxuICogTG9hZCBjYWNoZSBlbnRyaWVzIGZyb20gYSBKU09OIGZpbGUuXG4gKlxuICogQHJldHVybnMgVGhlIGVudHJpZXMgb2JqZWN0LCBvciBudWxsIGlmIGZpbGUgZG9lc24ndCBleGlzdCBvciBpcyBpbnZhbGlkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZENhY2hlKGZpbGVQYXRoKSB7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgXCJ1dGYtOFwiKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgICAgIHJldHVybiBkYXRhLmVudHJpZXMgPz8gbnVsbDtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/prompts_cache_fs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/utils/warn.js":
/*!***************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/warn.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   warnOnce: () => (/* binding */ warnOnce)\n/* harmony export */ });\nconst warnedMessages = {};\nfunction warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvd2Fybi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy93YXJuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHdhcm5lZE1lc3NhZ2VzID0ge307XG5leHBvcnQgZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICAgIGlmICghd2FybmVkTWVzc2FnZXNbbWVzc2FnZV0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB3YXJuZWRNZXNzYWdlc1ttZXNzYWdlXSA9IHRydWU7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/utils/warn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/dist/uuid.js":
/*!*********************************************!*\
  !*** ./node_modules/langsmith/dist/uuid.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uuid7: () => (/* binding */ uuid7),\n/* harmony export */   uuid7FromTime: () => (/* reexport safe */ _utils_uuid_js__WEBPACK_IMPORTED_MODULE_0__.uuid7FromTime)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v7.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(ssr)/./node_modules/langsmith/dist/utils/_uuid.js\");\n\n\n/**\n * Generate a random UUID v7 string.\n */\nfunction uuid7() {\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXVpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9DO0FBQ2E7QUFDakQ7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLGdEQUFNO0FBQ2pCIiwic291cmNlcyI6WyIvVXNlcnMvYXZlcnkvdGVzdDIvYWdlbnQtY2hhdC11aS9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXVpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2NyBhcyB1dWlkdjcgfSBmcm9tIFwidXVpZFwiO1xuZXhwb3J0IHsgdXVpZDdGcm9tVGltZSB9IGZyb20gXCIuL3V0aWxzL191dWlkLmpzXCI7XG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIFVVSUQgdjcgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXVpZDcoKSB7XG4gICAgcmV0dXJuIHV1aWR2NygpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/dist/uuid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/index.js":
/*!*****************************************!*\
  !*** ./node_modules/langsmith/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cache: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Cache),
/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),
/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),
/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__),
/* harmony export */   getDefaultProjectName: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getDefaultProjectName),
/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.overrideFetchImplementation),
/* harmony export */   uuid7: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.uuid7),
/* harmony export */   uuid7FromTime: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.uuid7FromTime)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "(ssr)/./node_modules/langsmith/dist/index.js");


/***/ }),

/***/ "(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js":
/*!**************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyxpRUFBZTtBQUNmLGNBQWMsK0RBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9uYXRpdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJhbmRvbVVVSUQ6IGNyeXB0by5yYW5kb21VVUlEXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/parse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/parse.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Parse ########-....-....-....-............\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff;\n\n  // Parse ........-####-....-....-............\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Parse ........-....-####-....-............\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Parse ........-....-....-####-............\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7QUFDckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9wYXJzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG4gIGxldCB2O1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmO1xuXG4gIC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjtcblxuICAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmO1xuXG4gIC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7XG5cbiAgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBkZWZhdWx0IHBhcnNlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js":
/*!*************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyw4RUFBOEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9yZWdleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLThdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMHxmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYpJC9pOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkM7QUFDZTtBQUNmO0FBQ0EsSUFBSSxpRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9ybmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5jb25zdCBybmRzOFBvb2wgPSBuZXcgVWludDhBcnJheSgyNTYpOyAvLyAjIG9mIHJhbmRvbSB2YWx1ZXMgdG8gcHJlLWFsbG9jYXRlXG5sZXQgcG9vbFB0ciA9IHJuZHM4UG9vbC5sZW5ndGg7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIGlmIChwb29sUHRyID4gcm5kczhQb29sLmxlbmd0aCAtIDE2KSB7XG4gICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKHJuZHM4UG9vbCk7XG4gICAgcG9vbFB0ciA9IDA7XG4gIH1cbiAgcmV0dXJuIHJuZHM4UG9vbC5zbGljZShwb29sUHRyLCBwb29sUHRyICs9IDE2KTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/sha1.js":
/*!************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/sha1.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTLDZEQUFpQjtBQUMxQjtBQUNBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zaGExLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcywgJ3V0ZjgnKTtcbiAgfVxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpO1xufVxuZXhwb3J0IGRlZmF1bHQgc2hhMTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyIvVXNlcnMvYXZlcnkvdGVzdDIvYWdlbnQtY2hhdC11aS9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5jb25zdCBieXRlVG9IZXggPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICAvL1xuICAvLyBOb3RlIHRvIGZ1dHVyZS1zZWxmOiBObywgeW91IGNhbid0IHJlbW92ZSB0aGUgYHRvTG93ZXJDYXNlKClgIGNhbGwuXG4gIC8vIFJFRjogaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNjc3I2lzc3VlY29tbWVudC0xNzU3MzUxMzUxXG4gIHJldHVybiAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHV1aWQgPSB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQpO1xuICAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG4gIHJldHVybiB1dWlkO1xufVxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v35.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/v35.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* binding */ v35)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/parse.js\");\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n\n    // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    if (buf) {\n      offset = offset || 0;\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n      return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  }\n\n  // Function#name is not settable on some platforms (#270)\n  try {\n    generateUUID.name = name;\n  } catch (err) {}\n\n  // For CommonJS default export support\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ2xCO0FBQy9CO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1E7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBZTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MzUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0IGNvbnN0IEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjM1KG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBfbmFtZXNwYWNlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIGlmICgoKF9uYW1lc3BhY2UgPSBuYW1lc3BhY2UpID09PSBudWxsIHx8IF9uYW1lc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9uYW1lc3BhY2UubGVuZ3RoKSAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiB1bnNhZmVTdHJpbmdpZnkoYnl0ZXMpO1xuICB9XG5cbiAgLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lO1xuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pEO0FBQ0EsTUFBTSxrREFBTTtBQUNaLFdBQVcsa0RBQU07QUFDakI7QUFDQTtBQUNBLGlEQUFpRCwrQ0FBRzs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbmF0aXZlIGZyb20gJy4vbmF0aXZlLmpzJztcbmltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiB1bnNhZmVTdHJpbmdpZnkocm5kcyk7XG59XG5leHBvcnQgZGVmYXVsdCB2NDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v5.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/v5.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsV0FBVyxtREFBRyxhQUFhLGdEQUFJO0FBQy9CLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBzaGExIGZyb20gJy4vc2hhMS5qcyc7XG5jb25zdCB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v7.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/v7.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nlet _seqLow = null;\nlet _seqHigh = null;\nlet _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  const msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  let seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  let seqHigh = _seqHigh;\n  let seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v7);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsK0NBQUc7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBZTtBQUMvQjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmVyeS90ZXN0Mi9hZ2VudC1jaGF0LXVpL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92Ny5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuLyoqXG4gKiBVVUlEIFY3IC0gVW5peCBFcG9jaCB0aW1lLWJhc2VkIFVVSURcbiAqXG4gKiBUaGUgSUVURiBoYXMgcHVibGlzaGVkIFJGQzk1NjIsIGludHJvZHVjaW5nIDMgbmV3IFVVSUQgdmVyc2lvbnMgKDYsNyw4KS4gVGhpc1xuICogaW1wbGVtZW50YXRpb24gb2YgVjcgaXMgYmFzZWQgb24gdGhlIGFjY2VwdGVkLCB0aG91Z2ggbm90IHlldCBhcHByb3ZlZCxcbiAqIHJldmlzaW9ucy5cbiAqXG4gKiBSRkMgOTU2MjpodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTU2Mi5odG1sIFVuaXZlcnNhbGx5IFVuaXF1ZVxuICogSURlbnRpZmllcnMgKFVVSURzKVxuXG4gKlxuICogU2FtcGxlIFY3IHZhbHVlOlxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk1NjIuaHRtbCNuYW1lLWV4YW1wbGUtb2YtYS11dWlkdjctdmFsdWVcbiAqXG4gKiBNb25vdG9uaWMgQml0IExheW91dDogUkZDIHJmYzk1NjIuNi4yIE1ldGhvZCAxLCBEZWRpY2F0ZWQgQ291bnRlciBCaXRzIHJlZjpcbiAqICAgICBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTU2Mi5odG1sI3NlY3Rpb24tNi4yLTUuMVxuICpcbiAqICAgMCAgICAgICAgICAgICAgICAgICAxICAgICAgICAgICAgICAgICAgIDIgICAgICAgICAgICAgICAgICAgMyAwIDEgMiAzIDQgNSA2XG4gKiAgIDcgOCA5IDAgMSAyIDMgNCA1IDYgNyA4IDkgMCAxIDIgMyA0IDUgNiA3IDggOSAwIDFcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXhfdHNfbXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLStcbiAqICB8ICAgICAgICAgIHVuaXhfdHNfbXMgICAgICAgICAgIHwgIHZlciAgfCAgICAgICAgc2VxX2hpICAgICAgICAgfFxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXG4gKiAgfHZhcnwgICAgICAgICAgICAgICBzZXFfbG93ICAgICAgICAgICAgICAgfCAgICAgICAgcmFuZCAgICAgICAgIHxcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLStcbiAqXG4gKiBzZXEgaXMgYSAzMSBiaXQgc2VyaWFsaXplZCBjb3VudGVyOyBjb21wcmlzZWQgb2YgMTIgYml0IHNlcV9oaSBhbmQgMTkgYml0XG4gKiBzZXFfbG93LCBhbmQgcmFuZG9tbHkgaW5pdGlhbGl6ZWQgdXBvbiB0aW1lc3RhbXAgY2hhbmdlLiAzMSBiaXQgY291bnRlciBzaXplXG4gKiB3YXMgc2VsZWN0ZWQgYXMgYW55IGJpdHdpc2Ugb3BlcmF0aW9ucyBpbiBub2RlIGFyZSBkb25lIGFzIF9zaWduZWRfIDMyIGJpdFxuICogaW50cy4gd2UgZXhjbHVkZSB0aGUgc2lnbiBiaXQuXG4gKi9cblxubGV0IF9zZXFMb3cgPSBudWxsO1xubGV0IF9zZXFIaWdoID0gbnVsbDtcbmxldCBfbXNlY3MgPSAwO1xuZnVuY3Rpb24gdjcob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gaW5pdGlhbGl6ZSBidWZmZXIgYW5kIHBvaW50ZXJcbiAgbGV0IGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGIgPSBidWYgfHwgbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gIC8vIHJuZHMgaXMgVWludDhBcnJheSgxNikgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzXG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIG1pbGxpc2Vjb25kcyBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwXG4gIGNvbnN0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7XG5cbiAgLy8gc2VxIGlzIHVzZXIgcHJvdmlkZWQgMzEgYml0IGNvdW50ZXJcbiAgbGV0IHNlcSA9IG9wdGlvbnMuc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNlcSA6IG51bGw7XG5cbiAgLy8gaW5pdGlhbGl6ZSBsb2NhbCBzZXEgaGlnaC9sb3cgcGFydHNcbiAgbGV0IHNlcUhpZ2ggPSBfc2VxSGlnaDtcbiAgbGV0IHNlcUxvdyA9IF9zZXFMb3c7XG5cbiAgLy8gY2hlY2sgaWYgY2xvY2sgaGFzIGFkdmFuY2VkIGFuZCB1c2VyIGhhcyBub3QgcHJvdmlkZWQgbXNlY3NcbiAgaWYgKG1zZWNzID4gX21zZWNzICYmIG9wdGlvbnMubXNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIF9tc2VjcyA9IG1zZWNzO1xuXG4gICAgLy8gdW5sZXNzIHVzZXIgcHJvdmlkZWQgc2VxLCByZXNldCBzZXEgcGFydHNcbiAgICBpZiAoc2VxICE9PSBudWxsKSB7XG4gICAgICBzZXFIaWdoID0gbnVsbDtcbiAgICAgIHNlcUxvdyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIHVzZXIgcHJvdmlkZWQgc2VxXG4gIGlmIChzZXEgIT09IG51bGwpIHtcbiAgICAvLyB0cmltIHByb3ZpZGVkIHNlcSB0byAzMSBiaXRzIG9mIHZhbHVlLCBhdm9pZGluZyBvdmVyZmxvd1xuICAgIGlmIChzZXEgPiAweDdmZmZmZmZmKSB7XG4gICAgICBzZXEgPSAweDdmZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIHNwbGl0IHByb3ZpZGVkIHNlcSBpbnRvIGhpZ2gvbG93IHBhcnRzXG4gICAgc2VxSGlnaCA9IHNlcSA+Pj4gMTkgJiAweGZmZjtcbiAgICBzZXFMb3cgPSBzZXEgJiAweDdmZmZmO1xuICB9XG5cbiAgLy8gcmFuZG9tbHkgaW5pdGlhbGl6ZSBzZXFcbiAgaWYgKHNlcUhpZ2ggPT09IG51bGwgfHwgc2VxTG93ID09PSBudWxsKSB7XG4gICAgc2VxSGlnaCA9IHJuZHNbNl0gJiAweDdmO1xuICAgIHNlcUhpZ2ggPSBzZXFIaWdoIDw8IDggfCBybmRzWzddO1xuICAgIHNlcUxvdyA9IHJuZHNbOF0gJiAweDNmOyAvLyBwYWQgZm9yIHZhclxuICAgIHNlcUxvdyA9IHNlcUxvdyA8PCA4IHwgcm5kc1s5XTtcbiAgICBzZXFMb3cgPSBzZXFMb3cgPDwgNSB8IHJuZHNbMTBdID4+PiAzO1xuICB9XG5cbiAgLy8gaW5jcmVtZW50IHNlcSBpZiB3aXRoaW4gbXNlY3Mgd2luZG93XG4gIGlmIChtc2VjcyArIDEwMDAwID4gX21zZWNzICYmIHNlcSA9PT0gbnVsbCkge1xuICAgIGlmICgrK3NlcUxvdyA+IDB4N2ZmZmYpIHtcbiAgICAgIHNlcUxvdyA9IDA7XG4gICAgICBpZiAoKytzZXFIaWdoID4gMHhmZmYpIHtcbiAgICAgICAgc2VxSGlnaCA9IDA7XG5cbiAgICAgICAgLy8gaW5jcmVtZW50IGludGVybmFsIF9tc2Vjcy4gdGhpcyBhbGxvd3MgdXMgdG8gY29udGludWUgaW5jcmVtZW50aW5nXG4gICAgICAgIC8vIHdoaWxlIHN0YXlpbmcgbW9ub3RvbmljLiBOb3RlLCBvbmNlIHdlIGhpdCAxMGsgbWlsbGlzZWNvbmRzIGJleW9uZCBzeXN0ZW1cbiAgICAgICAgLy8gY2xvY2ssIHdlIHdpbGwgcmVzZXQgYnJlYWtpbmcgbW9ub3RvbmljaXR5IChhZnRlciAoMl4zMSkqMTAwMDAgZ2VuZXJhdGlvbnMpXG4gICAgICAgIF9tc2VjcysrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyByZXNldHRpbmc7IHdlIGhhdmUgYWR2YW5jZWQgbW9yZSB0aGFuXG4gICAgLy8gMTBrIG1pbGxpc2Vjb25kcyBiZXlvbmQgc3lzdGVtIGNsb2NrXG4gICAgX21zZWNzID0gbXNlY3M7XG4gIH1cbiAgX3NlcUhpZ2ggPSBzZXFIaWdoO1xuICBfc2VxTG93ID0gc2VxTG93O1xuXG4gIC8vIFtieXRlcyAwLTVdIDQ4IGJpdHMgb2YgbG9jYWwgdGltZXN0YW1wXG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBiW2krK10gPSBfbXNlY3MgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAgJiAweGZmO1xuICBiW2krK10gPSBfbXNlY3MgLyAweDEwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAmIDB4ZmY7XG5cbiAgLy8gW2J5dGUgNl0gLSBzZXQgNCBiaXRzIG9mIHZlcnNpb24gKDcpIHdpdGggZmlyc3QgNCBiaXRzIHNlcV9oaVxuICBiW2krK10gPSBzZXFIaWdoID4+PiA0ICYgMHgwZiB8IDB4NzA7XG5cbiAgLy8gW2J5dGUgN10gcmVtYWluaW5nIDggYml0cyBvZiBzZXFfaGlcbiAgYltpKytdID0gc2VxSGlnaCAmIDB4ZmY7XG5cbiAgLy8gW2J5dGUgOF0gLSB2YXJpYW50ICgyIGJpdHMpLCBmaXJzdCA2IGJpdHMgc2VxX2xvd1xuICBiW2krK10gPSBzZXFMb3cgPj4+IDEzICYgMHgzZiB8IDB4ODA7XG5cbiAgLy8gW2J5dGUgOV0gOCBiaXRzIHNlcV9sb3dcbiAgYltpKytdID0gc2VxTG93ID4+PiA1ICYgMHhmZjtcblxuICAvLyBbYnl0ZSAxMF0gcmVtYWluaW5nIDUgYml0cyBzZXFfbG93LCAzIGJpdHMgcmFuZG9tXG4gIGJbaSsrXSA9IHNlcUxvdyA8PCAzICYgMHhmZiB8IHJuZHNbMTBdICYgMHgwNztcblxuICAvLyBbYnl0ZXMgMTEtMTVdIGFsd2F5cyByYW5kb21cbiAgYltpKytdID0gcm5kc1sxMV07XG4gIGJbaSsrXSA9IHJuZHNbMTJdO1xuICBiW2krK10gPSBybmRzWzEzXTtcbiAgYltpKytdID0gcm5kc1sxNF07XG4gIGJbaSsrXSA9IHJuZHNbMTVdO1xuICByZXR1cm4gYnVmIHx8IHVuc2FmZVN0cmluZ2lmeShiKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHY3OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v7.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js":
/*!****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDL0I7QUFDQSxxQ0FBcUMsaURBQUs7QUFDMUM7QUFDQSxpRUFBZSxRQUFRIiwic291cmNlcyI6WyIvVXNlcnMvYXZlcnkvdGVzdDIvYWdlbnQtY2hhdC11aS9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langsmith/run_trees.js":
/*!*********************************************!*\
  !*** ./node_modules/langsmith/run_trees.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),
/* harmony export */   convertToDottedOrderFormat: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.convertToDottedOrderFormat),
/* harmony export */   isRunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree),
/* harmony export */   isRunnableConfigLike: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunnableConfigLike)
/* harmony export */ });
/* harmony import */ var _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/run_trees.js */ "(ssr)/./node_modules/langsmith/dist/run_trees.js");


/***/ }),

/***/ "(ssr)/./node_modules/langsmith/singletons/traceable.js":
/*!********************************************************!*\
  !*** ./node_modules/langsmith/singletons/traceable.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton),
/* harmony export */   ROOT: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.ROOT),
/* harmony export */   getCurrentRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentRunTree),
/* harmony export */   isTraceableFunction: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.isTraceableFunction),
/* harmony export */   withRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.withRunTree)
/* harmony export */ });
/* harmony import */ var _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/singletons/traceable.js */ "(ssr)/./node_modules/langsmith/dist/singletons/traceable.js");


/***/ })

};
;